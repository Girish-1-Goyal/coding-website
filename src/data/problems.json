[
  {
    "data": {
      "question": {
        "questionId": "1",
        "questionFrontendId": "1",
        "title": "Two Sum",
        "content": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?",
        "likes": 61143,
        "dislikes": 2200,
        "stats": "{\"totalAccepted\": \"16.8M\", \"totalSubmission\": \"30.4M\", \"totalAcceptedRaw\": 16804550, \"totalSubmissionRaw\": 30358327, \"acRate\": \"55.4%\"}",
        "similarQuestions": "[{\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"4Sum\", \"titleSlug\": \"4sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum II - Input Array Is Sorted\", \"titleSlug\": \"two-sum-ii-input-array-is-sorted\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum III - Data structure design\", \"titleSlug\": \"two-sum-iii-data-structure-design\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Subarray Sum Equals K\", \"titleSlug\": \"subarray-sum-equals-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum IV - Input is a BST\", \"titleSlug\": \"two-sum-iv-input-is-a-bst\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Two Sum Less Than K\", \"titleSlug\": \"two-sum-less-than-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Max Number of K-Sum Pairs\", \"titleSlug\": \"max-number-of-k-sum-pairs\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Good Meals\", \"titleSlug\": \"count-good-meals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Number of Pairs With Absolute Difference K\", \"titleSlug\": \"count-number-of-pairs-with-absolute-difference-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Number of Pairs of Strings With Concatenation Equal to Target\", \"titleSlug\": \"number-of-pairs-of-strings-with-concatenation-equal-to-target\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All K-Distant Indices in an Array\", \"titleSlug\": \"find-all-k-distant-indices-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"First Letter to Appear Twice\", \"titleSlug\": \"first-letter-to-appear-twice\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Number of Excellent Pairs\", \"titleSlug\": \"number-of-excellent-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Arithmetic Triplets\", \"titleSlug\": \"number-of-arithmetic-triplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Node With Highest Edge Score\", \"titleSlug\": \"node-with-highest-edge-score\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check Distances Between Same Letters\", \"titleSlug\": \"check-distances-between-same-letters\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Subarrays With Equal Sum\", \"titleSlug\": \"find-subarrays-with-equal-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Largest Positive Integer That Exists With Its Negative\", \"titleSlug\": \"largest-positive-integer-that-exists-with-its-negative\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Number of Distinct Averages\", \"titleSlug\": \"number-of-distinct-averages\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Pairs Whose Sum is Less than Target\", \"titleSlug\": \"count-pairs-whose-sum-is-less-than-target\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.",
          "So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
          "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/567281997\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Brute Force\n\n**Algorithm**\n\nThe brute force approach is simple. Loop through each element $$x$$ and find if there is another value that equals to $$target - x$$.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/WTVGRyeD/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"WTVGRyeD\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(n^2)$$.\nFor each element, we try to find its complement by looping through the rest of the array which takes $$O(n)$$ time. Therefore, the time complexity is $$O(n^2)$$.\n\n* Space complexity: $$O(1)$$.\nThe space required does not depend on the size of the input array, so only constant space is used.\n\n---\n### Approach 2: Two-pass Hash Table\n\n**Intuition**\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from $$O(n)$$ to $$O(1)$$ by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in *near* constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to $$O(n)$$ time. However, lookup in a hash table should be amortized $$O(1)$$ time as long as the hash function was chosen carefully.\n\n**Algorithm**\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement ($$target - nums[i]$$) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be $$nums[i]$$ itself!\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/bbEpXJcf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bbEpXJcf\"></iframe>  \n\n**Complexity Analysis**\n\n* Time complexity: $$O(n)$$.\nWe traverse the list containing $$n$$ elements exactly twice. Since the hash table reduces the lookup time to $$O(1)$$, the overall time complexity is $$O(n)$$.\n\n* Space complexity: $$O(n)$$.\nThe extra space required depends on the number of items stored in the hash table, which stores exactly $$n$$ elements.\n\n---\n### Approach 3: One-pass Hash Table\n\n**Algorithm**\n    \nIt turns out we can do it in one-pass. While we are iterating and inserting elements into the hash table, we also look back to check if current element's complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.\n\n**Implementation**    \n    \n<iframe src=\"https://leetcode.com/playground/4KK3DMtw/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4KK3DMtw\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(n)$$.\nWe traverse the list containing $$n$$ elements only once. Each lookup in the table costs only $$O(1)$$ time.\n\n* Space complexity: $$O(n)$$.\nThe extra space required depends on the number of items stored in the hash table, which stores at most $$n$$ elements."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/two-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "2",
        "questionFrontendId": "2",
        "title": "Add Two Numbers",
        "content": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,0,8]\n<strong>Explanation:</strong> 342 + 465 = 807.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>Output:</strong> [8,9,9,9,0,0,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n",
        "likes": 33251,
        "dislikes": 6683,
        "stats": "{\"totalAccepted\": \"5.6M\", \"totalSubmission\": \"12.3M\", \"totalAcceptedRaw\": 5611521, \"totalSubmissionRaw\": 12269147, \"acRate\": \"45.7%\"}",
        "similarQuestions": "[{\"title\": \"Multiply Strings\", \"titleSlug\": \"multiply-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Two Integers\", \"titleSlug\": \"sum-of-two-integers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Strings\", \"titleSlug\": \"add-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Two Numbers II\", \"titleSlug\": \"add-two-numbers-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add to Array-Form of Integer\", \"titleSlug\": \"add-to-array-form-of-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Two Polynomials Represented as Linked Lists\", \"titleSlug\": \"add-two-polynomials-represented-as-linked-lists\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Double a Number Represented as a Linked List\", \"titleSlug\": \"double-a-number-represented-as-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Elementary Math\n\n**Intuition**\n\nKeep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\n\n![Illustration of Adding two numbers](../Figures/2_add_two_numbers.svg){:width=\"539px\"}\n\n\n*Figure 1. Visualization of the addition of two numbers: $$342 + 465 = 807$$.  \nEach node contains a single digit and the digits are stored in reverse order.*\n\n\n**Algorithm**\n\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $$l1$$ and $$l2$$. Since each digit is in the range of $$0 \\ldots 9$$, summing two digits may \"overflow\". For example $$5 + 7 = 12$$. In this case, we set the current digit to $$2$$ and bring over the $$carry = 1$$ to the next iteration. $$carry$$ must be either $$0$$ or $$1$$ because the largest possible sum of two digits (including the carry) is $$9 + 9 + 1 = 19$$.\n\nThe pseudocode is as following:\n\n* Initialize current node to dummy head of the returning list.\n* Initialize carry to $$0$$.\n* Loop through lists $$l1$$ and $$l2$$ until you reach both ends and carry is $$0$$.\n    * Set $$x$$ to node $$l1$$'s value. If $$l1$$ has reached the end of $$l1$$, set to $$0$$.\n    * Set $$y$$ to node $$l2$$'s value. If $$l2$$ has reached the end of $$l2$$, set to $$0$$.\n    * Set $$sum = x + y + carry$$.\n    * Update $$carry = sum / 10$$.\n    * Create a new node with the digit value of $$(sum \\bmod 10)$$ and set it to current node's next, then advance current node to next.\n    * Advance both $$l1$$ and $$l2$$.\n* Return dummy head's next node.\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\nTake extra caution of the following cases:\n\n| Test case | Explanation |\n| ------------- | ---------------- |\n| $$l1=[0,1]$$<br>$$l2=[0,1,2]$$ | When one list is longer than the other. |\n| $$l1=[]$$<br>$$l2=[0,1]$$ | When one list is null, which means an empty list. |\n| $$l1=[9,9]$$<br>$$l2=[1]$$ | The sum could have an extra carry of one at the end, which is easy to forget. |\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/XsLdm2AA/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"XsLdm2AA\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(\\max(m, n))$$. Assume that $$m$$ and $$n$$ represents the length of $$l1$$ and $$l2$$ respectively, the algorithm above iterates at most $$\\max(m, n)$$ times.\n\n* Space complexity : $$O(1)$$. The length of the new list is at most $$\\max(m,n) + 1$$ However, we don't count the answer as part of the space complexity.\n\n**Follow up**\n\nWhat if the the digits in the linked list are stored in non-reversed order? For example:\n\n$$\n(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7\n$$"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/add-two-numbers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "3",
        "questionFrontendId": "3",
        "title": "Longest Substring Without Repeating Characters",
        "content": "<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <span data-keyword=\"substring-nonempty\"><strong>substring</strong></span> without duplicate characters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbbb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pwwkew&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n",
        "likes": 41683,
        "dislikes": 2017,
        "stats": "{\"totalAccepted\": \"7.2M\", \"totalSubmission\": \"19.8M\", \"totalAcceptedRaw\": 7242517, \"totalSubmissionRaw\": 19811150, \"acRate\": \"36.6%\"}",
        "similarQuestions": "[{\"title\": \"Longest Substring with At Most Two Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-two-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Substring with At Most K Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-k-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Subarrays with K Different Integers\", \"titleSlug\": \"subarrays-with-k-different-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Erasure Value\", \"titleSlug\": \"maximum-erasure-value\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Equal Count Substrings\", \"titleSlug\": \"number-of-equal-count-substrings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Consecutive Cards to Pick Up\", \"titleSlug\": \"minimum-consecutive-cards-to-pick-up\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Nice Subarray\", \"titleSlug\": \"longest-nice-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Optimal Partition of String\", \"titleSlug\": \"optimal-partition-of-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Complete Subarrays in an Array\", \"titleSlug\": \"count-complete-subarrays-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Longest Special Substring That Occurs Thrice II\", \"titleSlug\": \"find-longest-special-substring-that-occurs-thrice-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Longest Special Substring That Occurs Thrice I\", \"titleSlug\": \"find-longest-special-substring-that-occurs-thrice-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "4",
        "questionFrontendId": "4",
        "title": "Median of Two Sorted Arrays",
        "content": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "likes": 29819,
        "dislikes": 3354,
        "stats": "{\"totalAccepted\": \"3.3M\", \"totalSubmission\": \"7.6M\", \"totalAcceptedRaw\": 3288268, \"totalSubmissionRaw\": 7602196, \"acRate\": \"43.3%\"}",
        "similarQuestions": "[{\"title\": \"Median of a Row Wise Sorted Matrix\", \"titleSlug\": \"median-of-a-row-wise-sorted-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Divide and Conquer"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n <div class='video-preview'></div>\n\n## Solution\n\n--- \n\n### Overview\n\nIn this problem, we are given two **sorted** arrays, `nums1` and `nums2`. We need to return the **median** of these two arrays.\n\n---\n\n### Approach 1: Merge Sort\n\n#### Intuition   \n\nLet's start with the straightforward approach. If we put the elements of two arrays in one array `A` and arrange them in order. Assume the merged arrays has a length of `n`, then the median is:\n    - `A[n / 2]`, if `n` is odd.\n    - The average of `A[n / 2]` and `A[n / 2 + 1]`, if `n` is even.\n\nHowever, we do not really need to merge and sort these arrays. Note that both arrays are already sorted, so the smallest element is either the first element of `nums1` or the first element of `nums2`. Therefore, we can set two pointers `p1` and `p2` at the start of each array, then we can get the smallest element from the `nums1` and `nums2` by comparing the values `nums1[p1]` and `nums2[p2]`.\n\nPlease refer to the following slide as an example:\n\n!?!../Documents/4/s1.json:601,301!?!\n\n\n<br>\n\n#### Algorithm\n\n1) Get the total size of two arrays `m + n`\n    - If `m + n` is odd, we are looking for the `(m + n) / 2`-th element.\n    - If `m + n` is even, we are looking for the average of the `(m + n) / 2`-th and the `(m + n) / 2 + 1`-th elements.\n2) Set two pointers `p1` and `p2` at the beginning of arrays `nums1` and `nums2`. \n3) If both `p1` and `p2` are in bounds of the arrays, compare the values at `p1` and `p2`:\n\n    - If `nums1[p1]` is smaller than `nums2[p2]`, we move `p1` one place to the right.\n    - Otherwise, we move `p2` one place to the right.\n\n    If `p1` is outside `nums1`, just move `p2` one place to the right.     \n    If `p2` is outside `nums2`, just move `p1` one place to the right.\n4) Get the target elements and calculate the median:\n    - If `m + n` is odd, repeat step 3 by `(m + n + 1) / 2` times and return the element from the last step.\n    - If `m + n` is even, repeat step 3 by `(m + n) / 2 + 1` times and return the average of the elements from the last two steps.\n\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/76VATgZB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"76VATgZB\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(m + n)$$\n\n    - We get the smallest element by comparing two values at `p1` and `p2`, it takes $$O(1)$$ to compare two elements and move the corresponding pointer to the right.\n    - We need to traverse half of the arrays before reaching the median element(s).\n    - To sum up, the time complexity is $$O(m + n)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - We only need to maintain two pointers `p1` and `p2`.\n\n<br/>\n\n\n\n---\n\n### Approach 2: Binary Search, Recursive\n\n#### Intuition   \n\nBecause the inputs are sorted arrays and the problem asks for a logarithmic time limit, we strongly feel that binary search (or a similar approach) is a promising method. While we're not sure how to cast the same pattern as a normal binary search on this problem, let's go over some steps of a regular binary search and see if we can get any inspiration. (If you are not familiar with binary search, you can refer to our [Binary Search Explore Card](https://leetcode.com/explore/learn/card/binary-search/))\n\n\nHere we use binary search to find `target` in a sorted array `A`:\n\n- Locate the middle index (element) of `A`.\n- Compare the value of the middle element with `target`.\n- Reduce the search space by cutting the current array in half and discarding the half which is guaranteed not to contain `target`.\n\n- Repeat the above process until we either empty the array (move to half a the length of 0) or find `target`.\n\n\n\n![img](../Figures/4/bs.png)\n\nAt each step, the search space is cut in half, so we can quickly get the result. Now back to this problem where we have two sorted arrays. For the sake of convenience, let's call them `A` and `B`. \n\n![img](../Figures/4/2.png)\n\nSimilarly, we can get and compare their middle values `A_mid` and `B_mid`. Without loss of generality in this example we assume `A_mid <= B_mid` initially, as shown in the yellow boxes. \n\n\n\n![img](../Figures/4/3.png)\n\n**What does this comparison imply?**\n\nIt implies that we can compare sections of `A` and `B`.\n\n> For the rest of this article, we will use $$\\le$$ to represent the relative magnitude of values in arrays. For example, $$A_{\\text{left}} \\le A_{\\text{right}}$$ means that every element in $A_{\\text{left}}$ is no larger than any element in $A_{\\text{right}}$. We also 'compare' elements in an array with a single element similarly, for example, $$A_{\\text{left}} \\le A_{\\text{mid}}$$ means that every element in $A_{\\text{left}}$ is no larger than the element $A_{\\text{mid}}$. \nThis may not be the most standard way of expressing it, but is easy enough to understand.\n\nRecall that both arrays are sorted, so we know that:\n- $$A_{\\text{left}} \\le A_{\\text{mid}}$$\n- $$B_{\\text{mid}} \\le B_{\\text{right}}$$\n\nCombine these observations with the comparison we just made:\n\n\n$$A_{\\text{mid}} \\le B_{\\text{mid}}$$\n\nWe have the following result:\n\n$$A_{\\text{left}} \\le A_{\\text{mid}} \\le B_{\\text{mid}} \\le B_{\\text{right}}$$\n\nThus, \n\n$$A_{\\text{left}} \\le B_{\\text{right}}$$\n\nAs shown in the picture below:\n\n![img](../Figures/4/4.png)\n\nSince `A` is sorted, we know that $$A_{\\text{left}} \\le A_{\\text{right}}$$.\n\n![img](../Figures/4/5.png)\n\n\nNow we know that `A_left` is smaller than two halves: `A_right` and `B_right`. Although we still don't know where exactly these elements are, what we do know is **`A_left` doesn't intersect with `A_right + B_right`**! There is an invisible boundary between the `A_left` segment and the mixed segment `A_right + B_right`. As shown in the picture below, the dashed line divides all sorted elements into two halves.\n\n\n\n![img](../Figures/4/6.png)\n\n\nWe can apply all the same logic to the mixed segment $$A_{\\text{left}}$$ + $$B_{\\text{left}}$$ and $$B_{\\text{right}}$$, which also do not intersect. You can try to prove it yourself as an exercise.\n\n\n![img](../Figures/4/7.png)\n\n\nIt looks somewhat clearer, we have clearly separated some subarrays. How do we continue to leverage this knowledge and use the cut-in-half method repeatedly?\n\n\n\n<br>\n\n**The following step is the most important one.**\n\n\nRemember that we are looking for the median of `sorted A + B` which is one or two target values. We regard the index of the target value in the `sorted(A + B)` as `k`. For example: \n\n- If the lengths of `A` and `B` are `6` and `5`, the target index is `k = (6 + 5 + 1) / 2 = 6`, we shall look for the 6th smallest element. \n\n- If the lengths of `A` and `B` are `6` and `6`, the target indexes are `k = (6 + 6) / 2 = 6` and `k + 1 = 7`, we shall look for the 6th and the 7th smallest elements. \n\n\n\nDepending on whether the total number of elements is odd or even, we need the $$k^{th}$$ (and maybe the $$(k + 1)^{th}$$) elements. What matters is that we set an index `k` at the beginning and we want to find the $$k^{th}$$ smallest element using the Binary Search-like algorithm discussed previously (for convenience, we will discuss only the $$k^{th}$$ element for now).\n\n\n\nHowever, during the Binary Search-like algorithm, we keep removing one half of an array, so the index `k` might not stay unchanged. Suppose we removed `3` elements that are smaller than the original $$k^{th}$$ smallest element, we shall look for the $$(k-3)^{th}$$ smallest element from the **remaining** arrays.\n\n\n![img](../Figures/4/exp_1.png)\n\nMore specifically:\n\nIf `k` is larger than half the total number of elements in `sorted(A + B)`, it means that the $$k^{th}$$ element is in the second (larger) half of `sorted(A + B)`, thus $$A_{\\text{left}}$$ (or $$B_{\\text{left}}$$, the smaller of the two smaller sections according to the comparison) is guaranteed not to contain this element, and we can safely cut this half, and reduce `k` by the length of the removed half.\n\n\nIf `k` is not larger than half the total number of elements in `sorted(A + B)`, it means that the $$k^{th}$$ element is in the first (smaller) half of `sorted(A + B)`, thus $$B_{\\text{right}}$$ (or $$A_{\\text{right}}$$, the larger of the two larger sections according to the comparison) is guaranteed not to contain this element, and we can safely discard it. Note that we don't need to modify `k` this time, since we removed one larger half that doesn't affect the order of the $$k^{th}$$ smallest element.\n\n\n\nWe can continue our search like above in the **remaining** arrays. The long arrow that starts from the bottom and points to the top-left indicates that we are repeating the process. Once we cut off part of either `A` or `B`, we regard the remaining arrays as modified `A` and `B` and restart this algorithm. Note that the following picture represents one case only: we consider the case that `a_value < b_value`, thus we remove either the smaller half of `A` or the larger half of `B`. If the comparison result is `a_value >= b_value`, we shall remove either the smaller half of `B` or the larger half of `A`.\n\n![img](../Figures/4/9.png)\n\n\nThat's it. We cut one of the two arrays in half at each step, so this approach has a logarithmic time complexity which we will discuss in detail later.\n\n\n> One more thing!\n\nIn the previous picture, we repeat all processes using the modified arrays, but this is just for the sake of understanding. We won't create copies of two arrays repeatedly, because that would introduce a linear time complexity at least. Instead, we just treat a part of the original array as the modified array for the next step, so that we can repeat the process on the original array without making any duplication. To do this, we need to maintain four pointers, two pointers for each array, e.g., `a_start` and `a_end` represent an inclusive range `[a_start, a_end]` of `A`.\n\n\n<br>\n\n#### Algorithm\n\nLet's define a function that helps us find the $$k^{th}$$ smallest element from two inclusive ranges `[a_start, a_end]` and `[b_start, b_end]` from arrays `A` and `B`.\n\n\n\n1) If the range (for example, a range of `A`) is empty, in other words `a_start > a_end`, it means all elements in `A` are passed, we just return the `(k - a_start)`-th element from the other array `B`. Vice versa if `b_start > b_end`.\n\n2) Otherwise, get the middle indexes of the two ranges: `a_index = (a_start + a_end) / 2`, `b_index = (b_start + b_end) / 2`.\n3) Get the middle values of the two ranges: `a_value = A[a_index]`, `b_value = B[b_index]`.\n4) Cut one array in half, according to:\n    - If `a_index + b_index < k`, cut one smaller half.\n        - If `a_value < b_value`, cut the smaller half of `A`.\n        - Otherwise, cut the smaller half of `B`.\n    - Otherwise, cut one larger half.\n        - If `b_value < a_value`, cut the larger half of `B`.\n        - Otherwise, cut the larger half of `A`.\n5) Repeat step 1 using the new starting and ending indexes of `A` and `B`.\n\n\nThen we move on to find the median elements, and get the length of both arrays `na = len(A)` and `nb = len(B)`.\n- If the total number of elements in `A` and `B` is odd, we just use the above function to find the middle element, that is `k = (na + nb) / 2`.\n- Otherwise, we use the function to find two middle elements: `k = (na + nb) / 2 - 1` and `k = (na + nb) / 2`, and return their average.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/EykqB3jM/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"EykqB3jM\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(\\log(m \\cdot n))$$\n\n\n    - At each step, we cut one half off from either `nums1` or `nums2`. If one of the arrays is emptied, we can directly get the target from the other array in a constant time. Therefore, the total time spent depends on when one of the arrays is cut into an empty array.\n    - In the worst-case scenario, we may need to cut both arrays before finding the target element.\n    - One of the two arrays is cut in half at each step, thus it takes logarithmic time to empty an array. The time to empty two arrays are independent of each other.\n\n    <br>\n    \n    ![img](../Figures/4/tc.png)\n\n    - Therefore, the time complexity is $$O(\\log m + \\log n)$$.\n     $$O(\\log m + \\log n) = O(\\log (m\\cdot n))$$\n    \n\n* Space complexity: $$O(\\log m + \\log n)$$\n\n    - Similar to the analysis on time complexity, the recursion steps depend on the number of iterations before we cut an array into an empty array. In the worst-case scenario, we need $$O(\\log m + \\log n)$$ recursion steps. \n    - However, during the recursive self-call, we only need to maintain 4 pointers: `a_start`, `a_end`, `b_start` and `b_end`. The last step of the function is to call itself, so if tail call optimization is implemented, the call stack always has $$O(1)$$ records.\n\n    - Please refer to [Tail Call](https://en.wikipedia.org/wiki/Tail_call) for more information on tail call optimization.\n\n<br/>\n\n\n\n---\n\n### Approach 3: A Better Binary Search\n\n\n#### Intuition   \n\nRecall the previous approach where we perform a binary search over the 'merged' array consisting of `nums1` and `nums2`, resulting in a time complexity of $$O(\\log(m \\cdot n))$$. We could further improve the algorithm by performing the binary search only on the smaller array of `nums1` and `nums2`, thus the time complexity is reduced to $$O(\\log(\\min(m, n)))$$.\n\n\nThe main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half. \n\n\nHowever, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array `A`). Suppose the partition index is `partitionA`, we specify that the smaller half contains `(m + n + 1) / 2` elements, and we can use this feature to our advantage by directly making `partitionB` equal to `(m + n + 1) / 2 - partitionA`, thus the smaller halves of both arrays always contain a total of `(m + n + 1) / 2` elements, as shown in the picture below.\n\n![img](../Figures/4/2_0.png)\n\nThe next step is to compare these edge elements.\n\n![img](../Figures/4/2_1.png)\n\nIf both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` hold, it means that we have partitioned arrays at the correct place. \n\n- The smaller half consists of two sections `A_left` and `B_left`\n- THe larger half consists of two sections `A_right` and `B_right`\n\nWe just need to find the maximum value from the smaller half as `max(A[maxLeftA], B[maxLeftB])` and the minimum value from the larger half as `min(A[minRightA], B[minRightB])`. The median value depends on these four boundary values and the total length of the input arrays and we can compute it by situation.\n\n![img](../Figures/4/2_2.png)\n\nIf `maxLeftA > minRightB`, it implies that `maxLeftA` is **too large to be in the smaller half** and we should look for a smaller partition value of `A`. \n\n\n![img](../Figures/4/2_3.png)\n\nOtherwise, it denotes that `minRightA` is **too small to be in the larger half** and we should look for a larger partition value of `A`.\n\n![img](../Figures/4/2_4.png)\n\n\n<br>\n\n#### Algorithm\n\n1) Assuming `nums1` to be the smaller array (If `nums2` is smaller, we can swap them). Let `m, n` represent the size of `nums1` and `nums2`, respectively.\n\n2) Define the search space for the partitioning index `partitionA` by setting boundaries as `left = 0` and `right = m`.\n\n3) While `left <= right` holds, do the following.\n\n4) Compute the partition index of `nums1` as `partitionA = (left + right) / 2`. Consequently, the partition index of `nums2` is `(m + n + 1) / 2 - partitionA`.\n\n5) Obtain the edge elements:\n    - Determine the maximum value of the section `A_left` as `maxLeftA = nums1[partitionA - 1]`. If `partitionA - 1 < 0`, set it as `maxLeftA = float(-inf)`.\n    - Determine the minimum value of the section `A_right` as `minRightA = nums1[partitionA]`. If `partitionA >= m`, set it as `minRightA = float(inf)`.\n    - Determine the maximum value of the section `B_left` as `maxLeftB = nums2[partitionB - 1]`. If `partitionB - 1 < 0`, set it as `maxLeftB = float(-inf)`.\n    - Determine the maximum value of the section `B_right` as `minRightB = nums2[partitionB]`. If `partitionB >= n`, set it as `minRightB = float(inf)`.\n\n\n6) Compare and recalculate: Compare `maxLeftA` with `minRightB` and `maxLeftB` with `minRightA`. \n    - If `maxLeftA > minRightB`, it means the `maxLeftA` is too large to be in the smaller half, so we update `right = partitionA - 1` to move to the left half of the search space.\n    - If `maxLeftB > minRightA`, it means that we are too far on the left side for `partitionA` and we need to go to the right half of the search space by updating `left = partitionA + 1`. \n\n    Repeat step 4.\n\n7) When both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` are true:\n    - If `(m + n) % 2 = 0`, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by `answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2`.\n    - Otherwise, the median value is the maximum value of the smaller half, given by `answer = max(maxLeftA, maxLeftB)`.\n\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/4xFHzYdC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4xFHzYdC\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(\\log(\\min(m, n)))$$\n\n    - We perform a binary search over the smaller array of size $$\\min(m, n)$$.\n\n* Space complexity: $$O(1)$$\n\n    - The algorithm only requires a constant amount of additional space to store and update a few parameters during the binary search.\n\n<br/>"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "5",
        "questionFrontendId": "5",
        "title": "Longest Palindromic Substring",
        "content": "<p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword=\"palindromic-string\"><em>palindromic</em></span> <span data-keyword=\"substring-nonempty\"><em>substring</em></span> in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babad&quot;\n<strong>Output:</strong> &quot;bab&quot;\n<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbbd&quot;\n<strong>Output:</strong> &quot;bb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consist of only digits and English letters.</li>\n</ul>\n",
        "likes": 30585,
        "dislikes": 1887,
        "stats": "{\"totalAccepted\": \"3.7M\", \"totalSubmission\": \"10.6M\", \"totalAcceptedRaw\": 3746657, \"totalSubmissionRaw\": 10553101, \"acRate\": \"35.5%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation\", \"titleSlug\": \"palindrome-permutation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Palindrome Pairs\", \"titleSlug\": \"palindrome-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Palindromic Subsequence\", \"titleSlug\": \"longest-palindromic-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindromic Substrings\", \"titleSlug\": \"palindromic-substrings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Non-overlapping Palindrome Substrings\", \"titleSlug\": \"maximum-number-of-non-overlapping-palindrome-substrings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "How can we reuse a previously computed palindrome to compute a larger palindrome?",
          "If \u201caba\u201d is a palindrome, is \u201cxabax\u201d a palindrome? Similarly is \u201cxabay\u201d a palindrome?",
          "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
        ],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n <div class='video-preview'></div>\n\n\n## Solution\n\n---\n\n### Approach 1: Check All Substrings\n\n**Intuition**\n\nWe can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the longest one that is.\n\nFirst, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second character is equal to the second last character, and so on.\n\n![Palindrome Check](../Figures/5/1.png)\n\nWe initialize two pointers: one at the start of the string and another at the end of it. We check if the characters at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome.\n\nOne bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a string of length `1000` and the third and third last characters did not match, we would exit the algorithm after only 3 iterations.\n\nThere's another optimization that we can do. Because the problem wants the longest palindrome, we can start by checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we find a substring that is a palindrome, we can immediately return it as the answer.\n\n**Algorithm**\n\n1. Create a helper method `check(i, j)` to determine if a substring is a palindrome.\n    - To save space, we will not pass the substring itself. Instead, we will pass two indices that represent the substring in question. The first character will be `s[i]` and the last character will be `s[j - 1]`.\n    - In this function, declare two pointers `left = i` and `right = j - 1`.\n    - While `left < right`, do the following steps:\n    - If `s[left] != s[right]`, return `false`.\n    - Otherwise, increment `left` and decrement `right`.\n    - If we get through the while loop, return `true`.\n2. Use a for loop to iterate a variable `length` starting from `s.length` until `1`. This variable represents the length of the substrings we are currently considering.\n3. Use a for loop to iterate a variable `start` starting from `0` until and including `s.length - length`. This variable represents the starting point of the substring we are currently considering.\n4. In each inner loop iteration, we are considering the substring starting at `start` until `start + length`. Pass these values into `check` to see if this substring is a palindrome. If it is, return the substring.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/nzeDdUw9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"nzeDdUw9\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^3)$$\n\n    The two nested for loops iterate $$O(n^2)$$ times. We check one substring of length `n`, two substrings of length `n - 1`, three substrings of length `n - 2`, and so on.\n\n    There are `n` substrings of length 1, but we don't check them all since any substring of length 1 is a palindrome, and we will return immediately.\n\n    Therefore, the number of substrings that we check in the worst case is `1 + 2 + 3 + ... + n - 1`. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums) for `n - 1`, which is equal to $$\\frac{n \\cdot (n - 1)}{2} = O(n^2)$$.\n\n    In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with `n` as well, giving us a time complexity of $$O(n^3)$$.\n\n    Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm is not too bad.\n\n* Space complexity: $$O(1)$$\n\n    We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables. \n    \n<br/>\n\n---\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nLet's say that we knew the substring with inclusive bounds `i, j` was a palindrome. If `s[i - 1] == s[j + 1]`, then we know the substring with inclusive bounds `i - 1, j + 1` must also be a palindrome, and this check can be done in constant time.\n\nWe can flip the direction of this logic as well - if `s[i] == s[j]` and the substring `i + 1, j - 1` is a palindrome, then the substring `i, j` must also be a palindrome.\n\n![DP Example](../Figures/5/2.png)\n\nWe know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a palindrome using the above fact. We just need to check every `i, j` pair where `j - i = 2`. Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then 7, and so on.\n\nWhat about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is, `i, i + 1` is a palindrome if `s[i] == s[i + 1]`. From this, we can use the earlier logic to find all palindromes of length 4, then 6, and so on.\n\nLet's use a table `dp` with dimensions of `n * n`. `dp[i][j]` is a boolean representing if the substring with inclusive bounds `i, j` is a palindrome. We initialize `dp[i][i] = true` for the substrings of length 1, and then `dp[i][i + 1] = (s[i] == s[i + 1])` for the substrings of length 2.\n\nNow, we need to populate the table. We iterate over all `i, j` pairs, starting with pairs that have a difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For each `i, j` pair, we check the condition from earlier:\n\n`s[i] == s[j] && dp[i + 1][j - 1]`\n\nIf this condition is true, then the substring with inclusive bounds `i, j` must be a palindrome. We set `dp[i][j] = true`.\n\nBecause we are starting with the shortest substrings and iterating toward the longest substrings, every time we find a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer on the fly.\n\n**Algorithm**\n\n1. Initialize `n = s.length` and a boolean table `dp` with size `n * n`, and all values to `false`.\n2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer.\n3. Set all `dp[i][i] = true`.\n4. Iterate over all pairs `i, i + 1`. For each one, if `s[i] == s[i + 1]`, then set `dp[i][i + 1] = true` and update `ans = [i, i + 1]`.\n5. Now, we populate the `dp` table. Iterate over `diff` from `2` until `n`. This variable represents the difference `j - i`.\n6. In a nested for loop, iterate over `i` from `0` until `n - diff`.\n    - Set `j = i + diff`.\n    - Check the condition: if `s[i] == s[j] && dp[i + 1][j - 1]`, we found a palindrome.\n    - In that case, set `dp[i][j] = true` and `ans = [i, j]`\n\n7. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/futnTSvZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"futnTSvZ\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    We declare an `n * n` table `dp`, which takes $$O(n^2)$$ time. We then populate $$O(n^2)$$ states `i, j` - each state takes $$O(1)$$ time to compute.\n\n* Space complexity: $$O(n^2)$$\n\n    The table `dp` takes $$O(n^2)$$ space.\n    \n<br/>\n\n---\n\n### Approach 3: Expand From Centers\n\n**Intuition**\n\nIn the first approach, the palindrome check cost $$O(n)$$. In the second approach, the palindrome check cost $$O(1)$$. This allowed us to improve the time complexity from $$O(n^3)$$ to $$O(n^2)$$.\n\nThe problem with the second approach is that we **always** iterated over $$O(n^2)$$ states of `i, j`. Can we optimize further to minimize the number of iterations required?\n\nIn the first approach, we implemented a palindrome check using two pointers. We started by checking the first and last characters, then the second and second last characters, and so on.\n\nInstead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had `s = \"racecar\"`. If we start both pointers at the middle (`\"e\"`) and move them away from each other, we can see that at every iteration, the characters match: `e -> c -> a -> r`.\n\nThe previous two approaches focused on the bounds of a substring - `i, j`. There are $$O(n^2)$$ bounds, but only $$O(n)$$ centers. For each index `i`, we can consider odd-length palindromes by starting the pointers at `i, i`. To consider the even length palindromes, we can start the pointers at `i, i + 1`. There are $$n$$ starting points for the odd-length palindromes and $$n - 1$$ starting points for the even-length palindromes - that's $$2n - 1 = O(n)$$ starting points in total.\n\nThis is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the bounds. Let's use a helper method `expand(i, j)` that starts two pointers `left = i` and `right = j`. In this method, we will consider `i, j` as a center. When `i == j`, we are considering odd-length palindromes. When `i != j`, we are considering even-length palindromes. We will expand from the center as far as we can to find the longest palindrome, and then return the length of this palindrome.\n\nLet's say that we have a center `i, i`. We call `expand` and find a length of `length`. What are the bounds of the palindrome? Because we are centered at `i, i`, it means `length` must be odd. If we perform floor division of `length` by 2, we will get the number of characters `dist` on each side of the palindrome. For example, given `s = \"racecar\"`, we have `length = 7` and `dist = 7 / 2 = 3`. There are 3 characters on each side - `\"rac\"` on the left and `\"car\"` on the right. Therefore, we can determine that the bounds of the palindrome are `i - dist, i + dist`.\n\nWhat about a center at `i, i + 1`? `length` must be even now. If we have a palindrome with length `2`, then `length / 2 = 1`, but there are zero characters on each side of the center. We can see that `dist` is too large by 1. Therefore, we will calculate `dist` as `(length / 2) - 1` instead. Now, `dist` correctly represents the number of characters on each side. The bounds of the palindrome are `i - dist, i + 1 + dist`.\n\n**Algorithm**\n\n1. Create a helper method `expand(i, j)` to find the length of the longest palindrome centered at `i, j`.\n    - Set `left = i` and `right = j`.\n    - While `left` and `right` are both in bounds and `s[left] == s[right]`, move the pointers away from each other.\n    - The formula for the length of a substring starting at `left` and ending at `right` is `right - left + 1`.\n    - However, when the while loop ends, it implies `s[left] != s[right]`. Therefore, we need to subtract `2`. Return `right - left - 1`.\n2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer.\n3. Iterate `i` over all indices of `s`.\n    - Find the length of the longest odd-length palindrome centered at `i`: `oddLength = expand(i, i)`.\n    - If `oddLength` is the greatest length we have seen so far, i.e. `oddLength > ans[1] - ans[0] + 1`, update `ans`.\n    - Find the length of the longest odd-length palindrome centered at `i`: `evenLength = expand(i, i + 1)`.\n    - If `evenLength` is the greatest length we have seen so far, update `ans`.\n4. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/oTLQzLEK/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"oTLQzLEK\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    There are $$2n - 1 = O(n)$$ centers. For each center, we call `expand`, which costs up to $$O(n)$$.\n\n    Although the time complexity is the same as in the DP approach, the average/practical runtime of the algorithm is much faster. This is because most centers will not produce long palindromes, so most of the $$O(n)$$ calls to `expand` will cost far less than $$n$$ iterations.\n\n    The worst case scenario is when every character in the string is the same.\n\n* Space complexity: $$O(1)$$\n\n    We don't use any extra space other than a few integers. This is a big improvement on the DP approach.\n    \n<br/>\n\n---\n\n### Approach 4: Manacher's Algorithm\n\nBelieve it or not, this problem can be solved in linear time.\n\n[Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) finds the longest palindromic substring in $$O(n)$$ time and space.\n\nNote: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews.\n\nIf you wish to learn more about Manacher's algorithm, please reference the above link.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/5JHr3EVn/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"5JHr3EVn\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n)$$\n\n    From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same algorithm):\n\n    > The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the first inner loop is linear in the increase of the sum Center + Radius while the number of operations in the second inner loop is linear in the increase of Center. Since Center $$\\leq$$ 2n+1 and Radius $$\\leq$$ n, the total number of operations in the first and second inner loops is $$O(n)$$ and the total number of operations in the outer loop, other than those in the inner loops, is also $$O(n)$$. The overall running time is therefore $$O(n)$$.\n\n* Space complexity: $$O(n)$$\n\n    We use `sPrime` and `palindromeRadii`, both of length $$O(n)$$.\n    \n<br/>\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-palindromic-substring/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "6",
        "questionFrontendId": "6",
        "title": "Zigzag Conversion",
        "content": "<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\n<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>\n\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n\n<pre>\nstring convert(string s, int numRows);\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 3\n<strong>Output:</strong> &quot;PAHNAPLSIIGYIR&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 4\n<strong>Output:</strong> &quot;PINALSIGYAHRPI&quot;\n<strong>Explanation:</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A&quot;, numRows = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), <code>&#39;,&#39;</code> and <code>&#39;.&#39;</code>.</li>\n\t<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>\n",
        "likes": 8388,
        "dislikes": 15277,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 1704082, \"totalSubmissionRaw\": 3335432, \"acRate\": \"51.1%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/zigzag-conversion/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "7",
        "questionFrontendId": "7",
        "title": "Reverse Integer",
        "content": "<p>Given a signed 32-bit integer <code>x</code>, return <code>x</code><em> with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then return <code>0</code>.</p>\n\n<p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 123\n<strong>Output:</strong> 321\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -123\n<strong>Output:</strong> -321\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 120\n<strong>Output:</strong> 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 13993,
        "dislikes": 13748,
        "stats": "{\"totalAccepted\": \"4M\", \"totalSubmission\": \"13.2M\", \"totalAcceptedRaw\": 3954775, \"totalSubmissionRaw\": 13175250, \"acRate\": \"30.0%\"}",
        "similarQuestions": "[{\"title\": \"String to Integer (atoi)\", \"titleSlug\": \"string-to-integer-atoi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reverse Bits\", \"titleSlug\": \"reverse-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"A Number After a Double Reversal\", \"titleSlug\": \"a-number-after-a-double-reversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Number of Distinct Integers After Reverse Operations\", \"titleSlug\": \"count-number-of-distinct-integers-after-reverse-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Pop and Push Digits & Check before Overflow\n\n**Intuition**\n\nWe can build up the reverse integer one digit at a time.\nWhile doing so, we can check beforehand whether or not appending another digit would cause overflow.\n\n**Algorithm**\n\nReversing an integer can be done similarly to reversing a string.\n\nWe want to repeatedly \"pop\" the last digit off of $$x$$ and \"push\" it to the back of the $$\\text{rev}$$. In the end, $$\\text{rev}$$ will be the reverse of the $$x$$.\n\nTo \"pop\" and \"push\" digits without the help of some auxiliary stack/array, we can use math.\n\n```cpp\n// pop operation:\npop = x % 10;\nx /= 10;\n\n// push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n\nHowever, this approach is dangerous, because the statement $$\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}$$ can cause overflow.\n\nLuckily, it is easy to check beforehand whether or this statement would cause an overflow.\n\nTo explain, lets assume that $$\\text{rev}$$ is positive.\n\n1. If $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ causes overflow, then it must be that $$\\text{rev} \\geq \\frac{INTMAX}{10}$$\n2. If $$\\text{rev} > \\frac{INTMAX}{10}$$, then $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ is guaranteed to overflow.\n3. If $$\\text{rev} == \\frac{INTMAX}{10}$$, then $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ will overflow if and only if $$\\text{pop} > 7$$\n\nSimilar logic can be applied when $$\\text{rev}$$ is negative.\n\n<iframe src=\"https://leetcode.com/playground/fm5j6WLP/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"fm5j6WLP\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(\\log(x))$$. There are roughly $$\\log_{10}(x)$$ digits in $$x$$.\n* Space Complexity: $$O(1)$$."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-integer/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "8",
        "questionFrontendId": "8",
        "title": "String to Integer (atoi)",
        "content": "<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer.</p>\n\n<p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p>\n\n<ol>\n\t<li><strong>Whitespace</strong>: Ignore any leading whitespace (<code>&quot; &quot;</code>).</li>\n\t<li><strong>Signedness</strong>: Determine the sign by checking if the next character is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>, assuming positivity if neither present.</li>\n\t<li><strong>Conversion</strong>: Read the integer by skipping leading zeros&nbsp;until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.</li>\n\t<li><strong>Rounding</strong>: If the integer is out of the 32-bit signed integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then round the integer to remain in the range. Specifically, integers less than <code>-2<sup>31</sup></code> should be rounded to <code>-2<sup>31</sup></code>, and integers greater than <code>2<sup>31</sup> - 1</code> should be rounded to <code>2<sup>31</sup> - 1</code>.</li>\n</ol>\n\n<p>Return the integer as the final result.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;42&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">42</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: &quot;42&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>42</u>&quot; (&quot;42&quot; is read in)\n           ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot; -042&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-42</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nStep 1: &quot;<u>   </u>-042&quot; (leading whitespace is read and ignored)\n            ^\nStep 2: &quot;   <u>-</u>042&quot; (&#39;-&#39; is read, so the result should be negative)\n             ^\nStep 3: &quot;   -<u>042</u>&quot; (&quot;042&quot; is read in, leading zeros ignored in the result)\n               ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;1337c0d3&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1337</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nStep 1: &quot;1337c0d3&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;1337c0d3&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>1337</u>c0d3&quot; (&quot;1337&quot; is read in; reading stops because the next character is a non-digit)\n             ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;0-1&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nStep 1: &quot;0-1&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;0-1&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>0</u>-1&quot; (&quot;0&quot; is read in; reading stops because the next character is a non-digit)\n          ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;words and 987&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Reading stops at the first non-digit character &#39;w&#39;.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li>\n</ul>\n",
        "likes": 5221,
        "dislikes": 14563,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"10.1M\", \"totalAcceptedRaw\": 1915419, \"totalSubmissionRaw\": 10132034, \"acRate\": \"18.9%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Integer\", \"titleSlug\": \"reverse-integer\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Number\", \"titleSlug\": \"valid-number\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if Numbers Are Ascending in a Sentence\", \"titleSlug\": \"check-if-numbers-are-ascending-in-a-sentence\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/string-to-integer-atoi/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "9",
        "questionFrontendId": "9",
        "title": "Palindrome Number",
        "content": "<p>Given an integer <code>x</code>, return <code>true</code><em> if </em><code>x</code><em> is a </em><span data-keyword=\"palindrome-integer\"><em><strong>palindrome</strong></em></span><em>, and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 121\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -121\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 10\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without converting the integer to a string?",
        "likes": 13830,
        "dislikes": 2804,
        "stats": "{\"totalAccepted\": \"6.2M\", \"totalSubmission\": \"10.5M\", \"totalAcceptedRaw\": 6166383, \"totalSubmissionRaw\": 10473207, \"acRate\": \"58.9%\"}",
        "similarQuestions": "[{\"title\": \"Palindrome Linked List\", \"titleSlug\": \"palindrome-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Palindrome With Fixed Length\", \"titleSlug\": \"find-palindrome-with-fixed-length\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Strictly Palindromic Number\", \"titleSlug\": \"strictly-palindromic-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"  Count Symmetric Integers\", \"titleSlug\": \"count-symmetric-integers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Count of Good Integers\", \"titleSlug\": \"find-the-count-of-good-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Largest Palindrome Divisible by K\", \"titleSlug\": \"find-the-largest-palindrome-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Beware of overflow when you reverse the integer."
        ],
        "topicTags": [
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/palindrome-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "10",
        "questionFrontendId": "10",
        "title": "Regular Expression Matching",
        "content": "<p>Given an input string <code>s</code>&nbsp;and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;.&#39;</code> Matches any single character.\u200b\u200b\u200b\u200b</li>\n\t<li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, p = &quot;.*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and&nbsp;<code>&#39;*&#39;</code>.</li>\n\t<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>\n</ul>\n",
        "likes": 12643,
        "dislikes": 2275,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 1132793, \"totalSubmissionRaw\": 3895704, \"acRate\": \"29.1%\"}",
        "similarQuestions": "[{\"title\": \"Wildcard Matching\", \"titleSlug\": \"wildcard-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursion\n\n**Intuition**\n\nIf there were no Kleene stars (the `*` wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.\n\nWhen a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.\n\n**Algorithm**\n\nWithout a Kleene star, our solution would look like this:\n\n\n<iframe src=\"https://leetcode.com/playground/WHCkKfaZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"WHCkKfaZ\"></iframe>\n\nIf a star is present in the pattern, it will be in the second position $$\\text{pattern[1]}$$.  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.\n\n<iframe src=\"https://leetcode.com/playground/QZA8SsdJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"QZA8SsdJ\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: Let $$T, P$$ be the lengths of the text and the pattern respectively.  In the worst case, a call to `match(text[i:], pattern[2j:])` will be made $$\\binom{i+j}{i}$$ times, and strings of the order $$O(T - i)$$ and $$O(P - 2*j)$$ will be made.  Thus, the complexity has the order $$\\sum_{i = 0}^T \\sum_{j = 0}^{P/2} \\binom{i+j}{i} O(T+P-i-2j)$$.  With some effort outside the scope of this article, we can show this is bounded by $$O\\big((T+P)2^{T + \\frac{P}{2}}\\big)$$.\n\n* Space Complexity:  For every call to `match`, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of $$O\\big((T+P)2^{T + \\frac{P}{2}}\\big)$$ space, even though there are only order $$O(T^2 + P^2)$$ unique suffixes of $$P$$ and  $$T$$ that are actually required.\n<br />\n<br />\n\n---\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nAs the problem has an **optimal substructure**, it is natural to cache intermediate results.  We ask the question $$\\text{dp(i, j)}$$: does $$\\text{text[i:]}$$ and $$\\text{pattern[j:]}$$ match?  We can describe our answer in terms of answers to questions involving smaller strings.\n\n**Algorithm**\n\nWe proceed with the same recursion as in [Approach 1](#approach-1-recursion), except because calls will only ever be made to `match(text[i:], pattern[j:])`, we use $$\\text{dp(i, j)}$$ to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.\n\n\n*Top-Down Variation*\n<iframe src=\"https://leetcode.com/playground/cXs5KPLc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"cXs5KPLc\"></iframe>\n\n*Bottom-Up Variation*\n\n<iframe src=\"https://leetcode.com/playground/GnSNNEQb/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"GnSNNEQb\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: Let $$T, P$$ be the lengths of the text and the pattern respectively.  The work for every call to `dp(i, j)` for $$i=0, ... ,T$$; $$j=0, ... ,P$$ is done once, and it is $$O(1)$$ work.  Hence, the time complexity is $$O(TP)$$.\n\n* Space Complexity:  The only memory we use is the $$O(TP)$$ boolean entries in our cache.  Hence, the space complexity is $$O(TP)$$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/regular-expression-matching/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "11",
        "questionFrontendId": "11",
        "title": "Container With Most Water",
        "content": "<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>\n\n<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>\n\n<p>Return <em>the maximum amount of water a container can store</em>.</p>\n\n<p><strong>Notice</strong> that you may not slant the container.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" style=\"width: 600px; height: 287px;\" />\n<pre>\n<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]\n<strong>Output:</strong> 49\n<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [1,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 30991,
        "dislikes": 1973,
        "stats": "{\"totalAccepted\": \"3.9M\", \"totalSubmission\": \"6.9M\", \"totalAcceptedRaw\": 3933042, \"totalSubmissionRaw\": 6850279, \"acRate\": \"57.4%\"}",
        "similarQuestions": "[{\"title\": \"Trapping Rain Water\", \"titleSlug\": \"trapping-rain-water\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Tastiness of Candy Basket\", \"titleSlug\": \"maximum-tastiness-of-candy-basket\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber IV\", \"titleSlug\": \"house-robber-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If you simulate the problem, it will be O(n^2) which is not efficient.",
          "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
          "How can you calculate the amount of water at each step?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/container-with-most-water/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "12",
        "questionFrontendId": "12",
        "title": "Integer to Roman",
        "content": "<p>Seven different symbols represent Roman numerals with the following values:</p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Symbol</th>\n\t\t\t<th>Value</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>I</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>V</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>X</td>\n\t\t\t<td>10</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>L</td>\n\t\t\t<td>50</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>C</td>\n\t\t\t<td>100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>D</td>\n\t\t\t<td>500</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>M</td>\n\t\t\t<td>1000</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Roman numerals are formed by appending&nbsp;the conversions of&nbsp;decimal place values&nbsp;from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:</p>\n\n<ul>\n\t<li>If the value does not start with 4 or&nbsp;9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.</li>\n\t<li>If the value starts with 4 or 9 use the&nbsp;<strong>subtractive form</strong>&nbsp;representing&nbsp;one symbol subtracted from the following symbol, for example,&nbsp;4 is 1 (<code>I</code>) less than 5 (<code>V</code>): <code>IV</code>&nbsp;and 9 is 1 (<code>I</code>) less than 10 (<code>X</code>): <code>IX</code>.&nbsp;Only the following subtractive forms are used: 4 (<code>IV</code>), 9 (<code>IX</code>),&nbsp;40 (<code>XL</code>), 90 (<code>XC</code>), 400 (<code>CD</code>) and 900 (<code>CM</code>).</li>\n\t<li>Only powers of 10 (<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5&nbsp;(<code>V</code>), 50 (<code>L</code>), or 500 (<code>D</code>) multiple times. If you need to append a symbol&nbsp;4 times&nbsp;use the <strong>subtractive form</strong>.</li>\n</ul>\n\n<p>Given an integer, convert it to a Roman numeral.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 3749</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;MMMDCCXLIX&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 58</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;LVIII&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n50 = L\n 8 = VIII\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 1994</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;MCMXCIV&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n</pre>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>\n",
        "likes": 7726,
        "dislikes": 5639,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1678776, \"totalSubmissionRaw\": 2464576, \"acRate\": \"68.1%\"}",
        "similarQuestions": "[{\"title\": \"Roman to Integer\", \"titleSlug\": \"roman-to-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Integer to English Words\", \"titleSlug\": \"integer-to-english-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/integer-to-roman/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "13",
        "questionFrontendId": "13",
        "title": "Roman to Integer",
        "content": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n\n<pre>\n<strong>Symbol</strong>       <strong>Value</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>For example,&nbsp;<code>2</code> is written as <code>II</code>&nbsp;in Roman numeral, just two ones added together. <code>12</code> is written as&nbsp;<code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p>\n\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n\n<ul>\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n\n<p>Given a roman numeral, convert it to an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;III&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;LVIII&quot;\n<strong>Output:</strong> 58\n<strong>Explanation:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;MCMXCIV&quot;\n<strong>Output:</strong> 1994\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s</code> contains only&nbsp;the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li>\n\t<li>It is <strong>guaranteed</strong>&nbsp;that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li>\n</ul>\n",
        "likes": 15682,
        "dislikes": 1072,
        "stats": "{\"totalAccepted\": \"4.7M\", \"totalSubmission\": \"7.3M\", \"totalAcceptedRaw\": 4681937, \"totalSubmissionRaw\": 7266343, \"acRate\": \"64.4%\"}",
        "similarQuestions": "[{\"title\": \"Integer to Roman\", \"titleSlug\": \"integer-to-roman\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Problem is simpler to solve by working the string from back to front and using a map."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/roman-to-integer/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "14",
        "questionFrontendId": "14",
        "title": "Longest Common Prefix",
        "content": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>Output:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no common prefix among the input strings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> consists of only lowercase English letters if it is non-empty.</li>\n</ul>\n",
        "likes": 18987,
        "dislikes": 4707,
        "stats": "{\"totalAccepted\": \"4.4M\", \"totalSubmission\": \"9.7M\", \"totalAcceptedRaw\": 4379743, \"totalSubmissionRaw\": 9707639, \"acRate\": \"45.1%\"}",
        "similarQuestions": "[{\"title\": \"Smallest Missing Integer Greater Than Sequential Prefix Sum\", \"titleSlug\": \"smallest-missing-integer-greater-than-sequential-prefix-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Length of the Longest Common Prefix\", \"titleSlug\": \"find-the-length-of-the-longest-common-prefix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Common Suffix Queries\", \"titleSlug\": \"longest-common-suffix-queries\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Common Prefix After at Most One Removal\", \"titleSlug\": \"longest-common-prefix-after-at-most-one-removal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Trie"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n\n### Approach 1: Horizontal scanning\n\n#### Intuition\n\nFor a start we will describe a simple way of finding the longest prefix shared by a set of strings $$LCP(S_1  \\ldots  S_n)$$.\nWe will use the observation that :\n\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$$\n\n#### Algorithm\n\n To employ this idea, the algorithm iterates through the strings $$[S_1  \\ldots  S_n]$$, finding at each iteration $$i$$ the longest common prefix of strings $$LCP(S_1  \\ldots  S_i)$$ When $$LCP(S_1  \\ldots  S_i)$$ is an empty string, the algorithm ends. Otherwise after $$n$$ iterations, the algorithm returns $$LCP(S_1  \\ldots  S_n)$$.\n\n ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_basic.png){:width=\"539px\"}\n \n\n *Figure 1. Finding the longest common prefix (Horizontal scanning)*\n \n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/Eyfryo9Z/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"Eyfryo9Z\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\n\n    In the worst case all $$n$$ strings are the same. The algorithm compares the string $$S1$$ with the other strings $$[S_2 \\ldots S_n]$$ There are $$S$$ character comparisons, where $$S$$ is the sum of all characters in the input array.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 2: Vertical scanning\n\n#### Algorithm\n\nImagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/WSSYVp4m/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"WSSYVp4m\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\nIn the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs  $$S = m \\cdot n$$ character comparisons.\nEven though the worst case is still the same as [Approach 1](#approach-1-horizontal-scanning), in the best case there are at most $$n \\cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 3: Divide and conquer\n\n#### Intuition\n\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$$\n, where $$LCP(S_1 \\ldots S_n)$$ is the longest common prefix in set of strings $$[S_1 \\ldots S_n]$$ , $$1 < k < n$$\n\n#### Algorithm\n\nTo apply the observation above, we use divide and conquer technique, where we split the $$LCP(S_i \\ldots S_j)$$ problem into two subproblems $$LCP(S_i \\ldots S_{mid})$$   and $$LCP(S_{mid+1} \\ldots S_j)$$, where `mid` is $$\\frac{i + j}{2}$$. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem $$LCP(S_i \\ldots S_j)$$. To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the  $$LCP(S_i \\ldots S_j)$$.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width=\"539px\"}\n\n\n*Figure 2. Finding the longest common prefix of strings using divide and conquer technique*\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/DR56kG9E/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DR56kG9E\"></iframe>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S = m \\cdot n$$\n Time complexity is $$2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)$$. Therefore time complexity is $$O(S)$$.\n  In the best case this algorithm performs  $$O(minLen \\cdot n)$$ comparisons, where  $$minLen$$ is the shortest string of the array\n\n* Space complexity : $$O(m \\cdot \\log n)$$\n\n    There is a memory overhead since we store recursive calls in the execution stack. There are $$\\log n$$ recursive calls, each store need $$m$$ space to store the result,  so space complexity is $$O(m \\cdot \\log n)$$\n\n\n---\n\n### Approach 4: Binary search\n\n#### Intuition\n\nThe idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \\ldots minLen)$$, where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:\n* `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the  search space.\n* `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width=\"539px\"}\n\n\n*Figure 3. Finding the longest common prefix of strings using binary search technique*\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/M2tJuDXZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"M2tJuDXZ\"></iframe>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S \\cdot \\log m)$$, where $$S$$ is the sum of all characters in all strings.\n\n    The algorithm makes $$\\log m$$ iterations, for each of them there are $$S = m \\cdot n$$ comparisons, which gives in total $$O(S \\cdot \\log m)$$ time complexity.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Further Thoughts / Follow up\n\nLet's take a look at a slightly different problem:\n\n> Given a set of keys S = $$[S_1,S_2 \\ldots S_n]$$, find the longest common prefix among a string `q` and S. This LCP query will be called frequently.\n\nWe could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n* it is prefix of query string `q`\n* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.\n\n#### Algorithm\n\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$[S_1 \\ldots   S_n]$$ strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n![Finding the longest common prefix using Trie](../Figures/14/14_lcp_trie_fix.png)\n\n*Figure 4. Finding the longest common prefix of strings using Trie*\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/bcDyZ5WU/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bcDyZ5WU\"></iframe>\n\n#### Complexity Analysis\n\nIn the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.\n\n* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.\n\n    Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.\n\n* Space complexity : $$O(S)$$. We only used additional  $$S$$ extra space for the Trie."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-common-prefix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "15",
        "questionFrontendId": "15",
        "title": "3Sum",
        "content": "<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n<strong>Explanation:</strong> \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The only possible triplet does not sum up to 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> [[0,0,0]]\n<strong>Explanation:</strong> The only possible triplet sums up to 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 32629,
        "dislikes": 3074,
        "stats": "{\"totalAccepted\": \"4.6M\", \"totalSubmission\": \"12.4M\", \"totalAcceptedRaw\": 4564491, \"totalSubmissionRaw\": 12444360, \"acRate\": \"36.7%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"3Sum Closest\", \"titleSlug\": \"3sum-closest\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"4Sum\", \"titleSlug\": \"4sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"3Sum Smaller\", \"titleSlug\": \"3sum-smaller\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Arithmetic Triplets\", \"titleSlug\": \"number-of-arithmetic-triplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Sum of Mountain Triplets I\", \"titleSlug\": \"minimum-sum-of-mountain-triplets-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Sum of Mountain Triplets II\", \"titleSlug\": \"minimum-sum-of-mountain-triplets-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
          "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
          "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/3sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "16",
        "questionFrontendId": "16",
        "title": "3Sum Closest",
        "content": "<p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p>\n\n<p>Return <em>the sum of the three integers</em>.</p>\n\n<p>You may assume that each input would have exactly one solution.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,2,1,-4], target = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0], target = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 10916,
        "dislikes": 588,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 1456016, \"totalSubmissionRaw\": 3117599, \"acRate\": \"46.7%\"}",
        "similarQuestions": "[{\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"3Sum Smaller\", \"titleSlug\": \"3sum-smaller\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/3sum-closest/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "17",
        "questionFrontendId": "17",
        "title": "Letter Combinations of a Phone Number",
        "content": "<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>\n\n<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 300px; height: 243px;\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;23&quot;\n<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;&quot;\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;2&quot;\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>\n</ul>\n",
        "likes": 19555,
        "dislikes": 1060,
        "stats": "{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 2482063, \"totalSubmissionRaw\": 3915600, \"acRate\": \"63.4%\"}",
        "similarQuestions": "[{\"title\": \"Generate Parentheses\", \"titleSlug\": \"generate-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Watch\", \"titleSlug\": \"binary-watch\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Number of Texts\", \"titleSlug\": \"count-number-of-texts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Pushes to Type Word I\", \"titleSlug\": \"minimum-number-of-pushes-to-type-word-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Pushes to Type Word II\", \"titleSlug\": \"minimum-number-of-pushes-to-type-word-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "18",
        "questionFrontendId": "18",
        "title": "4Sum",
        "content": "<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 11947,
        "dislikes": 1455,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 1236917, \"totalSubmissionRaw\": 3270245, \"acRate\": \"37.8%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"4Sum II\", \"titleSlug\": \"4sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Special Quadruplets\", \"titleSlug\": \"count-special-quadruplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\nThis problem is a follow-up of [3Sum](https://leetcode.com/articles/3sum/), so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.\n\nAs you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value `v`, it finds all pairs whose sum is equal to `target - v` using one of these approaches:\n\n1. [Two Sum](https://leetcode.com/articles/two-sum/) uses a hash set to check for a matching value.\n2. [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/) uses the two pointers pattern in a sorted array.\n\nFollowing a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.\n\n---\n\n### Approach 1: Two Pointers\n\n**Intuition**\n\nThe two pointers pattern requires the array to be sorted, so we do that first.  Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.\n\nFor 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have `k - 2` nested loops to enumerate all combinations of `k - 2` values.\n\n!?!../Documents/18_4Sum.json:1200,440!?!\n\n**Algorithm**\n\nWe can implement `k - 2` loops using a recursion. We will pass the starting point and `k` as the parameters. When `k == 2`, we will call `twoSum`, terminating the recursion.\n\n1. For the main function:\n    - Sort the input array `nums`.\n    - Call `kSum` with `start = 0`, `k = 4`, and `target`, and return the result.\n\n2. For `kSum` function:\n    - At the start of the `kSum` function, we will check three conditions:\n      1. Have we run out of numbers to choose from?\n      2. Is the smallest number remaining greater than `target / k`? <br>If so, then any `k` numbers we choose will be too large.\n      3. Is the largest number remaining smaller than `target / k`? <br>If so, then any `k` numbers we choose will be too small.\n      - If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to `target`.\n    - If `k` equals `2`, call `twoSum` and return the result.\n    - Iterate `i` through the array from `start`:\n        - If the current value is the same as the one before, skip it.\n        - Recursively call `kSum` with `start = i + 1`, `k = k - 1`, and `target - nums[i]`.\n        - For each returned `subset` of values:\n            - Include the current value `nums[i]` into `subset`.\n            - Add `subset` to the result `res`.\n    - Return the result `res`.\n\n3. For `twoSum` function:\n    - Set the low pointer `lo` to `start`, and high pointer `hi` to the last index.\n    - While low pointer is smaller than high:\n        - If the sum of `nums[lo]` and `nums[hi]` is less than `target`, increment `lo`.\n            - Also increment `lo` if the value is the same as for `lo - 1`.\n        - If the sum is greater than `target`, decrement `hi`.\n            - Also decrement `hi` if the value is the same as for `hi + 1`.\n        - Otherwise, we found a pair:\n            - Add it to the result `res`.\n            - Decrement `hi` and increment `lo`.\n    - Return the result `res`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/mQdTCUXD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mQdTCUXD\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$. We need $$O(k)$$ space for the recursion. $$k$$ can be the same as $$n$$ in the worst case for the generalized algorithm.\n\n    Note that, for the purpose of complexity analysis, we ignore the memory required for the output.\n\n---\n\n### Approach 2: Hash Set\n    \n**Intuition**\n\nSince elements must sum up to the exact target value, we can also use the [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table) approach.\n\nIn [3Sum: Hash Set](https://leetcode.com/articles/3sum/#approach-2-hash-set), we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.\n\nSo, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the `twoSum` implementation.\n\n**Algorithm**\n\n`twoSum` implementation here is almost the same as in [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result `res`.\n    \n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/oAq3g56d/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"oAq3g56d\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops iterating over $$n$$ elements, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$ for the hash set. The space needed for the recursion will not exceed $$O(n)$$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/4sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "19",
        "questionFrontendId": "19",
        "title": "Remove Nth Node From End of List",
        "content": "<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], n = 2\n<strong>Output:</strong> [1,2,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1], n = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2], n = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>sz</code>.</li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do this in one pass?</p>\n",
        "likes": 19824,
        "dislikes": 848,
        "stats": "{\"totalAccepted\": \"3.4M\", \"totalSubmission\": \"7M\", \"totalAcceptedRaw\": 3371567, \"totalSubmissionRaw\": 6962457, \"acRate\": \"48.4%\"}",
        "similarQuestions": "[{\"title\": \"Swapping Nodes in a Linked List\", \"titleSlug\": \"swapping-nodes-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete N Nodes After M Nodes of a Linked List\", \"titleSlug\": \"delete-n-nodes-after-m-nodes-of-a-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Delete the Middle Node of a Linked List\", \"titleSlug\": \"delete-the-middle-node-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Maintain two pointers and update one with a delay of n steps."
        ],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "20",
        "questionFrontendId": "20",
        "title": "Valid Parentheses",
        "content": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n\t<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;()&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;()[]{}&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;(]&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;([])&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n",
        "likes": 25523,
        "dislikes": 1869,
        "stats": "{\"totalAccepted\": \"5.9M\", \"totalSubmission\": \"14M\", \"totalAcceptedRaw\": 5889955, \"totalSubmissionRaw\": 14012662, \"acRate\": \"42.0%\"}",
        "similarQuestions": "[{\"title\": \"Generate Parentheses\", \"titleSlug\": \"generate-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Valid Parentheses\", \"titleSlug\": \"longest-valid-parentheses\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Remove Invalid Parentheses\", \"titleSlug\": \"remove-invalid-parentheses\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check If Word Is Valid After Substitutions\", \"titleSlug\": \"check-if-word-is-valid-after-substitutions\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check if a Parentheses String Can Be Valid\", \"titleSlug\": \"check-if-a-parentheses-string-can-be-valid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Move Pieces to Obtain a String\", \"titleSlug\": \"move-pieces-to-obtain-a-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use a stack of characters.",
          "When you encounter an opening bracket, push it to the top of the stack.",
          "When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."
        ],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/valid-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "21",
        "questionFrontendId": "21",
        "title": "Merge Two Sorted Lists",
        "content": "<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>\n\n<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>\n\n<p>Return <em>the head of the merged linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]\n<strong>Output:</strong> [1,1,2,3,4,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "likes": 23138,
        "dislikes": 2273,
        "stats": "{\"totalAccepted\": \"5.1M\", \"totalSubmission\": \"7.7M\", \"totalAcceptedRaw\": 5116383, \"totalSubmissionRaw\": 7693489, \"acRate\": \"66.5%\"}",
        "similarQuestions": "[{\"title\": \"Merge k Sorted Lists\", \"titleSlug\": \"merge-k-sorted-lists\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Merge Sorted Array\", \"titleSlug\": \"merge-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sort List\", \"titleSlug\": \"sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Word Distance II\", \"titleSlug\": \"shortest-word-distance-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Two Polynomials Represented as Linked Lists\", \"titleSlug\": \"add-two-polynomials-represented-as-linked-lists\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Common Subsequence Between Sorted Arrays\", \"titleSlug\": \"longest-common-subsequence-between-sorted-arrays\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Merge Two 2D Arrays by Summing Values\", \"titleSlug\": \"merge-two-2d-arrays-by-summing-values\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-two-sorted-lists/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "22",
        "questionFrontendId": "22",
        "title": "Generate Parentheses",
        "content": "<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [\"()\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "likes": 22015,
        "dislikes": 1026,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"3M\", \"totalAcceptedRaw\": 2288856, \"totalSubmissionRaw\": 2981665, \"acRate\": \"76.8%\"}",
        "similarQuestions": "[{\"title\": \"Letter Combinations of a Phone Number\", \"titleSlug\": \"letter-combinations-of-a-phone-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Parentheses\", \"titleSlug\": \"valid-parentheses\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Check if a Parentheses String Can Be Valid\", \"titleSlug\": \"check-if-a-parentheses-string-can-be-valid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/generate-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "23",
        "questionFrontendId": "23",
        "title": "Merge k Sorted Lists",
        "content": "<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>Output:</strong> [1,1,2,3,4,4,5,6]\n<strong>Explanation:</strong> The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[]]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>\n</ul>\n",
        "likes": 20231,
        "dislikes": 747,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 2430697, \"totalSubmissionRaw\": 4326606, \"acRate\": \"56.2%\"}",
        "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Subarrays With Maximum Bitwise OR\", \"titleSlug\": \"smallest-subarrays-with-maximum-bitwise-or\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Merge Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-k-sorted-lists/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "24",
        "questionFrontendId": "24",
        "title": "Swap Nodes in Pairs",
        "content": "<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = [1,2,3,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[2,1,4,3]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = [1,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[2,1,3]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the&nbsp;list&nbsp;is in the range <code>[0, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 12414,
        "dislikes": 475,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 1597199, \"totalSubmissionRaw\": 2392101, \"acRate\": \"66.8%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Nodes in k-Group\", \"titleSlug\": \"reverse-nodes-in-k-group\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Swapping Nodes in a Linked List\", \"titleSlug\": \"swapping-nodes-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/swap-nodes-in-pairs/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "25",
        "questionFrontendId": "25",
        "title": "Reverse Nodes in k-Group",
        "content": "<p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p>\n\n<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p>\n\n<p>You may not alter the values in the list&#39;s nodes, only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [2,1,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 3\n<strong>Output:</strong> [3,2,1,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve the problem in <code>O(1)</code> extra memory space?</p>\n",
        "likes": 14489,
        "dislikes": 747,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1188271, \"totalSubmissionRaw\": 1903405, \"acRate\": \"62.4%\"}",
        "similarQuestions": "[{\"title\": \"Swap Nodes in Pairs\", \"titleSlug\": \"swap-nodes-in-pairs\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Swapping Nodes in a Linked List\", \"titleSlug\": \"swapping-nodes-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reverse Nodes in Even Length Groups\", \"titleSlug\": \"reverse-nodes-in-even-length-groups\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "26",
        "questionFrontendId": "26",
        "title": "Remove Duplicates from Sorted Array",
        "content": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return <em>the number of unique elements in </em><code>nums</code>.</p>\n\n<p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p>\n\n<ul>\n\t<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>\n\t<li>Return <code>k</code>.</li>\n</ul>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong> 2, nums = [1,2,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]\n<strong>Output:</strong> 5, nums = [0,1,2,3,4,_,_,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "likes": 16481,
        "dislikes": 19682,
        "stats": "{\"totalAccepted\": \"6M\", \"totalSubmission\": \"10M\", \"totalAcceptedRaw\": 5998657, \"totalSubmissionRaw\": 10026943, \"acRate\": \"59.8%\"}",
        "similarQuestions": "[{\"title\": \"Remove Element\", \"titleSlug\": \"remove-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Duplicates from Sorted Array II\", \"titleSlug\": \"remove-duplicates-from-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Apply Operations to an Array\", \"titleSlug\": \"apply-operations-to-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Distances\", \"titleSlug\": \"sum-of-distances\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/>",
          "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
          "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "27",
        "questionFrontendId": "27",
        "title": "Remove Element",
        "content": "<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>. The order of the elements may be changed. Then return <em>the number of elements in </em><code>nums</code><em> which are not equal to </em><code>val</code>.</p>\n\n<p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p>\n\n<ul>\n\t<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>\n\t<li>Return <code>k</code>.</li>\n</ul>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,2,3], val = 3\n<strong>Output:</strong> 2, nums = [2,2,_,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n",
        "likes": 3717,
        "dislikes": 4682,
        "stats": "{\"totalAccepted\": \"4.1M\", \"totalSubmission\": \"6.8M\", \"totalAcceptedRaw\": 4073828, \"totalSubmissionRaw\": 6825057, \"acRate\": \"59.7%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted Array\", \"titleSlug\": \"remove-duplicates-from-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Linked List Elements\", \"titleSlug\": \"remove-linked-list-elements\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Move Zeroes\", \"titleSlug\": \"move-zeroes\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to <b>remove</b> that element per-say, right?",
          "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
          "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-element/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "28",
        "questionFrontendId": "28",
        "title": "Find the Index of the First Occurrence in a String",
        "content": "<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>\n</ul>\n",
        "likes": 6609,
        "dislikes": 487,
        "stats": "{\"totalAccepted\": \"3.2M\", \"totalSubmission\": \"7.2M\", \"totalAcceptedRaw\": 3213632, \"totalSubmissionRaw\": 7195260, \"acRate\": \"44.7%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Repeated Substring Pattern\", \"titleSlug\": \"repeated-substring-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          },
          {
            "name": "String Matching"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "29",
        "questionFrontendId": "29",
        "title": "Divide Two Integers",
        "content": "<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p>\n\n<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p>\n\n<p>Return <em>the <strong>quotient</strong> after dividing </em><code>dividend</code><em> by </em><code>divisor</code>.</p>\n\n<p><strong>Note: </strong>Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[&minus;2<sup>31</sup>, 2<sup>31</sup> &minus; 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>2<sup>31</sup> - 1</code>, then return <code>2<sup>31</sup> - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-2<sup>31</sup></code>, then return <code>-2<sup>31</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 10, divisor = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 10/3 = 3.33333.. which is truncated to 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 7, divisor = -3\n<strong>Output:</strong> -2\n<strong>Explanation:</strong> 7/-3 = -2.33333.. which is truncated to -2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>divisor != 0</code></li>\n</ul>\n",
        "likes": 5544,
        "dislikes": 15061,
        "stats": "{\"totalAccepted\": \"913.5K\", \"totalSubmission\": \"5M\", \"totalAcceptedRaw\": 913507, \"totalSubmissionRaw\": 5007855, \"acRate\": \"18.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/divide-two-integers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "30",
        "questionFrontendId": "30",
        "title": "Substring with Concatenation of All Words",
        "content": "<p>You are given a string <code>s</code> and an array of strings <code>words</code>. All the strings of <code>words</code> are of <strong>the same length</strong>.</p>\n\n<p>A <strong>concatenated string</strong> is a string that exactly contains all the strings of any permutation of <code>words</code> concatenated.</p>\n\n<ul>\n\t<li>For example, if <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>, then <code>&quot;abcdef&quot;</code>, <code>&quot;abefcd&quot;</code>, <code>&quot;cdabef&quot;</code>, <code>&quot;cdefab&quot;</code>, <code>&quot;efabcd&quot;</code>, and <code>&quot;efcdab&quot;</code> are all concatenated strings. <code>&quot;acdbef&quot;</code> is not a concatenated string because it is not the concatenation of any permutation of <code>words</code>.</li>\n</ul>\n\n<p>Return an array of <em>the starting indices</em> of all the concatenated substrings in <code>s</code>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[0,9]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substring starting at 0 is <code>&quot;barfoo&quot;</code>. It is the concatenation of <code>[&quot;bar&quot;,&quot;foo&quot;]</code> which is a permutation of <code>words</code>.<br />\nThe substring starting at 9 is <code>&quot;foobar&quot;</code>. It is the concatenation of <code>[&quot;foo&quot;,&quot;bar&quot;]</code> which is a permutation of <code>words</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no concatenated substring.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[6,9,12]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substring starting at 6 is <code>&quot;foobarthe&quot;</code>. It is the concatenation of <code>[&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;]</code>.<br />\nThe substring starting at 9 is <code>&quot;barthefoo&quot;</code>. It is the concatenation of <code>[&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;]</code>.<br />\nThe substring starting at 12 is <code>&quot;thefoobar&quot;</code>. It is the concatenation of <code>[&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;]</code>.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>s</code> and <code>words[i]</code> consist of lowercase English letters.</li>\n</ul>\n",
        "likes": 2180,
        "dislikes": 348,
        "stats": "{\"totalAccepted\": \"563.5K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 563539, \"totalSubmissionRaw\": 1714297, \"acRate\": \"32.9%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "31",
        "questionFrontendId": "31",
        "title": "Next Permutation",
        "content": "<p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li>\n</ul>\n\n<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>\n\n<ul>\n\t<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>\n\t<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>\n\t<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>\n</ul>\n\n<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>\n\n<p>The replacement must be <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a></strong> and use only constant extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,5]\n<strong>Output:</strong> [1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "likes": 19635,
        "dislikes": 4897,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"4.1M\", \"totalAcceptedRaw\": 1755455, \"totalSubmissionRaw\": 4120259, \"acRate\": \"42.6%\"}",
        "similarQuestions": "[{\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations II\", \"titleSlug\": \"permutations-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutation Sequence\", \"titleSlug\": \"permutation-sequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation II\", \"titleSlug\": \"palindrome-permutation-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Adjacent Swaps to Reach the Kth Smallest Number\", \"titleSlug\": \"minimum-adjacent-swaps-to-reach-the-kth-smallest-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Brute Force\n\n**Algorithm**\n\nIn this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is\njust larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation\n which will take really long time and the implementation is complex.\n Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n!)$$. Total possible permutations is $$n!$$.\n* Space complexity : $$O(n)$$. Since an array will be used to store the permutations.\n<br />\n<br />\n\n---\n\n### Approach 2: Single Pass Approach\n\n**Algorithm**\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\n For example, no next permutation is possible for the following array:\n ```\n [9, 5, 4, 3, 1]\n ```\n\nWe need to find the first pair of two successive numbers $$a[i]$$ and $$a[i-1]$$, from the right, which satisfy\n $$a[i] > a[i-1]$$. Now, no rearrangements to the right of $$a[i-1]$$ can create a larger permutation since that subarray consists of numbers in descending order.\n Thus, we need to rearrange the numbers to the right of $$a[i-1]$$ including itself.\n\nNow, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number $$a[i-1]$$ with the number which is just larger than itself among the numbers lying to its right section, say $$a[j]$$.\n\n![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png)\n\nWe swap the numbers $$a[i-1]$$ and $$a[j]$$. We now have the correct number at index $$i-1$$. But still the current permutation isn't the permutation\n    that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of $$a[i-1]$$. Therefore, we need to place those\n     numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index\n      until we found the pair $$a[i]$$ and $$a[i-1]$$ where,  $$a[i] > a[i-1]$$. Thus, all numbers to the right of $$a[i-1]$$ were already sorted in descending order.\n      Furthermore, swapping $$a[i-1]$$ and $$a[j]$$ didn't change that order.\n      Therefore, we simply need to reverse the numbers following $$a[i-1]$$ to get the next smallest lexicographic permutation.\n\nThe following animation will make things clearer:\n\n![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)\n\n<iframe src=\"https://leetcode.com/playground/Dm6PeACq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Dm6PeACq\"></iframe>\n\n**Complexity Analysis**\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n)$\n\n   The first `while` loop runs at most $n$ iterations, decrementing the variable `i` as it searches for the first decreasing element from the right. In the worst case, it checks all elements, so it takes $O(n)$ time.\n    \n   The second `while` loop also runs at most $n$ iterations, decrementing the variable `j` as it searches for the smallest element larger than `nums[i]`. Similarly, it can take $O(n)$ time.\n    \n   The `reverse` function is called on a portion of the array, from index `i + 1` to the end. In the worst case, this can cover the entire array, leading to a time complexity of $O(n)$.\n    \n   The `swap` function runs in constant time, $O(1)$, since it only exchanges two elements.\n    \n    Therefore, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(1)$\n\n   The function operates in-place on the `nums` array, meaning no extra space is used for storing additional data.\n    \n   Only a few constant space variables (`i`, `j`, and `temp`) are used.\n    \n   The built-in `swap` and `reverse` functions do not require additional space beyond what is already present in the input array.\n\n    Hence, the space complexity is $O(1)$."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/next-permutation/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "32",
        "questionFrontendId": "32",
        "title": "Longest Valid Parentheses",
        "content": "<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, return <em>the length of the longest valid (well-formed) parentheses </em><span data-keyword=\"substring-nonempty\"><em>substring</em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(()&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)()())&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()()&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> is <code>&#39;(&#39;</code>, or <code>&#39;)&#39;</code>.</li>\n</ul>\n",
        "likes": 12761,
        "dislikes": 429,
        "stats": "{\"totalAccepted\": \"882.6K\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 882574, \"totalSubmissionRaw\": 2457369, \"acRate\": \"35.9%\"}",
        "similarQuestions": "[{\"title\": \"Valid Parentheses\", \"titleSlug\": \"valid-parentheses\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/longest-valid-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "33",
        "questionFrontendId": "33",
        "title": "Search in Rotated Sorted Array",
        "content": "<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 27760,
        "dislikes": 1685,
        "stats": "{\"totalAccepted\": \"3.5M\", \"totalSubmission\": \"8.2M\", \"totalAcceptedRaw\": 3474587, \"totalSubmissionRaw\": 8171777, \"acRate\": \"42.5%\"}",
        "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array II\", \"titleSlug\": \"search-in-rotated-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Minimum in Rotated Sorted Array\", \"titleSlug\": \"find-minimum-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Pour Water Between Buckets to Make Water Levels Equal\", \"titleSlug\": \"pour-water-between-buckets-to-make-water-levels-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "34",
        "questionFrontendId": "34",
        "title": "Find First and Last Position of Element in Sorted Array",
        "content": "<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>\n\n<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8\n<strong>Output:</strong> [3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6\n<strong>Output:</strong> [-1,-1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> [-1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> is a non-decreasing array.</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 21643,
        "dislikes": 568,
        "stats": "{\"totalAccepted\": \"2.6M\", \"totalSubmission\": \"5.6M\", \"totalAcceptedRaw\": 2584392, \"totalSubmissionRaw\": 5569652, \"acRate\": \"46.4%\"}",
        "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Plates Between Candles\", \"titleSlug\": \"plates-between-candles\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Target Indices After Sorting Array\", \"titleSlug\": \"find-target-indices-after-sorting-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "35",
        "questionFrontendId": "35",
        "title": "Search Insert Position",
        "content": "<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 5\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 17253,
        "dislikes": 807,
        "stats": "{\"totalAccepted\": \"3.7M\", \"totalSubmission\": \"7.6M\", \"totalAcceptedRaw\": 3699791, \"totalSubmissionRaw\": 7614210, \"acRate\": \"48.6%\"}",
        "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Exceed Threshold Value I\", \"titleSlug\": \"minimum-operations-to-exceed-threshold-value-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/search-insert-position/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "36",
        "questionFrontendId": "36",
        "title": "Valid Sudoku",
        "content": "<p>Determine if a&nbsp;<code>9 x 9</code> Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>\n\n<ol>\n\t<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>\n\t<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n\t<li>Each of the nine&nbsp;<code>3 x 3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n</ol>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n\t<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = \n[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = \n[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li>\n</ul>\n",
        "likes": 11405,
        "dislikes": 1193,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 1933518, \"totalSubmissionRaw\": 3123281, \"acRate\": \"61.9%\"}",
        "similarQuestions": "[{\"title\": \"Sudoku Solver\", \"titleSlug\": \"sudoku-solver\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if Every Row and Column Contains All Numbers\", \"titleSlug\": \"check-if-every-row-and-column-contains-all-numbers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/valid-sudoku/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "37",
        "questionFrontendId": "37",
        "title": "Sudoku Solver",
        "content": "<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\n\n<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>\n\n<ol>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n</ol>\n\n<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> [[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Explanation:</strong>&nbsp;The input board is shown above and the only valid solution is shown below:\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\" style=\"height:250px; width:250px\" />\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the input board has only one solution.</li>\n</ul>\n",
        "likes": 10087,
        "dislikes": 290,
        "stats": "{\"totalAccepted\": \"744.8K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 744816, \"totalSubmissionRaw\": 1169104, \"acRate\": \"63.7%\"}",
        "similarQuestions": "[{\"title\": \"Valid Sudoku\", \"titleSlug\": \"valid-sudoku\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Unique Paths III\", \"titleSlug\": \"unique-paths-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sudoku-solver/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "38",
        "questionFrontendId": "38",
        "title": "Count and Say",
        "content": "<p>The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p>\n\n<ul>\n\t<li><code>countAndSay(1) = &quot;1&quot;</code></li>\n\t<li><code>countAndSay(n)</code> is the run-length encoding of <code>countAndSay(n - 1)</code>.</li>\n</ul>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Run-length_encoding\" target=\"_blank\">Run-length encoding</a> (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string <code>&quot;3322251&quot;</code> we replace <code>&quot;33&quot;</code> with <code>&quot;23&quot;</code>, replace <code>&quot;222&quot;</code> with <code>&quot;32&quot;</code>, replace <code>&quot;5&quot;</code> with <code>&quot;15&quot;</code> and replace <code>&quot;1&quot;</code> with <code>&quot;11&quot;</code>. Thus the compressed string becomes <code>&quot;23321511&quot;</code>.</p>\n\n<p>Given a positive integer <code>n</code>, return <em>the </em><code>n<sup>th</sup></code><em> element of the <strong>count-and-say</strong> sequence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;1211&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(2) = RLE of &quot;1&quot; = &quot;11&quot;\ncountAndSay(3) = RLE of &quot;11&quot; = &quot;21&quot;\ncountAndSay(4) = RLE of &quot;21&quot; = &quot;1211&quot;\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;1&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>This is the base case.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it iteratively?",
        "likes": 4342,
        "dislikes": 8608,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1097266, \"totalSubmissionRaw\": 1885157, \"acRate\": \"58.2%\"}",
        "similarQuestions": "[{\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"String Compression\", \"titleSlug\": \"string-compression\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with \"223314444411\", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]].",
          "Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\".",
          "Now, with the two helper functions, you can start with \"1\" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain."
        ],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-and-say/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "39",
        "questionFrontendId": "39",
        "title": "Combination Sum",
        "content": "<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>\n\n<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the <span data-keyword=\"frequency-array\">frequency</span> of at least one of the chosen numbers is different.</p>\n\n<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,6,7], target = 7\n<strong>Output:</strong> [[2,2,3],[7]]\n<strong>Explanation:</strong>\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,5], target = 8\n<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2], target = 1\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n\t<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n",
        "likes": 19695,
        "dislikes": 463,
        "stats": "{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 2461023, \"totalSubmissionRaw\": 3316526, \"acRate\": \"74.2%\"}",
        "similarQuestions": "[{\"title\": \"Letter Combinations of a Phone Number\", \"titleSlug\": \"letter-combinations-of-a-phone-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum II\", \"titleSlug\": \"combination-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combinations\", \"titleSlug\": \"combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum III\", \"titleSlug\": \"combination-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Factor Combinations\", \"titleSlug\": \"factor-combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum IV\", \"titleSlug\": \"combination-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"The Number of Ways to Make the Sum\", \"titleSlug\": \"the-number-of-ways-to-make-the-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/combination-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "40",
        "questionFrontendId": "40",
        "title": "Combination Sum II",
        "content": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>\n\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\n\n<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8\n<strong>Output:</strong> \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5\n<strong>Output:</strong> \n[\n[1,2,2],\n[5]\n]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n",
        "likes": 11477,
        "dislikes": 339,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 1341742, \"totalSubmissionRaw\": 2339275, \"acRate\": \"57.4%\"}",
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]  \n\n## Solution\n\n---\n\n### Overview\n\nThis is one of the problems in the series of combination sums. All these problems can be solved with the same backtracking algorithm.\n\nWe recommend trying these similar problems before tackling this one: [Combination Sum](https://leetcode.com/problems/combination-sum/description/) and [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/), which are arguably easier and one can tweak the solution a bit to solve this problem.\n\nWe also listed some follow-up problems at the end of the article if you are interested in exploring the bactracking algorithm further.\n\n---\n\n### Approach: Backtracking\n\n#### Intuition\n\nIn this problem, we need to generate unique combinations with the given sum value. In the worst case, we might need to generate the sum of all combinations in the array. Backtracking can be effectively used to generate all the possible combinations recursively. Backtracking incrementally builds candidates to the solutions and abandons a candidate (backtracks) as soon as it determines that this candidate can't lead to a final solution. For example, in the given problem, we can discard the candidate solution when it exceeds the sum value, provided the array contains non-negative values. Refer to this [backtracking explore card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) to read more about backtracking.\n\nUsing backtracking, we could incrementally build the combinations. When we find the current combination is not valid, we backtrack and try another option. For the first option, we add the current array element to the current combination array and move this combination to the next index recursively. Similarly, for the second option, we remove the element from the current combination array and move this combination to the next index. Therefore, for every index, we explored two possibilities of including and excluding that value and calculated the combination sum of the maintained combination array. If the desired sum is reached, we can append the list to the answer list. To demonstrate the idea, we showcase how it works with a concrete example in the following tree:\n\n![fig](../Figures/40/40.png)\n\nAre there any optimizations to reduce the backtracking calls? Since we need to return unique combinations, we can group equal values of the array together. The simplest way to group all elements together is by sorting them. Now, suppose the frequency of an element is `freq`, and you need to make backtracking calls for all its possible frequencies between `0` and `freq`, then we can simply pick them from the beginning of its group in the sorted array.\n\n#### Algorithm\n\n- Create a list `list` to store all the unique combinations that sum up to the target.\n- Sort the `candidates` array to handle duplicates and facilitate the backtracking process.\n- Call the `backtrack` function with the following parameters:\n  - `answer`: List to store the final combinations.\n  - `tempList`: Temporary list to store the current combination.\n  - `candidates`: Input array of numbers.\n  - `totalLeft`: Remaining sum to reach the target.\n  - `index`: Starting index for the current recursion.\n\n- Within the `backtrack` function:\n  - If `totalLeft` is less than 0, return immediately (invalid path).\n  - If `totalLeft` equals 0:\n    - Add a copy of `tempList` to `answer` (valid combination found).\n  - Otherwise:\n    - Iterate over `candidates` starting from `index`:\n      - Skip duplicate numbers by checking if `candidates[i] == candidates[i - 1]` for `i > index`.\n      - Add `candidates[i]` to `tempList`.\n      - Recursively call `backtrack` with:\n        - Updated `totalLeft` reduced by `candidates[i]`.\n        - Updated `index` as `i + 1` to avoid reusing the same element.\n      - Remove the last element from `tempList` to backtrack and explore other possibilities.\n\n- Return `list` containing all unique combinations after the recursive calls complete.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/SGfPMJBF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"SGfPMJBF\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number of $candidates$ in the array.\n\n- Time complexity: $O(2^N)$\n\n    In the worst case, our algorithm will exhaust all possible combinations from the input array. Again, in the worst case, let us assume that each number is unique. The number of combinations for an array of size $N$ would be $2^N$, i.e. each number is included or excluded in a combination. \n    \n    Additionally, it takes $O(N)$ time to build a counter table out of the input array.\n    \n    Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is $O(2^N)$.\n\n    You must think about how the solution passes the test cases when the value of $N$ goes up to 100. [Pruning](https://en.wikipedia.org/wiki/Decision_tree_pruning) is the process of writing some additional conditions within our recursion code that help us to reduce the size of our recursion trees by removing redundant sections. For example, in this problem, the maximum value of any `candidates` element is given by 50, whereas the maximum `target` value is 30. So, we can stop the recursion when the value of candidates exceeds the `target` value. Sorting the array is another way to prune the recursion tree. Checkout the image for an explanation:\n\n    ![fig](../Figures/40/image.png)\n   \n- Space complexity: $O(N)$\n   \n    We first create a `tempList`, which in the worst case will consume $O(N)$ space to keep track of the combinations. In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack. In the worst case, the stack will pile up to $O(N)$ space.\n\n    To sum up, the overall space complexity of the algorithm is $O(N)$.\n\n    Note: we did not take into account the space needed to hold the final results of the combination in the above analysis.\n\n---\n\nHere are a series of problems you can solve, with some tweaks of the backtracking algorithm presented in this article.\n\n[Subsets](https://leetcode.com/problems/subsets/description/)\n[Subsets II](https://leetcode.com/problems/subsets-ii/description/)\n[Permutations](https://leetcode.com/problems/permutations/description/)\n[Permutations II](https://leetcode.com/problems/permutations-ii/description/)\n[Combinations](https://leetcode.com/problems/combinations/description/)\n[Combination Sum](https://leetcode.com/problems/combination-sum/description/)\n[Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)\n[Palindrome Partition](https://leetcode.com/problems/palindrome-partitioning/description/)\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/combination-sum-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "41",
        "questionFrontendId": "41",
        "title": "First Missing Positive",
        "content": "<p>Given an unsorted integer array <code>nums</code>. Return the <em>smallest positive integer</em> that is <em>not present</em> in <code>nums</code>.</p>\n\n<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses <code>O(1)</code> auxiliary space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,0]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers in the range [1,2] are all in the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,-1,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 1 is in the array but 2 is missing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,8,9,11,12]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The smallest positive integer 1 is missing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 17446,
        "dislikes": 1916,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 1435263, \"totalSubmissionRaw\": 3516469, \"acRate\": \"40.8%\"}",
        "similarQuestions": "[{\"title\": \"Missing Number\", \"titleSlug\": \"missing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All Numbers Disappeared in an Array\", \"titleSlug\": \"find-all-numbers-disappeared-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Couples Holding Hands\", \"titleSlug\": \"couples-holding-hands\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Smallest Number in Infinite Set\", \"titleSlug\": \"smallest-number-in-infinite-set\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Integers to Choose From a Range I\", \"titleSlug\": \"maximum-number-of-integers-to-choose-from-a-range-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Missing Non-negative Integer After Operations\", \"titleSlug\": \"smallest-missing-non-negative-integer-after-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Integers to Choose From a Range II\", \"titleSlug\": \"maximum-number-of-integers-to-choose-from-a-range-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Missing Integer Greater Than Sequential Prefix Sum\", \"titleSlug\": \"smallest-missing-integer-greater-than-sequential-prefix-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think about how you would solve the problem in non-constant space.  Can you apply that logic to the existing space?",
          "We don't care about duplicates or non-positive integers",
          "Remember that O(2n) = O(n)"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe task is to find the smallest positive integer that is not present in `nums`.\n\nNote that positive integers are greater than zero.\n\nLet's discuss the two main cases:\n\n**1. No Missing Integer in `nums`:**\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|\n\n`nums` contains `9` elements. The smallest missing positive integer is `10`.\n\nFor an array of length `n`, if the array contains all of the integers in the range `1` to `n`, the smallest missing positive integer is `n + 1`.\n\n**2. Missing Integer in `nums`:**\n\n|-10 | 1 | 2 | 2 | 3 | 4 | 6 | 6 | 8 |\n|----|---|---|---|---|---|---|---|---|\n\n`nums` contains `9` elements. The smallest missing positive integer is `5`.\n\nFor an array of length `n`, if the array does not contain all of the integers in the range `1` to `n`, the smallest missing positive integer is the first integer missing from that range.\n\nLet's also discuss the constraints:\n\n> You must implement an algorithm that runs in $O(n)$ time and uses $O(1)$ auxiliary space.\n\n**1. Time Complexity:**\n\nHint number three reminds us that $O(2n) = O(n)$. While we know that one does not equal two, $O$ notation describes an algorithm's limiting behavior as the input size grows toward infinity.\n\n**2. Space Complexity:**\n\nThe optimized approaches in this article use in-place solutions. Does in-place mean a constant space complexity? By [definition](https://en.wikipedia.org/wiki/In-place_algorithm), an in-place algorithm transforms the input using no auxiliary data structures proportional to the input size. An in-place algorithm does not necessarily mean constant space complexity; for example, an in-place recursive algorithm uses the recursion stack, so the space is not constant.\n\nThe problem specifically asks us to use constant *auxiliary* space, so in-place solutions meet this criterion.\n\n---\n\n### Approach 1: Boolean Array\n\n#### Intuition\n\nWe can solve the problem by iterating through the numbers `1` to `n`, and use linear search to determine whether each number is in the array. The first number we cannot find is the smallest missing integer. This approach would result in a quadratic time complexity.\n\nWe need to determine whether an element is in the array in constant time. Array indexing provides constant lookup time. We need to check the existence of a relatively small range of values, positive numbers between `1` and `n`, so we can use an array like a hash table by using the index as a key and the value as a presence indicator. The default value is `false`, which represents a missing number, and we set the value to `true` for keys that exist in `nums`. Numbers not in the range `1` to `n` are not relevant in the search for the first missing positive, so we do not mark them in the `seen` array.\n\nTo solve the problem, we can create an array of size `n + 1`. For each positive number less than `n` in `nums`, we set `seen[num]` to `true`. Then, we iterate through the integers `1` to `n` and return the first number that is not marked as seen in the array. If the array contains all of the elements `1` to `n`, we return `n + 1`.\n\n> **Note:** This approach does not meet the problem constraint of solving the problem using constant auxiliary space. It is included to make the solution accessible, and it can provide valuable background for solving the problem within the space constraints. Other approaches that do not meet the time and/or space constraints are not included as they are less relevant to understanding the following approaches.\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`.\n\n2. Initialize an array `seen` to size `n + 1`.\n\n3. Mark the elements in `nums` as seen in the array `seen`.\n\n    - For each `num` in `nums`, if `num` is greater than `0` and less than or equal to `n`, set `seen[num]` to `true`.\n\n4. Find the smallest missing positive number:\n\n    - For `i` from `1` to `n`, If `seen[i]` is not `true`, return `i`, the smallest missing integer.\n\n5. If `seen` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ASLfPBW8/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"ASLfPBW8\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`.\n\n* Time complexity: $O(n)$\n\n    Marking the values from `nums` in `seen` takes $O(n)$.\n\n    We check for values `1` to `n` in `seen`, which takes $O(n)$.\n\n    The total time complexity will be $O(2n)$, which we can simplify to $O(n)$.\n\n* Space complexity: $O(n)$\n\n    We initialize the array `seen`, which is size `n + 1`, so the space complexity is $O(n)$.\n\n---\n\n### Approach 2: Index as a Hash Key\n\n#### Intuition\n\n**Data Clean Up**\n\nOur search for the first missing positive focuses on the elements with values `1` through `n`. Negative numbers, zeros, and numbers larger than `n` are not relevant. Let's replace all these with `1`s. \n\n![max_first](../Figures/41/41_replace.png)\n\nTo ensure that the first missing positive is not `1`, we also have to track whether `1` exists in the original array.\n\n**Solving In-Place**\n\nNow we have an array that contains only positive numbers in a range from `1` to `n`, and the goal is to find the first missing positive in linear time and constant auxiliary space. \n\nIn the above approach, using the `seen` array introduced extra space. We can utilize `nums` itself to track which positive integers occur in the array since the range of numbers we have now is the same as the length of the array. We can use the index as a hash key for a positive number, and the sign of the element as a presence indicator.\n\nFor example, the negative sign of `nums[5]` means that the number `5` is present in `nums`. The positive sign of `nums[6]` means that the number `6` is not present (missing) in `nums`.\n\n![max_first](../Figures/41/41_true_solution.png)\n\nTo determine the smallest missing positive, we traverse the array, check each element value `value`, and change the sign of element `nums[value]` to negative to mark the number `value` as present in `nums`. We must be careful with duplicates and ensure that the sign is changed only once.\n\n> **Interview Tip: In-place Algorithms**\n>\n> This approach modifies the input by changing values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.\n>\n> Here are a couple of situations where an in-place algorithm might not be suitable.\n>\n> 1. The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.\n>\n> 2. Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.\n>\n> In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`, and a boolean `contains1` to `false`.\n\n2. Traverse `nums`, check whether `1` occurs, and replace negative numbers, zeros, and numbers larger than `n` with `1`. For each element in nums:\n\n    - If the element equals `1`, set `contains1` to `true`.\n    - If the element is less than or equal to `0` or greater than `n`, replace it with `1`.\n\n3. If the original `nums` array does not contain `1`, return `1`.\n\n4. Traverse `nums` using a `for` loop from `i` equals `0` to `n`. When `value` is encountered, flip the sign of the number at index `value` to negative to indicate that it is present in the array. Use absolute value to prevent duplicate occurrences of `value` from flipping the sign back to positive.\n    - Set an integer `value` to the absolute value of `nums[i]`.\n    - If `value` equals `n`, we use index `0` to save information about the presence of the number `n` since index `n` is not available. Set `nums[0]` to the negative of the absolute value of `nums[0]`.\n    - Otherwise, we use index `value` to store information about the presence of the number `value`. Set `nums[value]` to the negative of the absolute value of `nums[value]`.\n\n5. Find the smallest missing positive number:\n\n    - Iterate through the integers `1` to `n` using iterator `i`. If `nums[i]` is positive, return `i`.\n\n6. If `nums[0]` is greater than `0` return `n`.\n\n7. If `nums` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number.\n\n!?!../Documents/41_LIS.json:1000,589!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/PppX77uq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PppX77uq\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`,\n\n* Time complexity: $O(n)$\n\n    We traverse `nums` using a `for` loop three separate times, so the time complexity is $O(n)$.\n\n* Space complexity: $O(n)$\n\n    We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$.\n\n    `nums` is the input array, so the *auxiliary* space used is $O(1)$.\n\n---\n\n### Approach 3: Cycle Sort\n\n#### Intuition\n\nIn the first approach, we discussed that we can solve the problem by iterating through the numbers `1` to `n` and searching for each in the array. If `nums` were sorted, this search process could be done in linear time. The built-in sorting functions in most major languages use linear or logarithmic auxiliary space. We need a way to sort the array in-place, in constant time.\n\nThe numbers we need to check for are in the range `1` to `n`, so we can utilize [cycle sort](https://en.wikipedia.org/wiki/Cycle_sort). Cycle sort is a sorting algorithm that can sort a given sequence in a range from `a` to `n` by putting each element at the index that corresponds to its value.\n\n`nums` is a zero-indexed array, so an element with the value `x` will be located at index `x - 1`. For example, `1` goes at index `0` in the array, `2` goes at index `1`, and `100` goes at index `99`. \n\nFor each element `x` in `nums`, if it is a positive integer between `1` and `n`, we place it at index `nums[x - 1]`. Elements smaller than `1` or larger than `n` will reside at indexes that do not have a corresponding value in `nums`.\n\nThen, to determine the smallest positive integer, we iterate through `nums`, and return the first element that is not equal to its index plus one.\n\nIf we iterate through the whole sorted array without returning a value, the array consists of the sequence of numbers `1` through `n`, so we return `n + 1`.\n\n> **Notes:** \n>   - This approach modifies the input. It changes the order of `nums`, but not the values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Always check with your interviewer before modifying the input.\n>\n>   - We use a simplified version of cycle sort because it is not a problem if the duplicate of a value is not in the correct position.\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`.\n\n2. Use cycle sort to place positive elements smaller than `n` at the correct index.\n\n    - Initialize a variable `i` to `0`.\n    - Iterate through the elements in `nums`:\n        - Set a variable `correctIdx` to `nums[i] - 1`.\n        - If the `nums[i]` is greater than zero, less than or equal to `n`, and does not equal `nums[correctIdx]`, swap the element at `nums[i]` with the element at `nums[correctIdx]`.\n        - Otherwise, increment `i`.\n\n3. Iterate through sorted `nums` and return the smallest missing positive number.\n\n    - For each element in `nums`, if `nums[i]` does not equal `i + 1`, return `i + 1`, the smallest missing positive number.\n\n4. Return `n + 1`, the smallest missing positive number when each number in `nums` is in the correct position.\n\n!?!../Documents/41/41_slideshow.json:960,540!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/efsbaqYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"efsbaqYc\"></iframe>\n\n> **Note:** The variable `correctIdx` is included in the Python3 and Java implementations for readability. The C++ version directly uses `nums[i] - 1` to prevent integer overflow.\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`.\n\n* Time complexity: $O(n)$\n\n    We loop through the elements in `nums` once, swapping elements to sort the array. Swapping takes constant time. Sorting `nums` using cycle sort takes $O(n)$ time. \n    \n    Iterating through the sorted array and finding the first missing positive can take up to $O(n)$. \n    \n    The total time complexity is $O(2n)$, which simplifies to $O(n)$.\n\n\n* Space complexity: $O(n)$\n\n    We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$.\n\n    `nums` is the input array, so the *auxiliary* space used is $O(1)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/first-missing-positive/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "42",
        "questionFrontendId": "42",
        "title": "Trapping Rain Water",
        "content": "<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" style=\"width: 412px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [4,2,0,3,2,5]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 33810,
        "dislikes": 590,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 2728024, \"totalSubmissionRaw\": 4223825, \"acRate\": \"64.6%\"}",
        "similarQuestions": "[{\"title\": \"Container With Most Water\", \"titleSlug\": \"container-with-most-water\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Product of Array Except Self\", \"titleSlug\": \"product-of-array-except-self\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Trapping Rain Water II\", \"titleSlug\": \"trapping-rain-water-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Pour Water\", \"titleSlug\": \"pour-water\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Value of an Ordered Triplet II\", \"titleSlug\": \"maximum-value-of-an-ordered-triplet-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/trapping-rain-water/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "43",
        "questionFrontendId": "43",
        "title": "Multiply Strings",
        "content": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\n\n<p><strong>Note:</strong>&nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num1 = \"2\", num2 = \"3\"\n<strong>Output:</strong> \"6\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num1 = \"123\", num2 = \"456\"\n<strong>Output:</strong> \"56088\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>\n\t<li><code>num1</code> and <code>num2</code> consist of digits only.</li>\n\t<li>Both <code>num1</code> and <code>num2</code>&nbsp;do not contain any leading zero, except the number <code>0</code> itself.</li>\n</ul>\n",
        "likes": 7349,
        "dislikes": 3514,
        "stats": "{\"totalAccepted\": \"953.6K\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 953635, \"totalSubmissionRaw\": 2269485, \"acRate\": \"42.0%\"}",
        "similarQuestions": "[{\"title\": \"Add Two Numbers\", \"titleSlug\": \"add-two-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Plus One\", \"titleSlug\": \"plus-one\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Strings\", \"titleSlug\": \"add-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Apply Discount to Prices\", \"titleSlug\": \"apply-discount-to-prices\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given two non-negative integers that are represented as strings and asked to return the product of the two integers, also in the form of a string. There are a few subtle challenges and edge cases that we must consider to solve this problem.  So, before determining how to multiply two numbers in string format, let's first consider a simpler variation of the problem: adding two numbers in string format.  \nWe can add two numbers represented as strings by adding digits from the given numbers in each place.  The sum of two digits must be between 0 and 18. The ones place is added to the result while the tens place is carried and summed with the next pair of digits. When summing two numbers, the carried digit will always be zero or one. This process can be repeated for each digit, as shown below.\n\n![image](../Figures/43/Slide31.JPG)\n\nWhy does learning how to add two integers represented as strings help us solve this problem? As we will soon see, addition is a subproblem of multiplication. Thus we will need to be able to solve the problem of adding two numbers as strings before we can solve the problem of multiplying two numbers as strings.\n\nIf this type of problem is new to you and you would like to practice by solving similar problems, we have provided the list below: \n1. [66. Plus One](https://leetcode.com/problems/plus-one/)      \n2. [67. Add Binary](https://leetcode.com/problems/add-binary/)      \n3. [415. Add Strings](https://leetcode.com/problems/add-strings/)  \n4. [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)     \n\n\n---\n\n### Approach 1: Elementary Math\n\n#### Intuition\n\nOur goal is to multiply two integer numbers that are represented as strings. However, we are not allowed to use a built-in BigInteger library or convert the inputs to integers directly. So how can we multiply the two input strings? We can try to break the problem down into manageable chunks, as is done in elementary mathematics.  Thus, we will focus on one digit at a time, just like in the addition example, except here we will be multiplying both numbers digit by digit.  \n\n**Now, let's recall the process for multiplying two numbers.**      \nWe take the ones place digit of the second number, then multiply it with all digits of the first number consequently going backward, and write the result. We need to remember about carry as well. Note that for multiplication, carry may be any digit between 0 and 8.\n\n![image](../Figures/43/Slide1.JPG)\n\n<br />\n\nThen we take the tens place digit of the second number and multiply it with all digits of the first number.  Since we used the tens place digit, we will multiply this result by 10.  Then we write this result below the previous result, signifying that we will **add** it to the previous result later.\n\n![image](../Figures/43/Slide2.JPG)\n\n<br />\n\nThen we continue the same way with hundreds place digit, then with thousands place digit of the second number, and so on, until we have visited every digit in the second number.\n\n![image](../Figures/43/Slide3.JPG)\n\n<br />\n\nAs is evident from the above diagram, this process is equivalent to multiplying each digit of the second number by the entire first number and appending zeros at the end of each intermediate result based on the place in the second number that the digit came from.\nThen we add all the results together to get the final product of the first and second numbers.\n\n![image](../Figures/43/Slide4.JPG)\n\n<br />\n\nLet's look at an example. Consider $$123 * 456$$, it can be written as,\n\n$$\\implies (123 * (6 + 50 + 400))$$      \n$$\\implies (123 * 6) + (123 * 50) + (123 * 400)$$     \n$$\\implies (123 * 6) + (123 * 5 * 10) + (123 * 4 * 100)$$     \n \n$$\\implies \\Sigma \\space ( firstNumber * j^{th} \\space digit \\space of \\space secondNumber * 10^{(index \\space j \\space of \\space digit \\space counting \\space from \\space the \\space end)} )$$      \n\nThe results of the multiplication of each digit of the second number with the first number can be stored in an array of strings, and then we can add all these strings to get the final product.     \n\n#### Algorithm\n\nMultiplication of both numbers starts from the ones place digit (the right-most digit), so we should start our multiplication from index `num2.size() - 1` and go to index `0`.  Alternatively, we can reverse both inputs and iterate from index `0` to index `num2.size() - 1`.\n\nFor each digit in `num2` that we multiply by `num1` we will get a new intermediate result.  This intermediate result (`currentResult`) will be stored in a list, string, or StringBuilder, depending on the language of choice.  To calculate each intermediate result, we will start by inserting the appropriate number of zeros according to the current digit's place in the second number (i.e. if it is the hundreds place, we append 2 zeros).  Then we will perform the multiplication step as demonstrated in the above diagrams. During this step, we will insert the lower place digits into the `currentResult` before the higher place digits.  Because we are pushing the lower place digits first and always appending to the end, our result will be in reverse order, so once the multiplication and addition steps are complete, we will need to reverse `answer` before returning.\n\nLet's walk through the steps one by one:\n\n1. Reverse both numbers.\n2. For each digit in `secondNumber`:\n    - Keep a `carry` variable, initially equal to `0`.\n    - Initialize `currentResult` array beginning with the appropriate number of zeros according to the place of the `secondNumber` digit.\n    - For each digit in `firstNumber`:\n        - Multiply the `secondNumber`'s digit and the `firstNumber`'s digit and add `carry` to the `multiplication`.\n        - Take the remainder of `multiplication` with `10` to get the last digit.\n        - Append the last digit to the `currentResult`.\n        - Divide `multiplication` by `10` to get the new value for `carry`.\n    - Append the remaining value for `carry` (if any) to the `currentResult`.\n    - Push the `currentResult` into the `results` array.\n3. Compute the cumulative sum over all the obtained arrays using the `ans` as an answer.\n4. Reverse `ans` and return it.\n\n!?!../Documents/43/slideshow1.json:960,540!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ecJN2cdc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ecJN2cdc\"></iframe>\n\n\n#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of digits in `num1` and `num2` respectively.\n\n* Time complexity: $$O(M^2 + M \\cdot N)$$.\n\n  During multiplication, we perform $$N$$ operations for each of the $$M$$ digits of the second number; this requires $$O(M \\cdot N)$$ time. Then we add each of the $$M$$ multiplication results (of length $$O(N + M)$$) to the answer string; this requires $$O(M \\cdot (M + N))$$ time.\n   \n  > When we multiply a number with one digit, the result's maximum length can be at most one more than the number's length _(We can see that when we multiply the max integer of `d` digits, i.e., `9...99` with `9`)_ and there can be at most (M-1) zeroes initially appended to the result. Hence, each result is of order $$O(N + M)$$.\n   \n  Summing the results requires iterating over the length of the current answer for each result.  Since the length of two numbers multiplied together cannot be longer than the sum of the lengths of the two numbers, iterating over each digit in the answer will take $$O(M + N)$$ time and we will do so $$M - 1$$ times (for all but one of the $$M$$ results). So this step takes $$O(M \\cdot (M + N))$$ time.  \n   \n  Finally, reversing the answer will require $$O(M + N)$$ time. Taking all steps into consideration, the total time complexity is $$O(M^2 + M \\cdot N)$$.\n\n* Space complexity: $$O(M^2 + M \\cdot N)$$.     \n\n  We store each result of multiplication for each digit of `num2` with `num1` in the results array. Each multiplication result can have at most $$N + M$$ length, and there will be $$M$$ such results. Thus the space complexity is $$O(M \\cdot (M + N))$$.\n    \n\n<br/>\n\n---\n\n### Approach 2: Elementary math using less intermediate space\n\n#### Intuition\n\nNotice that we are storing the multiplication result for every digit in `num2`. If we know the maximum size of the answer array ahead of time, we can add each multiplication result directly to the final answer. Thus, we can avoid using the extra space required by the `results` array.\n\nFirst, let's determine what the maximum size of the answer array would be.\n\nTry a few test cases on your own, multiply two numbers, count how many digits are in the result, and compare that to the number of digits in each number.  Notice that whenever two numbers with the number of digits $$N$$ and $$M$$ are multiplied, the result never exceeds $$(N+M)$$ digits. \n\nWe could readily accept that <strong>num1.length + num2.length \u2265 (num1 \u00b7 num2).length</strong> without rigorous proof. However, it never hurts to verify a relationship that was derived from observation before accepting it as a fact. Don't worry, you will not be expected to provide a proof like this during the interview, hence you can skip it if you want.\n\n<details>\n\n<summary> The proof that the length of the product of two numbers is always less than or equal to the sum of lengths of the two numbers is as follows: (click to show/hide) </summary>\n\n<br>\n\n> A number $$n$$ has digits, $$ d = 1 + \\lfloor log_{10}(n) \\rfloor $$.  \n   \nIts proof is:   \n> Suppose that $$n$$ has $$d$$ digits, then $$ 10^{d-1} \\leq n < 10^{d} $$, because $$ 10^{d} $$ is the smallest integer with $$d+1$$ digits.       \nNow take log base 10, then the inequality becomes $$ (d-1) \\leq \\log_{10}(n) < d $$.      \nNow everything between the range $$(d-1, \\space d)$$ is decimal part, so taking floor of $$ \\log_{10}(n) $$ we can eliminate all the decimal part and get, $$ (d-1) = \\lfloor \\log_{10}(n) \\rfloor $$. \n<br />           \nThus, $$d = \\lfloor \\log_{10}(n) \\rfloor + 1$$.\n\n<br />\n\nLet $$firstNumber$$ have $$N$$ digits and $$secondNumber$$ have $$M$$ digits.      \n\nLet $$product = firstNumber \\cdot secondNumber$$ have $$X$$ digits. So, number of digits in $$product$$ is,      \n           \n$$  \\implies X = 1 + \\lfloor log_{10}(result) \\rfloor   $$         \n$$  \\implies X = 1 + \\lfloor log_{10}(firstNumber \\cdot secondNumber) \\rfloor   $$         \n$$  \\implies X = 1 + \\lfloor log_{10}(firstNumber) + log_{10}(secondNumber) \\rfloor $$ <br />         \n                 \n\n> A real number $$a$$ can have two parts in it, integral $$(I)$$ and fractional $$(F)$$. $$a = I_{a} + F_{a}$$.    \n\nNow, let's say we have two real numbers $$a = I_{a} + F_{a} $$ and $$b = I_{b} + F_{b}$$. \n<br />     \n\n$$ \\lfloor a + b \\rfloor = \\lfloor I_{a} + F_{a} + I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} + F_{b} \\rfloor $$     \n$$ F_{a}, F_{b} $$ are fractional parts both always less than 1.           \n$$ 0 \\leq F_{a} + F_{b} < 2 $$.      \n$$ 0 \\leq \\lfloor F_{a} + F_{b} \\rfloor <= 1 $$. <br />       \n> So, $$ I_{a} + I_{b} \\leq \\lfloor a + b \\rfloor \\leq  I_{a} + I_{b} + 1$$. \n<br />     \n\nBut, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor = \\lfloor I_{a} + F_{a} \\rfloor + \\lfloor I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor $$     \n$$ F_{a}, F_{b} $$ are fractional parts both always less than $$ 1 $$.        \n$$ 0 \\leq F_{a}, \\space F_{b} < 1 $$.          \nHence, $$ \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor = 0 $$. <br />       \n> So, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor = I_{a} + I_{b} $$. \n\n> Hence we can conclude here that, <br />     \n> $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 $$  \n\n<br />\n\nNumber of digits in,\n$$ firstNumber = N, \\space secondNumber = M, \\space product = X $$ <br />  \nIf $$ a = log_{10}(firstNumber) $$ and $$ b = log_{10}(secondNumber) $$.     \n\n$$ N = \\lfloor log_{10} (firstNumber) \\rfloor + 1 = \\lfloor a \\rfloor + 1$$     \n$$ M = \\lfloor log_{10} (secondNumber) \\rfloor + 1 = \\lfloor b \\rfloor + 1$$     \n$$ X = \\lfloor log_{10} (firstNumber) + log_{10} (secondNumber) \\rfloor + 1 = \\lfloor a + b \\rfloor + 1$$      \n<br />\n\n$$ \\lfloor a \\rfloor = N - 1, \\space  \\lfloor b \\rfloor = M - 1, \\space  \\lfloor a + b \\rfloor = X - 1,  $$ <br />        \n\nas, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 $$  \n\n$$ \\implies (N-1) + (M-1) \\leq (X - 1) \\leq (N-1) + (M-1) + 1 $$       \n$$ \\implies (N + M - 1) \\leq X \\leq (N + M) $$ \n\n> Hence, $$X$$ can never exceed $$ (N + M) $$. \n\n</details>\n\n<br />\n\nSo an answer string of size $$N + M$$ is guaranteed to be large enough to hold our final result.  Let's create one and initialize all of its values as zero.\nInstead of storing all results of multiplication of each digit of $$num2$$ with $$num1$$ like we did in Approach 1, we can directly add the current result to the answer string.      \n\n#### Algorithm\n\n1. Reverse both numbers.\n2. Initialize `ans` array with $$(N+M)$$ zeros.\n3. For each digit in `secondNumber`:\n    - Keep a `carry` variable, initially equal to `0`.\n    - Initialize an array (`currentResult`) that begins with some zeros based on the place of the digit in `secondNumber`.\n    - For each digit of `firstNumber`:\n        - Multiply `secondNumber's` digit and `firstNumber's` digit and add previous `carry` to the `multiplication`.\n        - Take the remainder of `multiplication` with `10` to get the last digit.\n        - Append the last digit to `currentResult` array.\n        - Divide the `multiplication` by `10` to obtain the new value for `carry`.\n    - After iterating over each digit in the first number, if `carry` is not zero, append `carry` to the `currentResult`.\n    - Add `currentResult` to the `ans`.\n4. If the last digit in `ans` is zero, before reversing `ans`, we must pop the zero from `ans`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `ans` and return it.\n\n!?!../Documents/43/slideshow2.json:960,540!?!\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/aiu9hUhq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"aiu9hUhq\"></iframe>\n\n\n#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of elements in num 1 and num 2 strings.\n\n* Time complexity: $$O(M \\cdot (N+M))$$.     \n   - During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need $$O(M \\cdot N)$$ time for it.     \n   - We add the multiplication result to the `ans` string that has a length of $$N+M$$. There will be $$M$$ such additions since we have $$M$$ multiplication results. Therefore, the time consumed here will be $$O(M \\cdot (N+M))$$.\n   - It takes linear time to reverse the strings.\n   - Overall, this solution takes $$O(M \\cdot N + M \\cdot (N+M) + M + N) = O(M \\cdot (N+M))$$ time.\n\n* Space complexity: $$O(N + M)$$.     \n   - The answer string and multiplication results will have at most $$N + M$$ length.\n\n<br/>\n\n---\n\n### Approach 3: Sum the products from all pairs of digits\n\n#### Intuition\n\nAs we have seen in the previous approaches, when we multiply two digits, one from the first number and one from the second number, then their product will have some zeros appended at the end. The number of zeros depends on the place of each digit, and (as demonstrated in the image below) when the result is added to the answer, the trailing zeros do not affect the answer (because any number plus zero is itself).\nSo it is not necessary for us to append zeros at the end of each result before adding the result to the final answer. Instead, we can directly add the multiplication result at the place where the least significant digit will shift to after to appending some zeros.  \n\nAs an example, when we multiply two tens place digits, two zeros are appended at the end of the multiplication result, and the result will be added at the hundreds place in the final answer. One more example for clarity, if we multiplied a digit in the thousands place (3 trailing zeros) by a digit in the hundreds place (2 trailing zeros), the product will have 5 trailing zeros (the sum of trailing zeros of each digit) so the result will only affect the hundred thousands place and the millions place in the final answer.  \n\n![image](../Figures/43/Slide32.JPG)     \n\n<br />\n\nIn the previous solution, including the extra zeros was quite costly.  For instance, `multiplyOneDigit` stored these extra zeros for every intermediate result which required an additional $$O(N)$$ space and time for each multiplication, where $$N$$ is the number of digits in `num2`.  Furthermore, every time we called `multiplyOneDigit` we added the result to the current `answer`.  This involved iterating over all $$M + N$$ digits in answer each time we added a new result to the current answer. So let's get a better idea of how we can solve this problem without iterating over all the extra zeros.\n\nTake a moment to study the above example.  Notice that we multiply each digit in `num2` by each digit in `num1` just like before. Each time we will get a 2-digit result with some zeros after it. Since we know how many zeros will follow the product of the two digits based on their places, we know which two places in `answer` to update.  So, instead of updating all $$M + N$$ elements in `answer` for each of the $$N$$ digits in `num2`, we only need to update $$2$$ digits in `answer` for each of the $$M \\cdot N$$ pairs of digits.  The above example highlights the two digits from each result that we will add to the answer and the below example shows precisely how this will be done.\n\nThus, for each pair of digits, we multiply them together to get a 2-digit result. The ones place of the result will be added at the correct position in `answer` (based on the place of each of the digits). The tens place of the result will be added to the next place in `answer`. This step is effectively the same as carrying the tens place digit in the previous approaches.\n\nNote that the `answer` array will be reversed just like before. So when we multiply a digit in the $$i^{th}$$ place of the first number by a digit in the $$j^{th}$$ place of the second number, then the ones place of the result will add to the $$(i+j)^{th}$$ place in the final answer and the tens place of the result (carry) will be added to the $$(i+j+1)^{th}$$ place in the final answer. \n\n\n#### Algorithm\n\n1. Reverse both numbers.\n2. Initialize `answer` with $$N + M$$ zeros.\n3. For each digit at position `i` in `secondNumber`:\n    - For each digit at position `j` in `firstNumber`:\n        - Multiply the digit from `secondNumber` by the digit from `firstNumber` and add previously carried value to the `multiplication` result.  The previously carried value can be found at position `i + j` in the `answer`.\n        - Take the remainder of `multiplication` with `10` to get the ones place digit of the `multiplication` result.\n        - Put the last digit at current position (position `i + j`) in `answer`.\n        - Divide the `multiplication` by `10` to get the new value for carry and add it to `answer` at the next position.  Note, the next position is located at `(i + j + 1)`.\n4. If the last digit in `answer` is zero, before reversing `answer`, we must pop the zero from `answer`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `answer` and return it.\n\n!?!../Documents/43/slideshow3.json:960,540!?!\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/ktauubWh/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ktauubWh\"></iframe>\n\n\n#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of digits in `num1` and `num2` respectively.\n\n* Time complexity: $$O(M \\cdot N)$$.     \n\n  During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need $$M \\cdot N$$ time for it.\n\n* Space complexity: $$O(M + N)$$.     \n\n  The space used to store the output is not included in the space complexity. However, because strings are immutable in Python, Java, and Javascript, a temporary data structure, using $$O(M + N)$$ space, is required to store the answer while it is updated.\n  \n  On the other hand, in C++, strings are mutable, so we do not need a temporary data structure to store answer and can update answer directly.  Thus, the C++ approach is a constant space solution."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/multiply-strings/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "44",
        "questionFrontendId": "44",
        "title": "Wildcard Matching",
        "content": "<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;?&#39;</code> Matches any single character.</li>\n\t<li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>&nbsp;&#39;*&#39; matches any sequence.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cb&quot;, p = &quot;?a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong>&nbsp;&#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li>\n</ul>\n",
        "likes": 8597,
        "dislikes": 386,
        "stats": "{\"totalAccepted\": \"696.8K\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 696839, \"totalSubmissionRaw\": 2358240, \"acRate\": \"29.5%\"}",
        "similarQuestions": "[{\"title\": \"Regular Expression Matching\", \"titleSlug\": \"regular-expression-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Substring Matching Pattern\", \"titleSlug\": \"substring-matching-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/wildcard-matching/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "45",
        "questionFrontendId": "45",
        "title": "Jump Game II",
        "content": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p>\n\n<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>Return <em>the minimum number of jumps to reach </em><code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,0,1,4]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>\n</ul>\n",
        "likes": 15413,
        "dislikes": 645,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"4M\", \"totalAcceptedRaw\": 1668242, \"totalSubmissionRaw\": 4043754, \"acRate\": \"41.3%\"}",
        "similarQuestions": "[{\"title\": \"Jump Game\", \"titleSlug\": \"jump-game\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game III\", \"titleSlug\": \"jump-game-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VII\", \"titleSlug\": \"jump-game-vii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VIII\", \"titleSlug\": \"jump-game-viii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Visited Cells in a Grid\", \"titleSlug\": \"minimum-number-of-visited-cells-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Jumps to Reach the Last Index\", \"titleSlug\": \"maximum-number-of-jumps-to-reach-the-last-index\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Visit Array Positions to Maximize Score\", \"titleSlug\": \"visit-array-positions-to-maximize-score\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/jump-game-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "46",
        "questionFrontendId": "46",
        "title": "Permutations",
        "content": "<p>Given an array <code>nums</code> of distinct integers, return all the possible <span data-keyword=\"permutation-array\">permutations</span>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [[0,1],[1,0]]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 19822,
        "dislikes": 354,
        "stats": "{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"3.2M\", \"totalAcceptedRaw\": 2532986, \"totalSubmissionRaw\": 3152636, \"acRate\": \"80.3%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations II\", \"titleSlug\": \"permutations-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutation Sequence\", \"titleSlug\": \"permutation-sequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Combinations\", \"titleSlug\": \"combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/permutations/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "47",
        "questionFrontendId": "47",
        "title": "Permutations II",
        "content": "<p>Given a collection of numbers, <code>nums</code>,&nbsp;that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n",
        "likes": 8767,
        "dislikes": 153,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 1083093, \"totalSubmissionRaw\": 1769122, \"acRate\": \"61.2%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation II\", \"titleSlug\": \"palindrome-permutation-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Squareful Arrays\", \"titleSlug\": \"number-of-squareful-arrays\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nAs the name of the problem suggests, this problem is an extension of the [Permutation](https://leetcode.com/problems/permutations/) problem.\nThe problem is different from the previous permutation problem on the condition that the input array can contain **_duplicates_**.\n\nThe key to solve the problem is still the **_backtracking_** algorithm.\nHowever, we need some adaptation to ensure that the _enumerated_ solutions generated from our backtracking exploration do not have any duplicates.\n\n>As a reminder, **[backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/)** is a general algorithm for finding all (or some) solutions to some problems with constraints.\nIt incrementally builds candidates to the solutions, and abandons a candidate as soon as it determines that the candidate cannot possibly lead to a solution.\n\nIn this article, we will present a yet another backtracking solution to solve the problem.\n\n---\n### Approach 1: Backtracking with Groups of Numbers\n\n**Intuition**\n\nFirst of all, let us review the general idea of permutation with an example.\n\nGiven the input array `[1, 1, 2]`, to generate a permutation of the array, we could follow the _Depth-First Search_ (DFS) approach, or more precisely the backtracking technique as one will see later.\n\n>The idea is that we pick the numbers one by one. For a permutation of length $$N$$, we would then need $$N$$ stages to generate a valid permutation.\nAt each stage, we need to pick one number into the permutation, out of the remaining available numbers.\nLater at the same stage, we will try out all available choices.\nBy trying out, we progressively build up candidates to the solution, and revert each choice with another alternative until there is no more choice.\n\nLet us walk through the example with paper and pencil, as follows:\n\n- Given the input of `[1, 1, 2]`, at the first stage, we have 2 choices to pick a number as the first number in the final permutation, _i.e._ `1` and `2`.\nSuppose that we pick the number `1`, now the remaining numbers would become `[1, 2]`.\n**Note:** The reason that we have only 2 choices instead of 3, is that there is a duplicate in the given input.\nPicking any of the duplicate numbers as the first number of the permutation would lead us to the same permutation at the end.\nShould the numbers in the array be all unique, we would then have the same number of choices as the length of the array. \n\n- At the second stage, we now then have again 2 choices, _i.e._ `[1, 2]`. \nLet us pick again the number `1`, which leaves us the only remaining number `2`.\n\n- Now at the third stage, we have only one candidate number left, _i.e._ `[2]`. We then pick the last remaining number, which leads to a final permutation sequence of `[1, 1, 2]`.\n\n- Moreover, we need to **_revisit_** each of the above stages, and make a different choice in order to try out all possibilities.\nThe reversion of the choices is what we call __*backtracking*__.\n\nWe illustrate all potential exploration in the following graph where each node represents a choice at a specific stage:\n\n![permutation tree](../Figures/47/47_permutations.png)\n\n>A key insight to avoid generating any **_redundant_** permutation is that at each step rather than viewing each number as a candidate, we consider each **_unique_** number as the true candidate.\nFor instance, at the very beginning, given in the input of `[1, 1, 2]`, we have only two true candidates instead of three.\n\n\n**Algorithm**\n\nGiven the above insight, in order to find out all the unique numbers at each stage, we can build a **_hash table_** (denoted as `counter`), with each unique number as the key and its occurrence as the corresponding value.\n\nTo implement the algorithm, first we define a function called `backtrack(comb, counter)` which generates all permutations, starting from the current combination (`comb`) and the remaining numbers (`counter`).\n\nOnce the function is implemented, it suffices to invoke the function with the initial empty combination and the hash table we built out of the input array, to solve the problem.\n\nHere are some sample implementations.\n\n<iframe src=\"https://leetcode.com/playground/gmT2V4Q3/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gmT2V4Q3\"></iframe>\n\n**Note:** for a backtracking algorithm, usually there are some explorations that would lead to a *dead end*, and we have to abandon those explorations in the middle.\n\nHowever, due to the specificity of this problem and our exploration strategy, each exploration will result in a valid permutation, _i.e._ none of the efforts is in vain.\nThis insight would prove to be useful in the following complexity analysis.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the input array.\nHence, the number of permutations would be at maximum $$N!$$, _i.e._ $$N \\cdot (N-1) \\cdot (N-2) ... 1$$, when each number in the array is unique.\n\n- Time Complexity: $$\\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big)$$ where $$P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)$$\nis so-called [_k-permutations_of_N_ or _partial permutation_](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n). \n\n    - As one can see in the exploration graph we have shown earlier, the execution of the backtracking algorithm will unfold itself as a tree, where each node is an invocation of the recursive function `backtrack(comb, counter)`.\n    The total number of steps to complete the exploration is _exactly_ the number of nodes in the tree.\n    Therefore, the time complexity of the algorithm is linked directly with the size of the tree.\n\n    - It now boils down to estimating the number of nodes in the tree.\n    As we know now, each level of the tree corresponds to a specific _stage_ of the exploration.\n    At each stage, the number of candidates to explore is **bounded**.\n    For instance, at the first stage, _at most_ we would have $$N$$ candidates to explore, _i.e._ the number of nodes at this level would be $$N$$.\n    Moving on to the next stage, for each of the nodes in the first stage, we would have $$N-1$$ child nodes. Therefore, the number of nodes at this stage would be $$N \\cdot (N-1)$$.\n    So on and so forwards.\n\n    ![number of nodes](../Figures/47/47_number_of_nodes.png)\n\n    - By summing up all the nodes across the stages, we would then obtain the total number of nodes as $$\\sum_{k = 1}^{N}{P(N, k)}$$ where $$P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)$$.\n    As a result, the exact time complexity of the algorithm is $$\\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big)$$.\n\n    - The above complexity might appear a bit too abstract to comprehend.\n    Here we could provide another __*loose upper bound*__ on the complexity.\n\n    - It takes $$N$$ steps to generate a single permutation. Since there are in total $$N!$$ possible permutations, at most it would take us $$N \\cdot N!$$ steps to generate all permutations, simply assuming that there is no overlapping effort (which is not true).\n\n\n- Space Complexity: $$\\mathcal{O}(N)$$\n\n    - First of all, we build a hash table out of the input numbers. In the worst case where each number is unique, we would need $$\\mathcal{O}(N)$$ space for the table.\n\n    - Since we applied recursion in the algorithm which consumes some extra space in the function call stack, we would need another $$\\mathcal{O}(N)$$ space for the recursion.\n\n    - During the exploration, we keep a candidate of permutation along the way, which takes yet another $$\\mathcal{O}(N)$$.\n\n    - To sum up, the total space complexity would be $$\\mathcal{O}(N) + \\mathcal{O}(N) + \\mathcal{O}(N) = \\mathcal{O}(N)$$.\n\n    - **Note**, we did not take into account the space needed to hold the results. Otherwise, the space complexity would become $$\\mathcal{O}(N \\cdot N!)$$.\n\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/permutations-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "48",
        "questionFrontendId": "48",
        "title": "Rotate Image",
        "content": "<p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>\n\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"width: 500px; height: 188px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"width: 500px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 18540,
        "dislikes": 887,
        "stats": "{\"totalAccepted\": \"2.2M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 2219393, \"totalSubmissionRaw\": 2865793, \"acRate\": \"77.4%\"}",
        "similarQuestions": "[{\"title\": \"Determine Whether Matrix Can Be Obtained By Rotation\", \"titleSlug\": \"determine-whether-matrix-can-be-obtained-by-rotation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rotate-image/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "49",
        "questionFrontendId": "49",
        "title": "Group Anagrams",
        "content": "<p>Given an array of strings <code>strs</code>, group the <span data-keyword=\"anagram\">anagrams</span> together. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>There is no string in strs that can be rearranged to form <code>&quot;bat&quot;</code>.</li>\n\t<li>The strings <code>&quot;nat&quot;</code> and <code>&quot;tan&quot;</code> are anagrams as they can be rearranged to form each other.</li>\n\t<li>The strings <code>&quot;ate&quot;</code>, <code>&quot;eat&quot;</code>, and <code>&quot;tea&quot;</code> are anagrams as they can be rearranged to form each other.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">strs = [&quot;&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;&quot;]]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">strs = [&quot;a&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;a&quot;]]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "likes": 20342,
        "dislikes": 679,
        "stats": "{\"totalAccepted\": \"3.7M\", \"totalSubmission\": \"5.2M\", \"totalAcceptedRaw\": 3674079, \"totalSubmissionRaw\": 5205612, \"acRate\": \"70.6%\"}",
        "similarQuestions": "[{\"title\": \"Valid Anagram\", \"titleSlug\": \"valid-anagram\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Group Shifted Strings\", \"titleSlug\": \"group-shifted-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Resultant Array After Removing Anagrams\", \"titleSlug\": \"find-resultant-array-after-removing-anagrams\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Anagrams\", \"titleSlug\": \"count-anagrams\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/group-anagrams/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "50",
        "questionFrontendId": "50",
        "title": "Pow(x, n)",
        "content": "<p>Implement <a href=\"http://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x<sup>n</sup></code>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.00000, n = 10\n<strong>Output:</strong> 1024.00000\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.10000, n = 3\n<strong>Output:</strong> 9.26100\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.00000, n = -2\n<strong>Output:</strong> 0.25000\n<strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code> is an integer.</li>\n\t<li>Either <code>x</code> is not zero or <code>n &gt; 0</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 10588,
        "dislikes": 10093,
        "stats": "{\"totalAccepted\": \"2.2M\", \"totalSubmission\": \"5.9M\", \"totalAcceptedRaw\": 2153974, \"totalSubmissionRaw\": 5866074, \"acRate\": \"36.7%\"}",
        "similarQuestions": "[{\"title\": \"Sqrt(x)\", \"titleSlug\": \"sqrtx\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Super Pow\", \"titleSlug\": \"super-pow\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Collisions of Monkeys on a Polygon\", \"titleSlug\": \"count-collisions-of-monkeys-on-a-polygon\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/powx-n/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "51",
        "questionFrontendId": "51",
        "title": "N-Queens",
        "content": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>\n\n<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>Each solution contains a distinct board configuration of the n-queens&#39; placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> [[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n<strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[&quot;Q&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n",
        "likes": 13115,
        "dislikes": 319,
        "stats": "{\"totalAccepted\": \"944.1K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 944060, \"totalSubmissionRaw\": 1309637, \"acRate\": \"72.1%\"}",
        "similarQuestions": "[{\"title\": \"N-Queens II\", \"titleSlug\": \"n-queens-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Grid Illumination\", \"titleSlug\": \"grid-illumination\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/n-queens/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "52",
        "questionFrontendId": "52",
        "title": "N-Queens II",
        "content": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>\n\n<p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the&nbsp;<strong>n-queens puzzle</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two distinct solutions to the 4-queens puzzle as shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n",
        "likes": 4047,
        "dislikes": 273,
        "stats": "{\"totalAccepted\": \"478.3K\", \"totalSubmission\": \"626.9K\", \"totalAcceptedRaw\": 478317, \"totalSubmissionRaw\": 626934, \"acRate\": \"76.3%\"}",
        "similarQuestions": "[{\"title\": \"N-Queens\", \"titleSlug\": \"n-queens\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/n-queens-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "53",
        "questionFrontendId": "53",
        "title": "Maximum Subarray",
        "content": "<p>Given an integer array <code>nums</code>, find the <span data-keyword=\"subarray-nonempty\">subarray</span> with the largest sum, and return <em>its sum</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The subarray [1] has the largest sum 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,-1,7,8]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>\n",
        "likes": 35476,
        "dislikes": 1499,
        "stats": "{\"totalAccepted\": \"4.8M\", \"totalSubmission\": \"9.3M\", \"totalAcceptedRaw\": 4832020, \"totalSubmissionRaw\": 9315011, \"acRate\": \"51.9%\"}",
        "similarQuestions": "[{\"title\": \"Best Time to Buy and Sell Stock\", \"titleSlug\": \"best-time-to-buy-and-sell-stock\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Degree of an Array\", \"titleSlug\": \"degree-of-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Longest Turbulent Subarray\", \"titleSlug\": \"longest-turbulent-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Score Of Spliced Array\", \"titleSlug\": \"maximum-score-of-spliced-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Absolute Sum of Any Subarray\", \"titleSlug\": \"maximum-absolute-sum-of-any-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Subarray Sum After One Operation\", \"titleSlug\": \"maximum-subarray-sum-after-one-operation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Substring With Largest Variance\", \"titleSlug\": \"substring-with-largest-variance\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Subarrays With Score Less Than K\", \"titleSlug\": \"count-subarrays-with-score-less-than-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Value of a String in an Array\", \"titleSlug\": \"maximum-value-of-a-string-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Substring With Maximum Cost\", \"titleSlug\": \"find-the-substring-with-maximum-cost\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"K Items With the Maximum Sum\", \"titleSlug\": \"k-items-with-the-maximum-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Good Subarray Sum\", \"titleSlug\": \"maximum-good-subarray-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximize Subarray Sum After Removing All Occurrences of One Element\", \"titleSlug\": \"maximize-subarray-sum-after-removing-all-occurrences-of-one-element\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/maximum-subarray/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "54",
        "questionFrontendId": "54",
        "title": "Spiral Matrix",
        "content": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
        "likes": 15893,
        "dislikes": 1422,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 1858796, \"totalSubmissionRaw\": 3485675, \"acRate\": \"53.3%\"}",
        "similarQuestions": "[{\"title\": \"Spiral Matrix II\", \"titleSlug\": \"spiral-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix III\", \"titleSlug\": \"spiral-matrix-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix IV\", \"titleSlug\": \"spiral-matrix-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.",
          "We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need.",
          "Think about when you want to switch the progress on one of the indexes. If you progress on i out of [i, j], you'll shift in the same column. Similarly, by changing values for j, you'd be shifting in the same row.\r\nAlso, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to simulate edge cases like a single column or a single row to see if anything breaks or not."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/spiral-matrix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "55",
        "questionFrontendId": "55",
        "title": "Jump Game",
        "content": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array&#39;s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>\n\n<p>Return <code>true</code><em> if you can reach the last index, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,0,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 20416,
        "dislikes": 1377,
        "stats": "{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"6.5M\", \"totalAcceptedRaw\": 2535318, \"totalSubmissionRaw\": 6463803, \"acRate\": \"39.2%\"}",
        "similarQuestions": "[{\"title\": \"Jump Game II\", \"titleSlug\": \"jump-game-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game III\", \"titleSlug\": \"jump-game-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VII\", \"titleSlug\": \"jump-game-vii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VIII\", \"titleSlug\": \"jump-game-viii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Visited Cells in a Grid\", \"titleSlug\": \"minimum-number-of-visited-cells-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Largest Element in an Array after Merge Operations\", \"titleSlug\": \"largest-element-in-an-array-after-merge-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/jump-game/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "56",
        "questionFrontendId": "56",
        "title": "Merge Intervals",
        "content": "<p>Given an array&nbsp;of <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>Output:</strong> [[1,6],[8,10],[15,18]]\n<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[4,5]]\n<strong>Output:</strong> [[1,5]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 23221,
        "dislikes": 843,
        "stats": "{\"totalAccepted\": \"3.1M\", \"totalSubmission\": \"6.3M\", \"totalAcceptedRaw\": 3085825, \"totalSubmissionRaw\": 6292405, \"acRate\": \"49.0%\"}",
        "similarQuestions": "[{\"title\": \"Insert Interval\", \"titleSlug\": \"insert-interval\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms\", \"titleSlug\": \"meeting-rooms\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms II\", \"titleSlug\": \"meeting-rooms-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Teemo Attacking\", \"titleSlug\": \"teemo-attacking\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Bold Tag in String\", \"titleSlug\": \"add-bold-tag-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Employee Free Time\", \"titleSlug\": \"employee-free-time\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Partition Labels\", \"titleSlug\": \"partition-labels\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Interval List Intersections\", \"titleSlug\": \"interval-list-intersections\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Amount of New Area Painted Each Day\", \"titleSlug\": \"amount-of-new-area-painted-each-day\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Substring of One Repeating Character\", \"titleSlug\": \"longest-substring-of-one-repeating-character\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Integers in Intervals\", \"titleSlug\": \"count-integers-in-intervals\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Divide Intervals Into Minimum Number of Groups\", \"titleSlug\": \"divide-intervals-into-minimum-number-of-groups\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Determine if Two Events Have Conflict\", \"titleSlug\": \"determine-if-two-events-have-conflict\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Ways to Group Overlapping Ranges\", \"titleSlug\": \"count-ways-to-group-overlapping-ranges\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Points That Intersect With Cars\", \"titleSlug\": \"points-that-intersect-with-cars\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Days Without Meetings\", \"titleSlug\": \"count-days-without-meetings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimize Connected Groups by Inserting Interval\", \"titleSlug\": \"minimize-connected-groups-by-inserting-interval\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/471861267\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Connected Components\n\n**Intuition**\n\nIf we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each *connected component* of the graph can be merged into a single interval.\n\n**Algorithm**\n\nWith the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is in, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a `Set`, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new `Interval` with `start` equal to the minimum start among them and `end` equal to the maximum end.\n\nThis algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly.\n\n![Components Example](../Figures/56/component.png)\n\nAlthough (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals:\n\n(1, 10), (15, 20)\n\n\n<iframe src=\"https://leetcode.com/playground/VH5daGtY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VH5daGtY\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n^2)$$\n\n    Building the graph costs $$O(V + E) = O(V) + O(E) = O(n) + O(n^2) = O(n^2)$$ time, as in the worst case all intervals are mutually overlapping. Traversing the graph has the same cost (although it might appear higher at first) because our `visited` set guarantees that each node will be visited exactly once. Finally, because each node is part of exactly one component, the merge step costs $$O(V) = O(n)$$ time. This all adds up as follows:\n\n    $$\n        O(n^2) + O(n^2) + O(n) = O(n^2)\n    $$\n\n* Space complexity : $$O(n^2)$$\n\n    As previously mentioned, in the worst case, all intervals are mutually overlapping, so there will be an edge for every pair of intervals. Therefore, the memory footprint is quadratic in the input size.\n\n<br/>\n\n---\n\n### Approach 2: Sorting\n\n**Intuition**\n\nIf we sort the intervals by their `start` value, then each set of intervals that can be merged will appear as a contiguous \"run\" in the sorted list.\n\n**Algorithm**\n\nFirst, we sort the list as described. Then, we insert the first interval into our `merged` list and continue considering each interval in turn as follows: If the current interval begins *after* the previous interval ends, then they do not overlap and we can append the current interval to `merged`. Otherwise, they do overlap, and we merge them by updating the `end` of the previous interval if it is less than the `end` of the current interval.\n\nA simple proof by contradiction shows that this algorithm always produces the correct answer. First, suppose that the algorithm at some point fails to merge two intervals that should be merged. This would imply that there exists some triple of indices $$i$$, $$j$$, and $$k$$ in a list of intervals $$\\text{ints}$$ such that $$i < j < k$$ and ($$\\text{ints[i]}$$, $$\\text{ints[k]}$$) can be merged, but neither ($$\\text{ints[i]}$$, $$\\text{ints[j]}$$) nor ($$\\text{ints[j]}$$, $$\\text{ints[k]}$$) can be merged. From this scenario follow several inequalities:\n\n$$\n\\begin{aligned}\n    \\text{ints[i].end} < \\text{ints[j].start} \\\\\n    \\text{ints[j].end} < \\text{ints[k].start} \\\\\n    \\text{ints[i].end} \\geq \\text{ints[k].start} \\\\\n\\end{aligned}\n$$\n\nWe can chain these inequalities (along with the following inequality, implied by the well-formedness of the intervals: $$\\text{ints[j].start} \\leq \\text{ints[j].end}$$) to demonstrate a contradiction:\n\n$$\n\\begin{aligned}\n    \\text{ints[i].end} < \\text{ints[j].start} \\leq \\text{ints[j].end} < \\text{ints[k].start} \\\\\n    \\text{ints[i].end} \\geq \\text{ints[k].start}\n\\end{aligned}\n$$\n\nTherefore, all mergeable intervals must occur in a contiguous run of the sorted list.\n\n![Sorting Example](../Figures/56/sort.png)\n\n\nConsider the example above, where the intervals are sorted, and then all mergeable intervals form contiguous blocks.\n\n<iframe src=\"https://leetcode.com/playground/95HUcjnF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"95HUcjnF\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n\\log{}n)$$\n\n    Other than the `sort` invocation, we do a simple linear scan of the list, so the runtime is dominated by the $$O(n\\log{}n)$$ complexity of sorting.\n\n* Space complexity : $$O(\\log N)$$ (or $$O(n)$$)\n\n    If we can sort `intervals` in place, we do not need more than constant additional space, although the sorting itself takes $$O(\\log n)$$ space. Otherwise, we must allocate linear space to store a copy of `intervals` and sort that."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-intervals/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "57",
        "questionFrontendId": "57",
        "title": "Insert Interval",
        "content": "<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 10971,
        "dislikes": 871,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 1407768, \"totalSubmissionRaw\": 3263177, \"acRate\": \"43.1%\"}",
        "similarQuestions": "[{\"title\": \"Merge Intervals\", \"titleSlug\": \"merge-intervals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Integers in Intervals\", \"titleSlug\": \"count-integers-in-intervals\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
          "Can you try merging the overlapping intervals while inserting the new interval?",
          "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
        ],
        "topicTags": [
          {
            "name": "Array"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a sorted list of non-overlapping `intervals` and a `newInterval`. The task is to insert the `newInterval` into the `intervals` while maintaining sorted order and ensuring no overlapping intervals. If there is any overlap, the overlapping intervals should be merged. In the end, return the intervals list with the addition of the new intervals.\n\nTwo key observations are crucial for this problem:\n1. The given intervals are already sorted in ascending order based on the start values.\n2. Initially, the intervals are non-overlapping, but inserting a new interval might lead to overlaps that need resolution by merging while maintaining sorted order.\n\nTo solve this problem, we break it into three cases when comparing the current interval with the new interval:\nCase 1. The current interval ends before the new interval starts.\nCase 2. There is an overlap, and the intervals need merging.\nCase 3. The current interval starts after the new interval ends.\n\nA visual representation below illustrates all three scenarios:\n\n![img](../Figures/57_re/1.png)\n\n\nNow let us consider the given problem description example with `intervals` and a `newInterval`:\n```\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\n```\n\nThe first interval starts at 1 and ends at 3, while the second interval starts at 6 and ends at 9. The goal is to insert the `newInterval` into the existing list of `intervals`, maintaining sorted order.\n\nUpon analysis, we observe that the `newInterval` [2, 5] overlaps with the first interval [1, 3] because 2 is less than 3. Now, since we know the intervals need to be merged, we must ensure the merged interval covers the entire overlapping region.\n\nTo achieve this, we take the maximum of the end of the first interval and the end of the new interval, as well as the minimum of the start of the first interval and the start of the new interval. Therefore, the merged interval becomes `[min(1, 2), max(3, 5)] = [1, 5]`.\n\nMoving on to the second interval [6, 9], its starting point (6) comes after the new interval's ending point (5). There is no overlap between them. Therefore, the second interval remains unchanged.\n\n\n| Original Intervals | New Interval | Action                     | Resulting Intervals |\n|-------------------- |--------------|---------------------------- |----------------------|\n|      [1,3]          |   [2,5]      | New interval overlaps with the first interval [1,3]. Merge intervals by taking [min(1, 2), max(3, 5)] = [1, 5]. |      [1,5]           |\n|      [6,9]          |              | No overlap with the new interval [2,5]. Interval remains unchanged. |      [6,9]           |\n\nIn conclusion, the final result is [[1, 5], [6, 9]], representing the intervals after inserting and merging the new interval [2, 5].\n\nIn a concrete business context, this problem may be presented as follows: Suppose we have an array representing video watch times, where each segment consists of the start and stop times of a user watching a video. The task is to calculate the total number of unique minutes watched across all the video segments. This is fundamentally the same question.\n\n> We recommend solving [Merge Intervals](https://leetcode.com/problems/merge-intervals/) problem before attempting this question, as it provides valuable insights into pattern recognition. This question is an extension of the Merge Intervals concept, building upon the same principles.\n\n---\n\n### Approach 1: Linear Search\n\n#### Intuition\n\nWe can do a linear search by iterating through all the intervals and checking which one of the three conditions the intervals fall under:\n\n1. **No Overlaps before Merging:**\n   - This occurs when the current interval ends before the new interval starts.\n\n2. **Overlapping and Merging:**\n   - This occurs when the starting point of the current interval is less than or equal to the ending point of the new interval (`newInterval[1]`), indicating an overlap. We can merge the current interval with the new interval by updating the start and end values of the new interval.\n\n3. **No Overlapping after Merging:**\n   - This occurs when the current interval starts after the new interval ends.\n\n##### 1. Identifying Non-Overlapping Intervals Before Merging:\nWe iterate through all intervals, checking whether the endpoint of the current interval (`intervals[i][1]`) is less than the starting point of the new interval (`newInterval[0]`). If this condition holds true, it indicates there is no overlap before merging, and we add the current interval to the result.\n\n##### 2. Identifying and Merging Overlapping Intervals:\nDuring the iteration, we identify overlap by comparing the endpoint of the new interval (`newInterval[1]`) with the starting point of the current interval (`intervals[i][0]`). When an overlap is detected, we merge the intervals by updating the start and end values of the new interval. The index (`i`) is then incremented to move to the next interval. After merging, the new interval is added to the result.\n\n##### 3. Identifying Non-Overlapping Intervals After Merging:\nAs we have already added the non-overlapping intervals before `newInterval` and merged overlapping ones, the remaining intervals after are guaranteed not to overlap with the newly merged interval. We simply add these remaining intervals to the result.\n\nThe following slideshow illustrates how the linear search algorithm is employed:\n\n!?!../Documents/57/57_LS.json:945,480!?!\n\n#### Algorithm\n\n- Initialize variables `n` and `i` to store the size of intervals and the current index, respectively, and an empty array `res` to store the result.\n- Case 1: No Overlap Before Insertion:\n    - Loop through intervals while `i` is less than `n` and the current interval's endpoint (`intervals[i][1]`) is less than the new interval's start point (`newInterval[0]`).\n    - Add the current interval from intervals to the `res` array.\n    - Increment `i` to move to the next interval.\n- Case 2: Overlap and Merge:\n    - Loop through intervals while `i` is less than `n` and the new interval's endpoint (`newInterval[1]`) is greater than or equal to the current interval's start point (`intervals[i][0]`).\n    - Update the newInterval's start point to the minimum of its current start and the current interval's start.\n    - Update the newInterval's endpoint to the maximum of its current end and the current interval's end.\n    - This essentially merges overlapping intervals into a single larger interval.\n    - Increment `i` to move to the next interval.\n- Add the updated `newInterval` to the `res` array, representing the merged interval.\n- Case 3: No overlap after insertion:\n    - Loop through the remaining intervals (from index `i`) and add them to the `res` array.\n        - This includes intervals that occur after the new interval and those that don't overlap, as they have already been correctly inserted in the previous iterations (previous two cases).\n- Return the `res` array containing all intervals with the new interval inserted correctly.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/XFeK8AcX/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XFeK8AcX\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number of intervals.\n\n* Time complexity: $O(N)$\n\n    We iterate through the intervals once, and each interval is considered and processed only once.\n\n* Space complexity: $O(1)$\n\n    We only use the result (`res`) array to store output, so this could be considered $O(1)$.\n\n---\n\n### Approach 2: Binary Search\n\n#### Intuition\n\nTo apply binary search to a problem, a crucial requirement is that the input should have a monotonically increasing or decreasing nature. In our given scenario, it is explicitly stated that the input is already sorted with respect to the start value, indicating a monotonically increasing order. Therefore, we can confidently consider applying binary search.\n\n##### 1. Finding the Insertion Position\nAs the intervals are sorted by start value, we perform a binary search comparing the starting point of the current interval (`intervals[mid][0]`) with the starting point of the new interval (`target`). If `intervals[mid][0]` is less than the target, it indicates that the insertion point should be to the right of the current position. Consequently, we update `left` to `mid + 1`. If it's greater, the insertion point should be to the left, so we update `right` to `mid - 1`. This process continues until `left` becomes greater than `right`, revealing the correct insertion position.\n\n##### 2. Handling Merging\n1. If `res` is empty or the end of the last interval in `res` is less than the starting point of the current interval, it indicates there is no overlap before merging. The current interval is directly added to `res` in such cases.\n2. If an overlap is detected, signifying the need for merging, the current interval is merged with the last interval in `res`. The end of the last interval in `res` is updated to the maximum of its current end and the end of the current interval.\n\nThe following slideshow illustrates how the binary search algorithm is employed:\n\n!?!../Documents/57/57_BS.json:930,315!?!\n\n#### Algorithm\n\n- If `intervals` is empty, it means there are no existing intervals, so we can simply return a array containing the `newInterval`.\n- Perform a binary search to find the correct position to insert the new interval in the `intervals` array. It updates the values of `left` and `right` based on the comparison of the target value with the first element of the interval at the middle index.\n    - Initialize the variables `target` with the starting point of `newInterval` (i.e., `newInterval[0]`), `left` with 0, and `right` with `n - 1` to define the search space in the `intervals` array.\n    - Perform a binary search by repeatedly dividing the search space in half until `left` is greater than `right`.\n    - Calculate the middle index `mid` as the average of `left` and `right`.\n    - If the start of the interval at index `mid` is less than the target value, update `left` to `mid + 1` to search the right half of the search space. Otherwise, update `right` to `mid - 1` to search the left half of the search space.\n    - The search updates `left` and `right` until they converge to the correct position. Repeat until `left` is greater than `right`.\n- Use `intervals.insert(intervals.begin() + left, newInterval)` to insert the `newInterval` at the correct position.\n- Initialize an empty array `res` to store the result.\n- Iterate through the sorted intervals.\n    - Check if `res` is empty or if the end of the last interval in `res` is less than the start of the current interval. If either condition is true, add the current interval to `res`.\n    - If there is an overlap, update the endpoint of the last interval in `res` to cover the current interval. This step ensures that non-overlapping intervals are added directly, and overlapping intervals are merged.\n- The final merged and inserted intervals are stored in the `res` array, which is then returned.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/Rg6hYgzg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Rg6hYgzg\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number of intervals.\n\n* Time complexity: $O(N)$\n\n    The binary search for finding the position to insert the `newInterval` has a time complexity of $O(\\log N)$. However, the insertion of the `newInterval` into the list may take $O(N)$ time in the worst case, as it could involve shifting elements within the list. Consequently, the overall time complexity is $O(N + \\log N)$, which simplifies to $O(N)$.\n\n* Space complexity: $O(N)$\n\n    We use the additional space to store the result (`res`) and perform calculations using `res,` so it does count towards the space complexity. In the worst case, the size of `res` will be proportional to the number of intervals in the input list."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/insert-interval/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "58",
        "questionFrontendId": "58",
        "title": "Length of Last Word",
        "content": "<p>Given a string <code>s</code> consisting of words and spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p>\n\n<p>A <strong>word</strong> is a maximal <span data-keyword=\"substring-nonempty\">substring</span> consisting of non-space characters only.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello World&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The last word is &quot;World&quot; with length 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;   fly me   to   the moon  &quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The last word is &quot;moon&quot; with length 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;luffy is still joyboy&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The last word is &quot;joyboy&quot; with length 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There will be at least one word in <code>s</code>.</li>\n</ul>\n",
        "likes": 5661,
        "dislikes": 321,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"4.8M\", \"totalAcceptedRaw\": 2662295, \"totalSubmissionRaw\": 4771433, \"acRate\": \"55.8%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/length-of-last-word/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "59",
        "questionFrontendId": "59",
        "title": "Spiral Matrix II",
        "content": "<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "likes": 6605,
        "dislikes": 272,
        "stats": "{\"totalAccepted\": \"673.7K\", \"totalSubmission\": \"921.1K\", \"totalAcceptedRaw\": 673709, \"totalSubmissionRaw\": 921111, \"acRate\": \"73.1%\"}",
        "similarQuestions": "[{\"title\": \"Spiral Matrix\", \"titleSlug\": \"spiral-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix III\", \"titleSlug\": \"spiral-matrix-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix IV\", \"titleSlug\": \"spiral-matrix-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nThere are various problems in spiral matrix series with some variations like [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) and [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/).\n\nIn order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given $$n$$.\nLet's discuss a few approaches.\n\n---\n### Approach 1: Traverse Layer by Layer in Spiral Form\n\n**Intuition**\n\nIf we try to build a pattern for a given $$n$$, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as  _layer_. We start traversing from the outer layer and move towards inner layers on every iteration.\n\n![img](../Figures/59/spiral_layers.png)\n\n**Algorithm**\n\nLet's devise an algorithm for the spiral traversal:\n\n-  We can observe that, for any given $$n$$, the total number of layers is given by :\n$$\\lfloor \\frac{n+1}{2} \\rfloor$$\nThis works for both even and odd $$n$$.\n\n_Example_\n\nFor $$n = 3$$, $$layers = 2$$\n\nFor $$n = 6$$, total $$layers = 3$$\n\n- Also, for each layer, we traverse in _at most_ 4 directions :\n\n\n![img](../Figures/59/spiral_traverse.png)\n\n\nIn every direction, either row or column remains constant and other parameter changes (increments/decrements).\n\n_Direction 1: From top left corner to top right corner._\n\nThe row remains constant as $$\\text{layer}$$ and column increments from $$\\text{layer}$$ to  $$n-\\text{layer}-1$$\n\n_Direction 2: From top right corner to the bottom right corner._\n\nThe column remains constant as $$n-layer-1$$ and row increments from\n$$\\text{layer}+1$$ to $$n-\\text{layer}$$.\n\n_Direction 3: From bottom right corner to bottom left corner._\n\nThe row remains constant as $$n-\\text{layer}-1$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}$$.\n\n_Direction 4: From bottom left corner to top left corner._\n\nThe column remains constant as $$\\text{layer}$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}+1$$.\n\nThis process repeats $$(n+1)/2$$ times until all layers are traversed.\n\n![img](../Figures/59/spiral_detailed.png)\n\n\n<iframe src=\"https://leetcode.com/playground/6UNnc6fM/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6UNnc6fM\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$.\n\n---\n### Approach 2: Optimized spiral traversal\n\n**Intuition**\n\nOur main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result.\n\n**Algorithm**\n\n- We have to walk in 4 directions forming a layer. We use an array $$dir$$ that stores the changes in $$x$$ and $$y$$ co-ordinates in each direction.\n\n_Example_\n\nIn left to right walk ( _direction #1_ ), $$x$$ co-ordinates remains same and $$y$$ increments ($$x = 0$$, $$y = 1$$).\n\nIn right to left walk ( _direction #3_ ), $$x$$ remains same and $$y$$ decrements ($$x = 0$$, $$y = -1$$).\n\nUsing this intuition, we pre-define an array $$dir$$ having $$x$$ and $$y$$ co-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach.\n\n- The $$\\text{row}$$ and $$col$$ variables represent the current $$x$$ and $$y$$ co-ordinates respectively. It updates based on the direction in which we are moving.\n\n_How do we know when we have to change the direction?_\n\nWhen we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction.\n\nLet $$d$$ be the current direction index. We go to next direction in array $$dir$$ using $$(d+ 1) \\% 4$$. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 .\n\n> It must be noted that we use `floorMod` in Java instead of modulo $$\\%$$ to handle mod of negative numbers. This is required because row and column values might go negative and using $$\\%$$ won't give desired results in such cases.  \n\n<iframe src=\"https://leetcode.com/playground/QYtw7GFR/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"QYtw7GFR\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/spiral-matrix-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "60",
        "questionFrontendId": "60",
        "title": "Permutation Sequence",
        "content": "<p>The set <code>[1, 2, 3, ...,&nbsp;n]</code> contains a total of <code>n!</code> unique permutations.</p>\n\n<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>\n\n<ol>\n\t<li><code>&quot;123&quot;</code></li>\n\t<li><code>&quot;132&quot;</code></li>\n\t<li><code>&quot;213&quot;</code></li>\n\t<li><code>&quot;231&quot;</code></li>\n\t<li><code>&quot;312&quot;</code></li>\n\t<li><code>&quot;321&quot;</code></li>\n</ol>\n\n<p>Given <code>n</code> and <code>k</code>, return the <code>k<sup>th</sup></code> permutation sequence.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 3\n<strong>Output:</strong> \"213\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 4, k = 9\n<strong>Output:</strong> \"2314\"\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> \"123\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n",
        "likes": 6921,
        "dislikes": 491,
        "stats": "{\"totalAccepted\": \"466.9K\", \"totalSubmission\": \"944.1K\", \"totalAcceptedRaw\": 466851, \"totalSubmissionRaw\": 944141, \"acRate\": \"49.4%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/permutation-sequence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "61",
        "questionFrontendId": "61",
        "title": "Rotate List",
        "content": "<p>Given the <code>head</code> of a linked&nbsp;list, rotate the list to the right by <code>k</code> places.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px; height: 191px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [4,5,1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" />\n<pre>\n<strong>Input:</strong> head = [0,1,2], k = 4\n<strong>Output:</strong> [2,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 500]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 10326,
        "dislikes": 1494,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 1243837, \"totalSubmissionRaw\": 3139956, \"acRate\": \"39.6%\"}",
        "similarQuestions": "[{\"title\": \"Rotate Array\", \"titleSlug\": \"rotate-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Split Linked List in Parts\", \"titleSlug\": \"split-linked-list-in-parts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rotate-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "62",
        "questionFrontendId": "62",
        "title": "Unique Paths",
        "content": "<p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" style=\"width: 400px; height: 183px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 7\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right\n3. Down -&gt; Right -&gt; Down\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n",
        "likes": 17358,
        "dislikes": 464,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 2264008, \"totalSubmissionRaw\": 3454000, \"acRate\": \"65.5%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths II\", \"titleSlug\": \"unique-paths-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Sum\", \"titleSlug\": \"minimum-path-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Dungeon Game\", \"titleSlug\": \"dungeon-game\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost Homecoming of a Robot in a Grid\", \"titleSlug\": \"minimum-cost-homecoming-of-a-robot-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Ways to Reach a Position After Exactly k Steps\", \"titleSlug\": \"number-of-ways-to-reach-a-position-after-exactly-k-steps\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Combinatorics"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-paths/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "63",
        "questionFrontendId": "63",
        "title": "Unique Paths II",
        "content": "<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>\n\n<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == obstacleGrid.length</code></li>\n\t<li><code>n == obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "likes": 9145,
        "dislikes": 535,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1171676, \"totalSubmissionRaw\": 2731416, \"acRate\": \"42.9%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths\", \"titleSlug\": \"unique-paths\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Unique Paths III\", \"titleSlug\": \"unique-paths-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use dynamic programming since, from each cell, you can move to the right or down.",
          "assume dp[i][j] is the number of unique paths to reach (i, j). dp[i][j] = dp[i][j -1] + dp[i - 1][j]. Be careful when you encounter an obstacle. set its value in dp to 0."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-paths-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "64",
        "questionFrontendId": "64",
        "title": "Minimum Path Sum",
        "content": "<p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>\n\n<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>\n</ul>\n",
        "likes": 12948,
        "dislikes": 178,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1464942, \"totalSubmissionRaw\": 2216625, \"acRate\": \"66.1%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths\", \"titleSlug\": \"unique-paths\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Dungeon Game\", \"titleSlug\": \"dungeon-game\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Cherry Pickup\", \"titleSlug\": \"cherry-pickup\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Points with Cost\", \"titleSlug\": \"maximum-number-of-points-with-cost\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost Homecoming of a Robot in a Grid\", \"titleSlug\": \"minimum-cost-homecoming-of-a-robot-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if There is a Path With Equal Number of 0's And 1's\", \"titleSlug\": \"check-if-there-is-a-path-with-equal-number-of-0s-and-1s\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost of a Path With Special Roads\", \"titleSlug\": \"minimum-cost-of-a-path-with-special-roads\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-path-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "65",
        "questionFrontendId": "65",
        "title": "Valid Number",
        "content": "<p>Given a string <code>s</code>, return whether <code>s</code> is a <strong>valid number</strong>.<br />\n<br />\nFor example, all the following are valid numbers: <code>&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;</code>, while the following are not valid numbers: <code>&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;</code>.</p>\n\n<p>Formally, a&nbsp;<strong>valid number</strong> is defined using one of the following definitions:</p>\n\n<ol>\n\t<li>An <strong>integer number</strong> followed by an <strong>optional exponent</strong>.</li>\n\t<li>A <strong>decimal number</strong> followed by an <strong>optional exponent</strong>.</li>\n</ol>\n\n<p>An <strong>integer number</strong> is defined with an <strong>optional sign</strong> <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> followed by <strong>digits</strong>.</p>\n\n<p>A <strong>decimal number</strong> is defined with an <strong>optional sign</strong> <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> followed by one of the following definitions:</p>\n\n<ol>\n\t<li><strong>Digits</strong> followed by a <strong>dot</strong> <code>&#39;.&#39;</code>.</li>\n\t<li><strong>Digits</strong> followed by a <strong>dot</strong> <code>&#39;.&#39;</code> followed by <strong>digits</strong>.</li>\n\t<li>A <strong>dot</strong> <code>&#39;.&#39;</code> followed by <strong>digits</strong>.</li>\n</ol>\n\n<p>An <strong>exponent</strong> is defined with an <strong>exponent notation</strong> <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code> followed by an <strong>integer number</strong>.</p>\n\n<p>The <strong>digits</strong> are defined as one or more digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;0&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;e&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;.&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.</li>\n</ul>\n",
        "likes": 1372,
        "dislikes": 2138,
        "stats": "{\"totalAccepted\": \"439.2K\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 439180, \"totalSubmissionRaw\": 2064180, \"acRate\": \"21.3%\"}",
        "similarQuestions": "[{\"title\": \"String to Integer (atoi)\", \"titleSlug\": \"string-to-integer-atoi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/valid-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "66",
        "questionFrontendId": "66",
        "title": "Plus One",
        "content": "<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>i<sup>th</sup></code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>&#39;s.</p>\n\n<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1,2,3]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong> The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [4,3,2,1]\n<strong>Output:</strong> [4,3,2,2]\n<strong>Explanation:</strong> The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [9]\n<strong>Output:</strong> [1,0]\n<strong>Explanation:</strong> The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li><code>digits</code> does not contain any leading <code>0</code>&#39;s.</li>\n</ul>\n",
        "likes": 10166,
        "dislikes": 5483,
        "stats": "{\"totalAccepted\": \"2.8M\", \"totalSubmission\": \"6M\", \"totalAcceptedRaw\": 2844586, \"totalSubmissionRaw\": 6021551, \"acRate\": \"47.2%\"}",
        "similarQuestions": "[{\"title\": \"Multiply Strings\", \"titleSlug\": \"multiply-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Plus One Linked List\", \"titleSlug\": \"plus-one-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add to Array-Form of Integer\", \"titleSlug\": \"add-to-array-form-of-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Reduce an Integer to 0\", \"titleSlug\": \"minimum-operations-to-reduce-an-integer-to-0\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/plus-one/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "67",
        "questionFrontendId": "67",
        "title": "Add Binary",
        "content": "<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> a = \"11\", b = \"1\"\n<strong>Output:</strong> \"100\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> a = \"1010\", b = \"1011\"\n<strong>Output:</strong> \"10101\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> and <code>b</code> consist&nbsp;only of <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code> characters.</li>\n\t<li>Each string does not contain leading zeros except for the zero itself.</li>\n</ul>\n",
        "likes": 9851,
        "dislikes": 1037,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 1812071, \"totalSubmissionRaw\": 3271977, \"acRate\": \"55.4%\"}",
        "similarQuestions": "[{\"title\": \"Add Two Numbers\", \"titleSlug\": \"add-two-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Multiply Strings\", \"titleSlug\": \"multiply-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Plus One\", \"titleSlug\": \"plus-one\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add to Array-Form of Integer\", \"titleSlug\": \"add-to-array-form-of-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/add-binary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "68",
        "questionFrontendId": "68",
        "title": "Text Justification",
        "content": "<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n",
        "likes": 4081,
        "dislikes": 5056,
        "stats": "{\"totalAccepted\": \"527.2K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 527221, \"totalSubmissionRaw\": 1109390, \"acRate\": \"47.5%\"}",
        "similarQuestions": "[{\"title\": \"Rearrange Spaces Between Words\", \"titleSlug\": \"rearrange-spaces-between-words\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Divide a String Into Groups of Size k\", \"titleSlug\": \"divide-a-string-into-groups-of-size-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Split Message Based on Limit\", \"titleSlug\": \"split-message-based-on-limit\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/text-justification/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "69",
        "questionFrontendId": "69",
        "title": "Sqrt(x)",
        "content": "<p>Given a non-negative integer <code>x</code>, return <em>the square root of </em><code>x</code><em> rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>\n\n<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>\n\n<ul>\n\t<li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The square root of 4 is 2, so we return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 8\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 8785,
        "dislikes": 4572,
        "stats": "{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"6.2M\", \"totalAcceptedRaw\": 2498695, \"totalSubmissionRaw\": 6221285, \"acRate\": \"40.2%\"}",
        "similarQuestions": "[{\"title\": \"Pow(x, n)\", \"titleSlug\": \"powx-n\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Perfect Square\", \"titleSlug\": \"valid-perfect-square\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Try exploring all integers. (Credits: @annujoshi)",
          "Use the sorted property of integers to reduced the search space. (Credits: @annujoshi)"
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/sqrtx/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "70",
        "questionFrontendId": "70",
        "title": "Climbing Stairs",
        "content": "<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>\n\n<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n",
        "likes": 22999,
        "dislikes": 948,
        "stats": "{\"totalAccepted\": \"4.1M\", \"totalSubmission\": \"7.7M\", \"totalAcceptedRaw\": 4096923, \"totalSubmissionRaw\": 7669892, \"acRate\": \"53.4%\"}",
        "similarQuestions": "[{\"title\": \"Min Cost Climbing Stairs\", \"titleSlug\": \"min-cost-climbing-stairs\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Fibonacci Number\", \"titleSlug\": \"fibonacci-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"N-th Tribonacci Number\", \"titleSlug\": \"n-th-tribonacci-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Rounds to Complete All Tasks\", \"titleSlug\": \"minimum-rounds-to-complete-all-tasks\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Number of Ways to Place Houses\", \"titleSlug\": \"count-number-of-ways-to-place-houses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Ways to Reach a Position After Exactly k Steps\", \"titleSlug\": \"number-of-ways-to-reach-a-position-after-exactly-k-steps\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Ways To Build Good Strings\", \"titleSlug\": \"count-ways-to-build-good-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Frog Jump II\", \"titleSlug\": \"frog-jump-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Number of Ways to Reach the K-th Stair\", \"titleSlug\": \"find-number-of-ways-to-reach-the-k-th-stair\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"The Number of Ways to Make the Sum\", \"titleSlug\": \"the-number-of-ways-to-make-the-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Memoization"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/climbing-stairs/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "71",
        "questionFrontendId": "71",
        "title": "Simplify Path",
        "content": "<p>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code>&#39;/&#39;</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p>\n\n<p>The <em>rules</em> of a Unix-style file system are as follows:</p>\n\n<ul>\n\t<li>A single period <code>&#39;.&#39;</code> represents the current directory.</li>\n\t<li>A double period <code>&#39;..&#39;</code> represents the previous/parent directory.</li>\n\t<li>Multiple consecutive slashes such as <code>&#39;//&#39;</code> and <code>&#39;///&#39;</code> are treated as a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file </strong><strong>name</strong>. For example, <code>&#39;...&#39; </code>and <code>&#39;....&#39;</code> are valid directory or file names.</li>\n</ul>\n\n<p>The simplified canonical path should follow these <em>rules</em>:</p>\n\n<ul>\n\t<li>The path must start with a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Directories within the path must be separated by exactly one slash <code>&#39;/&#39;</code>.</li>\n\t<li>The path must not end with a slash <code>&#39;/&#39;</code>, unless it is the root directory.</li>\n\t<li>The path must not have any single or double periods (<code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>) used to denote current or parent directories.</li>\n</ul>\n\n<p>Return the <strong>simplified canonical path</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home/&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The trailing slash should be removed.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home//foo/&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home/foo&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Multiple consecutive slashes are replaced by a single one.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home/user/Documents/../Pictures&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home/user/Pictures&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>A double period <code>&quot;..&quot;</code> refers to the directory up a level (the parent directory).</p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/../&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Going one level up from the root directory is not possible.</p>\n</div>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/.../a/../b/c/../d/./&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/.../b/d&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><code>&quot;...&quot;</code> is a valid name for a directory in this problem.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> consists of English letters, digits, period <code>&#39;.&#39;</code>, slash <code>&#39;/&#39;</code> or <code>&#39;_&#39;</code>.</li>\n\t<li><code>path</code> is a valid absolute Unix path.</li>\n</ul>\n",
        "likes": 6014,
        "dislikes": 1351,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1036936, \"totalSubmissionRaw\": 2201818, \"acRate\": \"47.1%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/simplify-path/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "72",
        "questionFrontendId": "72",
        "title": "Edit Distance",
        "content": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>\n\n<p>You have the following three operations permitted on a word:</p>\n\n<ul>\n\t<li>Insert a character</li>\n\t<li>Delete a character</li>\n\t<li>Replace a character</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nhorse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -&gt; rose (remove &#39;r&#39;)\nrose -&gt; ros (remove &#39;e&#39;)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> \nintention -&gt; inention (remove &#39;t&#39;)\ninention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -&gt; execution (insert &#39;u&#39;)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "likes": 15515,
        "dislikes": 268,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1114329, \"totalSubmissionRaw\": 1907970, \"acRate\": \"58.4%\"}",
        "similarQuestions": "[{\"title\": \"One Edit Distance\", \"titleSlug\": \"one-edit-distance\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete Operation for Two Strings\", \"titleSlug\": \"delete-operation-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum ASCII Delete Sum for Two Strings\", \"titleSlug\": \"minimum-ascii-delete-sum-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Uncrossed Lines\", \"titleSlug\": \"uncrossed-lines\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum White Tiles After Covering With Carpets\", \"titleSlug\": \"minimum-white-tiles-after-covering-with-carpets\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Palindrome After Substring Concatenation II\", \"titleSlug\": \"longest-palindrome-after-substring-concatenation-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/edit-distance/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "73",
        "questionFrontendId": "73",
        "title": "Set Matrix Zeroes",
        "content": "<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>&#39;s.</p>\n\n<p>You must do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n<strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[0].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li>\n\t<li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li>\n\t<li>Could you devise a constant space solution?</li>\n</ul>\n",
        "likes": 15480,
        "dislikes": 787,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.2M\", \"totalAcceptedRaw\": 1892833, \"totalSubmissionRaw\": 3193208, \"acRate\": \"59.3%\"}",
        "similarQuestions": "[{\"title\": \"Game of Life\", \"titleSlug\": \"game-of-life\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Laser Beams in a Bank\", \"titleSlug\": \"number-of-laser-beams-in-a-bank\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Remove Adjacent Ones in Matrix\", \"titleSlug\": \"minimum-operations-to-remove-adjacent-ones-in-matrix\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Remove All Ones With Row and Column Flips II\", \"titleSlug\": \"remove-all-ones-with-row-and-column-flips-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If any cell of the matrix has a zero we can record its row and column number using additional memory.\r\nBut if you don't want to use extra memory then you can manipulate the array instead. i.e. simulating exactly what the question says.",
          "Setting cell values to zero on the fly while iterating might lead to discrepancies. What if you use some other integer value as your marker?\r\nThere is still a better approach for this problem with 0(1) space.",
          "We could have used 2 sets to keep a record of rows/columns which need to be set to zero. But for an O(1) space solution, you can use one of the rows and and one of the columns to keep track of this information.",
          "We can use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/set-matrix-zeroes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "74",
        "questionFrontendId": "74",
        "title": "Search a 2D Matrix",
        "content": "<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>\n\n<ul>\n\t<li>Each row is sorted in non-decreasing order.</li>\n\t<li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n\n<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 16671,
        "dislikes": 446,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"4.4M\", \"totalAcceptedRaw\": 2276491, \"totalSubmissionRaw\": 4381804, \"acRate\": \"52.0%\"}",
        "similarQuestions": "[{\"title\": \"Search a 2D Matrix II\", \"titleSlug\": \"search-a-2d-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Split Message Based on Limit\", \"titleSlug\": \"split-message-based-on-limit\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/search-a-2d-matrix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "75",
        "questionFrontendId": "75",
        "title": "Sort Colors",
        "content": "<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> </strong>so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>\n\n<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>\n\n<p>You must solve this problem without using the library&#39;s sort function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,2,1,1,0]\n<strong>Output:</strong> [0,0,1,1,2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,1]\n<strong>Output:</strong> [0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?</p>\n",
        "likes": 19657,
        "dislikes": 698,
        "stats": "{\"totalAccepted\": \"2.8M\", \"totalSubmission\": \"4.1M\", \"totalAcceptedRaw\": 2753942, \"totalSubmissionRaw\": 4131717, \"acRate\": \"66.7%\"}",
        "similarQuestions": "[{\"title\": \"Sort List\", \"titleSlug\": \"sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Wiggle Sort\", \"titleSlug\": \"wiggle-sort\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Wiggle Sort II\", \"titleSlug\": \"wiggle-sort-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "A rather straight forward solution is a two-pass algorithm using counting sort.",
          "Iterate the array counting number of 0's, 1's, and 2's.",
          "Overwrite array with the total number of 0's, then 1's and followed by 2's."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sort-colors/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "76",
        "questionFrontendId": "76",
        "title": "Minimum Window Substring",
        "content": "<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n",
        "likes": 18753,
        "dislikes": 778,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"3.8M\", \"totalAcceptedRaw\": 1689380, \"totalSubmissionRaw\": 3760710, \"acRate\": \"44.9%\"}",
        "similarQuestions": "[{\"title\": \"Substring with Concatenation of All Words\", \"titleSlug\": \"substring-with-concatenation-of-all-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Size Subarray Sum\", \"titleSlug\": \"minimum-size-subarray-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Permutation in String\", \"titleSlug\": \"permutation-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Range Covering Elements from K Lists\", \"titleSlug\": \"smallest-range-covering-elements-from-k-lists\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Window Subsequence\", \"titleSlug\": \"minimum-window-subsequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Substrings That Can Be Rearranged to Contain a String II\", \"titleSlug\": \"count-substrings-that-can-be-rearranged-to-contain-a-string-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Substrings That Can Be Rearranged to Contain a String I\", \"titleSlug\": \"count-substrings-that-can-be-rearranged-to-contain-a-string-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use two pointers to create a window of letters in s, which would have all the characters from t.",
          "Expand the right pointer until all the characters of t are covered.",
          "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
          "Continue expanding the right and left pointers until you reach the end of s."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-window-substring/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "77",
        "questionFrontendId": "77",
        "title": "Combinations",
        "content": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 2\n<strong>Output:</strong> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<strong>Explanation:</strong> There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> There is 1 choose 1 = 1 total combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "likes": 8524,
        "dislikes": 235,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 1092389, \"totalSubmissionRaw\": 1506427, \"acRate\": \"72.5%\"}",
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/combinations/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "78",
        "questionFrontendId": "78",
        "title": "Subsets",
        "content": "<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 18048,
        "dislikes": 302,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"3M\", \"totalAcceptedRaw\": 2421927, \"totalSubmissionRaw\": 3009147, \"acRate\": \"80.5%\"}",
        "similarQuestions": "[{\"title\": \"Subsets II\", \"titleSlug\": \"subsets-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Generalized Abbreviation\", \"titleSlug\": \"generalized-abbreviation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Letter Case Permutation\", \"titleSlug\": \"letter-case-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Array Given Subset Sums\", \"titleSlug\": \"find-array-given-subset-sums\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Number of Maximum Bitwise-OR Subsets\", \"titleSlug\": \"count-number-of-maximum-bitwise-or-subsets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Overview: Solution Pattern\n\nLet us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them.\n\nFirst, their solution space is often quite large:\n\n- [Permutations](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n): $$N!$$. \n\n- [Combinations](https://en.wikipedia.org/wiki/Combination#Number_of_k-combinations): $$C_N^k = \\frac{N!}{(N - k)! k!}$$\n\n- Subsets: $$2^N$$, since each element could be absent or present. \n\nGiven their exponential solution space, it is tricky to ensure that the generated solutions are _**complete**_ and _**non-redundant**_. It is essential to have a clear and easy-to-reason strategy.\n\nThere are generally three strategies to do it:\n\n- Iterative\n\n- Recursion/Backtracking\n\n- Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets.\n\nAs one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing.\n\nBesides, as a bonus, it generates lexicographically sorted output for the sorted inputs.\n\n\n---\n### Approach 1: Cascading\n\n#### Intuition\n\nLet's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones. \n\n![diff](../Figures/78/recursion.png)\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/GfSoguWr/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"GfSoguWr\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list. \n    \n* Space complexity: $$\\mathcal{O}(N \\times 2^N)$$. This is exactly the number of solutions for subsets multiplied by the number $$N$$ of elements to keep for each subset.  \n    - For a given number, it could be present or absent (_i.e._ binary choice) in a subset solution. As a result, for $$N$$ numbers, we would have in total $$2^N$$ choices (solutions). \n<br />\n<br />\n\n\n---\n### Approach 2: Backtracking\n\n#### Algorithm\n\n>Power set is all possible combinations of all possible _lengths_, from 0 to n.\n\nGiven the definition, the problem can also be interpreted as finding the _power set_ from a sequence.\n\nSo, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of _backtracking_ technique.\n\n![diff](../Figures/78/combinations.png)\n\n>[Backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be _not_ a solution (or at least not the _last_ one), the backtracking algorithm discards it by making some changes on the previous step, *i.e.* _backtracks_ and then tries again.\n\n![diff](../Figures/78/backtracking.png)\n\n#### Algorithm\n\nWe define a backtrack function named `backtrack(first, curr)` that takes the index of the first element to add and a current combination as arguments.\n\n- If the current combination is done, we add the combination to the final output.\n\n- Otherwise, we iterate over the indexes `i` from `first` to the length of the entire sequence `n`.\n\n    - Add integer `nums[i]` into the current combination `curr`.\n\n    - Proceed to add more integers into the combination: `backtrack(i + 1, curr)`.\n\n    - Backtrack by removing `nums[i]` from `curr`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/X6GCLJ3t/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"X6GCLJ3t\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list.\n \n* Space complexity: $$\\mathcal{O}(N)$$. We are using $$O(N)$$ space to maintain `curr`, and are modifying `curr` in-place with backtracking. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored.\n\n\n---\n### Approach 3: Lexicographic (Binary Sorted) Subsets\n\n#### Intuition\n\nThe idea of this solution is originated from [Donald E. Knuth](https://www-cs-faculty.stanford.edu/~knuth/taocp.html).\n\n>The idea is that we map each subset to a bitmask of length n,\nwhere `1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n![diff](../Figures/78/bitmask4.png)\n\nFor instance, the bitmask `0..00` (all zeros) corresponds to an empty subset, \nand the bitmask `1..11` (all ones) corresponds to the entire input array `nums`. \n\nHence to solve the initial problem, we just need to generate n bitmasks\nfrom `0..00` to `1..11`. \n\nIt might seem simple at first glance to generate binary numbers, but \nthe real problem here is how to deal with \n[zero left padding](https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding),\nbecause one has to generate bitmasks of fixed length, _i.e._ `001` and not just `1`.\nFor that one could use standard bit manipulation trick:\n\n<iframe src=\"https://leetcode.com/playground/PtHUHaeY/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"PtHUHaeY\"></iframe>\n\nor keep it simple stupid and shift iteration limits:\n\n<iframe src=\"https://leetcode.com/playground/4XWEGcWd/shared\" frameBorder=\"0\" width=\"100%\" height=\"123\" name=\"4XWEGcWd\"></iframe>\n\n#### Algorithm\n\n- Generate all possible binary bitmasks of length n.\n\n- Map a subset to each bitmask: \n`1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n- Return output list.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/DwHHy2yt/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"DwHHy2yt\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets \nand then copy them into output list.\n    \n* Space complexity: $$\\mathcal{O}(N)$$ to store the bitset\nof length $$N$$. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/subsets/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "79",
        "questionFrontendId": "79",
        "title": "Word Search",
        "content": "<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>\n\n<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>\n",
        "likes": 16608,
        "dislikes": 706,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"4.5M\", \"totalAcceptedRaw\": 2033451, \"totalSubmissionRaw\": 4533425, \"acRate\": \"44.9%\"}",
        "similarQuestions": "[{\"title\": \"Word Search II\", \"titleSlug\": \"word-search-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-search/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "80",
        "questionFrontendId": "80",
        "title": "Remove Duplicates from Sorted Array II",
        "content": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove some duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each unique element appears <strong>at most twice</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>\n\n<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code>&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;<code>k</code>&nbsp;elements.</p>\n\n<p>Return <code>k</code><em> after placing the final result in the first </em><code>k</code><em> slots of </em><code>nums</code>.</p>\n\n<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,2,2,3]\n<strong>Output:</strong> 5, nums = [1,1,2,2,3,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,1,1,2,3,3]\n<strong>Output:</strong> 7, nums = [0,0,1,1,2,3,3,_,_]\n<strong>Explanation:</strong> Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "likes": 7559,
        "dislikes": 1435,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 1500407, \"totalSubmissionRaw\": 2400288, \"acRate\": \"62.5%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted Array\", \"titleSlug\": \"remove-duplicates-from-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "81",
        "questionFrontendId": "81",
        "title": "Search in Rotated Sorted Array II",
        "content": "<p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</p>\n\n<p>Before being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <code>true</code><em> if </em><code>target</code><em> is in </em><code>nums</code><em>, or </em><code>false</code><em> if it is not in </em><code>nums</code><em>.</em></p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 0\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 3\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is guaranteed to be rotated at some pivot.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"/problems/search-in-rotated-sorted-array/description/\" target=\"_blank\">Search in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n",
        "likes": 8944,
        "dislikes": 1084,
        "stats": "{\"totalAccepted\": \"935.2K\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 935152, \"totalSubmissionRaw\": 2417029, \"acRate\": \"38.7%\"}",
        "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array\", \"titleSlug\": \"search-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "82",
        "questionFrontendId": "82",
        "title": "Remove Duplicates from Sorted List II",
        "content": "<p>Given the <code>head</code> of a sorted linked list, <em>delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,3,4,4,5]\n<strong>Output:</strong> [1,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"width: 500px; height: 205px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,1,2,3]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>\n</ul>\n",
        "likes": 9180,
        "dislikes": 261,
        "stats": "{\"totalAccepted\": \"895K\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 895006, \"totalSubmissionRaw\": 1808615, \"acRate\": \"49.5%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted List\", \"titleSlug\": \"remove-duplicates-from-sorted-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Duplicates From an Unsorted Linked List\", \"titleSlug\": \"remove-duplicates-from-an-unsorted-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "83",
        "questionFrontendId": "83",
        "title": "Remove Duplicates from Sorted List",
        "content": "<p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list1.jpg\" style=\"width: 302px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,2,3,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>\n</ul>\n",
        "likes": 9185,
        "dislikes": 335,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 1886961, \"totalSubmissionRaw\": 3459294, \"acRate\": \"54.5%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted List II\", \"titleSlug\": \"remove-duplicates-from-sorted-list-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Remove Duplicates From an Unsorted Linked List\", \"titleSlug\": \"remove-duplicates-from-an-unsorted-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "84",
        "questionFrontendId": "84",
        "title": "Largest Rectangle in Histogram",
        "content": "<p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" style=\"width: 522px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,1,5,6,2,3]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" style=\"width: 202px; height: 362px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 18107,
        "dislikes": 322,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1149319, \"totalSubmissionRaw\": 2452556, \"acRate\": \"46.9%\"}",
        "similarQuestions": "[{\"title\": \"Maximal Rectangle\", \"titleSlug\": \"maximal-rectangle\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Score of a Good Subarray\", \"titleSlug\": \"maximum-score-of-a-good-subarray\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "85",
        "questionFrontendId": "85",
        "title": "Maximal Rectangle",
        "content": "<p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[i].length</code></li>\n\t<li><code>1 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "likes": 11044,
        "dislikes": 196,
        "stats": "{\"totalAccepted\": \"578.1K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 578097, \"totalSubmissionRaw\": 1087746, \"acRate\": \"53.1%\"}",
        "similarQuestions": "[{\"title\": \"Largest Rectangle in Histogram\", \"titleSlug\": \"largest-rectangle-in-histogram\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximal Square\", \"titleSlug\": \"maximal-square\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Sorted Submatrices With Maximum Element at Most K\", \"titleSlug\": \"find-sorted-submatrices-with-maximum-element-at-most-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximal-rectangle/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "86",
        "questionFrontendId": "86",
        "title": "Partition List",
        "content": "<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>\n\n<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3\n<strong>Output:</strong> [1,2,2,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [2,1], x = 2\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n",
        "likes": 7633,
        "dislikes": 931,
        "stats": "{\"totalAccepted\": \"748.7K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 748651, \"totalSubmissionRaw\": 1278290, \"acRate\": \"58.6%\"}",
        "similarQuestions": "[{\"title\": \"Partition Array According to Given Pivot\", \"titleSlug\": \"partition-array-according-to-given-pivot\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/partition-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "87",
        "questionFrontendId": "87",
        "title": "Scramble String",
        "content": "<p>We can scramble a string s to get a string t using the following algorithm:</p>\n\n<ol>\n\t<li>If the length of the string is 1, stop.</li>\n\t<li>If the length of the string is &gt; 1, do the following:\n\t<ul>\n\t\t<li>Split the string into two non-empty substrings at a random index, i.e., if the string is <code>s</code>, divide it to <code>x</code> and <code>y</code> where <code>s = x + y</code>.</li>\n\t\t<li><strong>Randomly</strong>&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, <code>s</code> may become <code>s = x + y</code> or <code>s = y + x</code>.</li>\n\t\t<li>Apply step 1 recursively on each of the two substrings <code>x</code> and <code>y</code>.</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>Given two strings <code>s1</code> and <code>s2</code> of <strong>the same length</strong>, return <code>true</code> if <code>s2</code> is a scrambled string of <code>s1</code>, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible scenario applied on s1 is:\n&quot;great&quot; --&gt; &quot;gr/eat&quot; // divide at random index.\n&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // random decision is not to swap the two substrings and keep them in order.\n&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // apply the same algorithm recursively on both substrings. divide at random index each of them.\n&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // random decision was to swap the first substring and to keep the second substring in the same order.\n&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // again apply the algorithm recursively, divide &quot;at&quot; to &quot;a/t&quot;.\n&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is &quot;rgeat&quot; which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;a&quot;, s2 = &quot;a&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 &lt;= s1.length &lt;= 30</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "likes": 3453,
        "dislikes": 1289,
        "stats": "{\"totalAccepted\": \"262.1K\", \"totalSubmission\": \"626.3K\", \"totalAcceptedRaw\": 262126, \"totalSubmissionRaw\": 626313, \"acRate\": \"41.9%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Dynamic Programming\n\n#### Intuition\n\nWe have a recursive definition of scrambling a string `s`. First, we divide `s` into `x` and `y`. Then we either keep `s` as `x + y` or swap them and get `y + x`. After that, we scramble `x` and `y` independently. Let `x'` denote the scrambled `x` and `y'` denote the scrambled `y`. `s` will eventually become `x' + y'` or `y' + x'`.\n\n![split](../Figures/87/diagram2.drawio.png)\n\nHow do we check whether a given string `t` is a scrambled string of `s`? First, we choose an index and cut `s` into `x` and `y` (`s = x + y`). Then, we see if we can cut `t` into `x'` and `y'` (`t = x' + y'` if we do not swap or `t = y' + x'` if we do). Since verifying that `x'` is a scrambled `x` and `y'` is scrambled `y` are smaller subproblems, we will solve the problem using dynamic programming.\n\nWe have two strings `s1` and `s2`.\n\nFor each given dp state, we need 3 variables: `length`, `i`, and `j`.\n\nEach state will focus on two substrings. The first one will be a substring of `s1`, starting at index `i` with length equal to `length` - let's call this substring `s`. The second one will be a substring of `s2`, starting at index `j` with `length` - let's call this substring `t`.\n\nLet `dp[length][i][j]` be a boolean representing whether `t` is a scrambled version of `s`.\n\nThe base case, as defined by the problem is when `length = 1`. Here we do not have to split strings into smaller ones, so we can easily compare the corresponding characters: `dp[1][i][j]` is `true` when `s1[i]` equals `s2[j]`, and `false` otherwise.\n\nNow we need to write down the transitions of `dp`. We will use the following image as an example during the explanations.\n\n![split](../Figures/87/diagram.drawio.png)\n\nAt each state, we need to perform a split on `s1`. We will consider all possible splits. If we are currently considering a substring with a length of `length`, then we could perform a split at any index `newLength`, where `0 < newLength < length`. (Here, `newLength` represents the length of the left string after the split). A split gives us two new strings:\n\n- A substring of `s1` starting at index `i` and ending with index `i + newLength - 1`. This string has a length of `newLength` (Blue in the picture)\n\n- A substring of `s1` starting at index `i + newLength` and ending at index `i + length - 1`. This string has a length of `length - newLength`. (Yellow in the picture)\n\nFor each split, we have two cases:\n\n* Do not swap the blue and yellow parts. The corresponding substrings of `s2` must be scrambled versions of the substrings we just created by splitting `s1`. This means both `dp[newLength][i][j]` (representing the blue parts) and `dp[length - newLength][i + newLength][j + newLength]` (representing the yellow parts) must be true.\n* Swap the blue and yellow parts. As you can see in the image, this misaligns the blue and yellow parts between `s1` and `s2`, but we still need the parts to match (we still need the blue part of `s1` to be a scrambled version of the blue part of `s2`, same with the yellow part). What are the new starting indices? For blue, it's `s1` starting with `i` and `s2` starting with `j + length - newLength`. For yellow, it's `s1` starting with `i + newLength` and `s2` starting with `j`. Thus, we need both `dp[newLength][i][j+length-newLength]` and `dp[length-newLength][i+newLength][j]` to be `true`.\n\nNow we can formally write down the transitions. For `length > 1`, `dp[length][i][j]` is `true` if and only if for at least one `newLength` where `0 < newLength < length`:\n\n`(dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+length-newLength] && dp[length-newLength][i+newLength][j])` is `true`.\n\nLet `n` denote the length of the input strings. The answer to the problem is `dp[n][0][0]`, as starting at index `0` with length `n` is considering the entire input string.\n\n#### Algorithm\n\n1. Iterate `i` from `0` to `n-1`.\n\t* Iterate `j` from `0` to `n-1`.\n\t\t* Set `dp[1][i][j]` to the boolean value of `s1[i] == s2[j]`. (The base case of the DP).\n2. Iterate `length` from `2` to `n`.\n\t* Iterate `i` from `0` to `n + 1 - length`.\n\t\t* Iterate `j` from `0` to `n + 1 - length`.\n\t\t\t* Iterate `newLength` from `1` to `length - 1`.\n\t\t\t\t* If `dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] && dp[l-newLength][i+newLength][j]` is `true`, set `dp[length][i][j]` to `true`.\n3. Return `dp[n][0][0]`.\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/XJvjmW6h/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XJvjmW6h\"></iframe>\n\n\n#### Complexity Analysis\n\n* Time complexity: $O(n^4)$.\n\nWe have four nested for loops (for `length`, `i`, `j`, `newLength`), each doing $O(n)$ iterations.\n\n* Space complexity: $O(n^3)$.\n\nWe store the matrix `dp[n+1][n][n]` for dynamic programming."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/scramble-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "88",
        "questionFrontendId": "88",
        "title": "Merge Sorted Array",
        "content": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>\n\n<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>\n\n<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array </em><code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>Output:</strong> [1,2,2,3,5,6]\n<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up: </strong>Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</p>\n",
        "likes": 16756,
        "dislikes": 2316,
        "stats": "{\"totalAccepted\": \"4.4M\", \"totalSubmission\": \"8.5M\", \"totalAcceptedRaw\": 4446389, \"totalSubmissionRaw\": 8467614, \"acRate\": \"52.5%\"}",
        "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Squares of a Sorted Array\", \"titleSlug\": \"squares-of-a-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Interval List Intersections\", \"titleSlug\": \"interval-list-intersections\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Take K of Each Character From Left and Right\", \"titleSlug\": \"take-k-of-each-character-from-left-and-right\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
          "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "89",
        "questionFrontendId": "89",
        "title": "Gray Code",
        "content": "<p>An <strong>n-bit gray code sequence</strong> is a sequence of <code>2<sup>n</sup></code> integers where:</p>\n\n<ul>\n\t<li>Every integer is in the <strong>inclusive</strong> range <code>[0, 2<sup>n</sup> - 1]</code>,</li>\n\t<li>The first integer is <code>0</code>,</li>\n\t<li>An integer appears <strong>no more than once</strong> in the sequence,</li>\n\t<li>The binary representation of every pair of <strong>adjacent</strong> integers differs by <strong>exactly one bit</strong>, and</li>\n\t<li>The binary representation of the <strong>first</strong> and <strong>last</strong> integers differs by <strong>exactly one bit</strong>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>any valid <strong>n-bit gray code sequence</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [0,1,3,2]\n<strong>Explanation:</strong>\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 0<u>0</u> and 0<u>1</u> differ by one bit\n- <u>0</u>1 and <u>1</u>1 differ by one bit\n- 1<u>1</u> and 1<u>0</u> differ by one bit\n- <u>1</u>0 and <u>0</u>0 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- <u>0</u>0 and <u>1</u>0 differ by one bit\n- 1<u>0</u> and 1<u>1</u> differ by one bit\n- <u>1</u>1 and <u>0</u>1 differ by one bit\n- 0<u>1</u> and 0<u>0</u> differ by one bit\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n</ul>\n",
        "likes": 2359,
        "dislikes": 2784,
        "stats": "{\"totalAccepted\": \"341.7K\", \"totalSubmission\": \"556.3K\", \"totalAcceptedRaw\": 341682, \"totalSubmissionRaw\": 556272, \"acRate\": \"61.4%\"}",
        "similarQuestions": "[{\"title\": \"1-bit and 2-bit Characters\", \"titleSlug\": \"1-bit-and-2-bit-characters\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/gray-code/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "90",
        "questionFrontendId": "90",
        "title": "Subsets II",
        "content": "<p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span><em> (the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,2]\n<strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n",
        "likes": 10239,
        "dislikes": 361,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1164433, \"totalSubmissionRaw\": 1969977, \"acRate\": \"59.1%\"}",
        "similarQuestions": "[{\"title\": \"Subsets\", \"titleSlug\": \"subsets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Array Given Subset Sums\", \"titleSlug\": \"find-array-given-subset-sums\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/subsets-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "91",
        "questionFrontendId": "91",
        "title": "Decode Ways",
        "content": "<p>You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:</p>\n\n<p><code>&quot;1&quot; -&gt; &#39;A&#39;<br />\n&quot;2&quot; -&gt; &#39;B&#39;<br />\n...<br />\n&quot;25&quot; -&gt; &#39;Y&#39;<br />\n&quot;26&quot; -&gt; &#39;Z&#39;</code></p>\n\n<p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code>&quot;2&quot;</code> and <code>&quot;5&quot;</code> vs <code>&quot;25&quot;</code>).</p>\n\n<p>For example, <code>&quot;11106&quot;</code> can be decoded into:</p>\n\n<ul>\n\t<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1, 1, 10, 6)</code></li>\n\t<li><code>&quot;KJF&quot;</code> with the grouping <code>(11, 10, 6)</code></li>\n\t<li>The grouping <code>(1, 11, 06)</code> is invalid because <code>&quot;06&quot;</code> is not a valid code (only <code>&quot;6&quot;</code> is valid).</li>\n</ul>\n\n<p>Note: there may be strings that are impossible to decode.<br />\n<br />\nGiven a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code>0</code>.</p>\n\n<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;12&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>&quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;226&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>&quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;06&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>&quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;). In this case, the string is not a valid encoding, so return 0.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> contains only digits and may contain leading zero(s).</li>\n</ul>\n",
        "likes": 12324,
        "dislikes": 4568,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 1428602, \"totalSubmissionRaw\": 3939987, \"acRate\": \"36.3%\"}",
        "similarQuestions": "[{\"title\": \"Decode Ways II\", \"titleSlug\": \"decode-ways-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Ways to Separate Numbers\", \"titleSlug\": \"number-of-ways-to-separate-numbers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Number of Texts\", \"titleSlug\": \"count-number-of-texts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/decode-ways/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "92",
        "questionFrontendId": "92",
        "title": "Reverse Linked List II",
        "content": "<p>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4\n<strong>Output:</strong> [1,4,3,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [5], left = 1, right = 1\n<strong>Output:</strong> [5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-500 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do it in one pass?",
        "likes": 12157,
        "dislikes": 698,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1062471, \"totalSubmissionRaw\": 2155819, \"acRate\": \"49.3%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Linked List\", \"titleSlug\": \"reverse-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-linked-list-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "93",
        "questionFrontendId": "93",
        "title": "Restore IP Addresses",
        "content": "<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>\n\n<ul>\n\t<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>\n</ul>\n\n<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;25525511135&quot;\n<strong>Output:</strong> [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0000&quot;\n<strong>Output:</strong> [&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101023&quot;\n<strong>Output:</strong> [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of digits only.</li>\n</ul>\n",
        "likes": 5399,
        "dislikes": 805,
        "stats": "{\"totalAccepted\": \"526.7K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 526690, \"totalSubmissionRaw\": 1000596, \"acRate\": \"52.6%\"}",
        "similarQuestions": "[{\"title\": \"IP to CIDR\", \"titleSlug\": \"ip-to-cidr\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n--- \n\n### Approach 1: Backtracking\n\n#### Intuition\n\n\nSince a valid IP address consists of 4 integers, that means we need to place 3 dots. We can try putting dots at all possible different positions using backtracking. If an invalid number is formed then we backtrack to try out another combination.\n\n> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination to solve a computational problem. It incrementally builds candidates to the solution and abandons a candidate (\"backtracks\") when it determines that the candidate cannot lead to the solution.\n\nWe will recursively enumerate all the possibilities and whenever we get a new integer because of a dot (or 2 integers for the last dot), we check whether the integer(s) is valid, i.e the integer cannot have leading 0s other than being 0 itself and it's no larger than 255.\nThere are 3 possibilities to add each dot, namely it can be added after 1, 2, or 3 digits from the last dot or the beginning of the string, so there are at most $3 ^ 3 = 27$ possibilities to add all 3 dots.\n\nAn optimization is to return an empty result if the input string's length is longer than 12 since each integer can have 3 digits at most (any more and it would either have leading zeroes or be greater than 255).\n\nWe can create a helper function `valid(s, start, length)` to check whether the substring from index `start` to `start + length` is a valid number from range 0-255. The logic is to check both the conditions (the caller guarantees that the length is in the range of [1, 3]):\n\n1. If the substring's first character is `0` (i.e. `s[start]` is '0'), then `length` must be 1.\n2. If `length` is `3`, the substring should no larger than \"255\" lexically. If the length is 1 or 2 and the first case was not triggered, then it will be in the acceptable range.\n\n#### Algorithm\n\nCreate a function `helper` which takes the original string `s`, the processing index `startIndex` (i.e we only consider the substring starting from `startIndex` and the prefix part is already separated into valid integers.), a list of integers `dots` which saves distances for the dots we have added so far and a list of strings `ans` to save the answers.\n\n1. Set `remainingLength` to `length of s - startIndex` which is the string length we want to process.\n2. Set `remainingNumberOfIntegers` to `4 - dots.length`. This is how many integers we have left to form.\n3. Return if `remainingLength` is larger than `remainingNumberOfIntegers * 3` or smaller than `remainingNumberOfIntegers`, since each integer has 1-3 digits. Also note that this catches the case where `s.length() > 12` since at the very beginning `remainingLength` is `s.length()` and `remainingNumberOfIntegers` is 4.\n4. If `remainingNumberOfIntegers = 1`,\n    * if the last integer `s.substring(startIndex, startIndex + remainingLength)` is valid\n        * Create an empty string to save this answer using the following steps.\n        * Set `last` to `0`.\n        * Iterate over all elements `dot` in the list `dots`.\n            * Append `s.substring(last, last + dot)` and a '.' into the answer string.\n            * Increase `last` by `dot` and repeat these steps for each dot.\n       * Append `s.substring(last, s.length)`. This is the final integer after the last dot.\n       * Add the answer string into `ans`.\n    * Return.\n5. Iterate over `curPos` from `1` to `min(3, remainingLength)`. `curPos` is the number of digits we are including before placing a dot.\n    * Place a dot by adding `curPos` into `dots`.\n    * If the integer `s.substring(startIndex, startIndex + curPos)` is valid\n        * Call helper(s, startIndex + curPos, dots, ans)\n    * Remove the dot that we placed to backtrack.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/DYStKNxi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DYStKNxi\"></iframe>\n\n\n#### Complexity Analysis\n\nLet's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits.\n\n* Time complexity: $O(M ^ N \\cdot N)$.\n\n There are at most $M ^ {N - 1}$ possibilities, and for each possibility checking whether all parts are valid takes $O(M \\cdot N)$ time, so the final time complexity is $O(M ^ {N - 1}) \\cdot O(M \\cdot N)$ = $O(M ^ N \\cdot N)$.\n\nFor this question, M = 3, N = 4, so the time complexity is $O(1)$.\n\n* Space complexity: $O(M \\cdot N)$.\n\n  For each possibility, we save (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration.\n\nFor this question, M = 3, N = 4, so the space complexity is $O(1)$.\n\n\n### Approach 2: Iterative\n\n#### Intuition\nWe need to separate the input string into 4 integers, so we can enumerate the length of the first 3 integers, `len1`, `len2`, `len3`. We could iterate over `len1`, `len2`, `len3` with 3 nested loops and the last integer is the remaining part after separating out the first 3.\n\nWe can make the ranges of `len1`, `len2`, `len3` tighter:\n\n* `len1` should be in the range `[max(1, s.length() - 9), min(3, s.length() - 3]` since we need to separate 3 more integers after it and the length of each integer is in [1..3].\n* Similarly, `len2` should be in the range `[max(1, s.length() - len1 - 6, min(3, s.length() - len1 - 2]`\n* `len3` should be in the range `[max(1, s.length() - len1 - len2 - 3), min(3, s.length() - len1 - len2 - 1]`\n\nIn this way, the last part's length is always in the range of `[1..3]`, then we can split each substring out based on the lengths and check whether they are valid. Each integer can be validated before starting the loop of the next part to prevent wasting time.\n\n\n#### Algorithm\n\n1. Initialize an array of strings `ans`.\n2. Iterate over the range of `len1`, the length of the first integer.\n    * If the first integer is valid, then we iterate over `len2`'s range. \n        * If the second integer is also valid, then we iterate over `len3`'s range.\n           * If both third and fourth integers are valid, concatenate all four integers together with a character `'.'` between any 2 neighbors, and add the result string to `ans`.\n3. Return `ans`.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/mcmi5hLS/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mcmi5hLS\"></iframe>\n\n\n#### Complexity Analysis\n\n\nLet's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits.\n\n* Time complexity: $O(M ^ N \\cdot N)$.\n\n  We have $(N - 1)$ nested loops and each of them iterates at most $M$ times, so the total number of iterations is at most  $M ^ {N - 1}$ .\n\n  In each iteration we split $N$ substrings out to check whether they are valid, each substring's length is at most $M$, so the time complexity to separate out all of them is $O(M \\cdot N)$.\n\nFor this question, M = 3, N = 4, so the time complexity is $O(1)$.\n\n* Space complexity: $O(M \\cdot N)$.\n \nThe algorithm saves (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration.\n\nFor this question, M = 3, N = 4, so the space complexity is $O(1)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/restore-ip-addresses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "94",
        "questionFrontendId": "94",
        "title": "Binary Tree Inorder Traversal",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,2]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[4,2,6,5,7,1,3,9,8]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "likes": 14025,
        "dislikes": 835,
        "stats": "{\"totalAccepted\": \"3M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 3042714, \"totalSubmissionRaw\": 3889454, \"acRate\": \"78.2%\"}",
        "similarQuestions": "[{\"title\": \"Validate Binary Search Tree\", \"titleSlug\": \"validate-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Preorder Traversal\", \"titleSlug\": \"binary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Postorder Traversal\", \"titleSlug\": \"binary-tree-postorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Kth Smallest Element in a BST\", \"titleSlug\": \"kth-smallest-element-in-a-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST\", \"titleSlug\": \"inorder-successor-in-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Convert Binary Search Tree to Sorted Doubly Linked List\", \"titleSlug\": \"convert-binary-search-tree-to-sorted-doubly-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Distance Between BST Nodes\", \"titleSlug\": \"minimum-distance-between-bst-nodes\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursive Approach\n\nThe first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.\n\n<iframe src=\"https://leetcode.com/playground/E5pBkUup/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"E5pBkUup\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - The time complexity is $$O(n)$$ because the recursive function is $$T(n) = 2 \\cdot T(n/2)+1$$.\n\nSpace complexity: $$O(n)$$\n\n  - The worst case space required is $$O(n)$$, and in the average case it's $$O(\\log n)$$ where $$n$$ is number of nodes.\n  \n<br />\n\n---\n\n### Approach 2: Iterating method using Stack\n\nThe strategy is very similiar to the first method, the different is using stack.\n\nHere is an illustration:\n\n!?!../Documents/94_Binary.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/9k44r9CB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9k44r9CB\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\nSpace complexity: $$O(n)$$\n\n<br />\n\n---\n\n### Approach 3: Morris Traversal\n\n\nIn this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:\n\n\n>Step 1: Initialize current as root\n>\n>Step 2: While current is not NULL,\n>\n>     If current does not have left child\n>\n>         a. Add current\u2019s value\n>\n>         b. Go to the right, i.e., current = current.right\n>\n>     Else\n>\n>         a. In current's left subtree, make current the right child of the rightmost node\n>\n>         b. Go to this left child, i.e., current = current.left\n\n\nFor example:\n```\n\n          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n\n```\nFirst, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is\n\n```\n         2\n        / \\\n       4   5\n```\n So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).\nThe tree now looks like:\n```\n         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n```\nFor current 2, which has left child 4, we can continue with the same process as we did above\n```\n        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n```\n then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder traversal is [4,2,5,1,6,3].\n\nFor more details, please check\n[Threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) and\n[Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)\n\n\n<iframe src=\"https://leetcode.com/playground/fVkds6Bx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"fVkds6Bx\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - To prove that the time complexity is $$O(n)$$, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is $$O(n \\log n)$$, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs $$O(n)$$ time. Because a binary Tree with $$n$$ nodes has $$n-1$$ edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is $$O(n)$$.\n\nSpace complexity: $$O(1)$$\n\n  - Extra space is only allocated for the ArrayList of size $$n$$, however the output does not count towards the space complexity."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "95",
        "questionFrontendId": "95",
        "title": "Unique Binary Search Trees II",
        "content": "<p>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST&#39;</strong>s (binary search trees), which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "likes": 7744,
        "dislikes": 556,
        "stats": "{\"totalAccepted\": \"504.2K\", \"totalSubmission\": \"840.5K\", \"totalAcceptedRaw\": 504245, \"totalSubmissionRaw\": 840469, \"acRate\": \"60.0%\"}",
        "similarQuestions": "[{\"title\": \"Unique Binary Search Trees\", \"titleSlug\": \"unique-binary-search-trees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an integer `n`, our task is to return all unique BSTs (binary search trees) that have exactly `n` nodes of unique values from `1` to `n`.\n\n---\n\n### Approach 1: Recursive Dynamic Programming\n\n#### Intuition\n\nIn each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater.\n\nTo find all the possible permutations of BSTs with `n` nodes, we can lock one node as the `root` node and split `n - 1` nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value `i` as the root node and place `i - 1` nodes having values from `1` to `i - 1` in the left subtree. (If `i == 1`, the left child is null). Similarly, we place the remaining `n - i` nodes having values from `i + 1` to `n` in the right subtree. (If `i == n`, the right child is null).\n\nNow, we create a list of nodes called `leftSubTrees` for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called `rightSubTrees` for all the BSTs that could be the right subtree. \n\n> In a BST, every subtree is also a BST.\n\nWe iterate over both the lists and for each node pair `l` in `leftSubTrees` and `r` in `rightSubTrees`, we create a new `root` node with value `i` and set the left and right child of `root` to `l` and `r` respectively to form all the BSTs with the root node as `i`.\n\nWe can iterate over the root's value from `i = 1` to `n` and repeat the process for each root value to get all the BSTs.\n\nYou may notice that the subproblem of finding the arrays `leftSubTrees` and `rightSubTrees` are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with `n` nodes to smaller, repetitive subproblems with `i - 1` and `n - i` nodes (for `i = 1` till `n`) to compute the answer for `n` nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range.\n\nWe implement a recursive function `allPossibleBST(start, end)` where `start` and `end` correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value `i`, we will find all the left subtrees using `leftSubTrees = allPossibleBST(start, i - 1)` and also compute all the right subtrees using `rightSubTrees = allPossibleBST(i + 1, right)`. Finally, we iterate over all pairs between `leftSubTrees` and `rightSubTrees` and create a new root with value `i` for each pair.\n\nThe base case of this function is when `start > end`. We have no values in our range and thus we will return `null` (an empty tree).\n\nHere is a visual representation of the recursion tree with `3` nodes:\n\n![img](../Figures/95/95-1.png)\n\nSeveral subproblems, such as `allPossibleBST(1, 1)`, `allPossibleBST(3, 3)`, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.\n\nTo avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of `TreeNode`. This is called **memoization**.\n\n#### Algorithm\n\n1. Create a hash map `memo` where `memo[(start, end)]` contains the list of root nodes of all possible BSTs with the range of node values from `start` to `end`.\n2. We implement a recursive function `allPossibleBST` which takes the starting range of node values `start`, ending range `end`, and `memo` as parameters. It returns a list of `TreeNode` corresponding to all the BSTs that can be formed with this range of node values. We call `allPossibleBST(1, n, memo)` and perform the following:\n    - We declare a list of `TreeNode` called `res` to store the list of root nodes of all possible BSTs.\n    - If `start > end`, we push `null` to `res` and return it.\n    - If we already have solved this subproblem, i.e., `memo` contains the pair `(start, end)`, we return `memo[(start, end)]`.\n    - Select the root node value from `i = start` to `end` incrementing `i` by `1` after each iteration. We recursively call `leftSubtrees = llPossibleBST(start, i - 1, memo)` and `rightSubTrees = allPossibleBST(i + 1, end, memo)`. We iterate over all pairs between `leftSubtrees` and `rightSubTrees` and create a new root with value `i` for each pair. We push `root` of the new formed BST into `res`.\n    - Set `memo[(start, end)] = res` and return `res`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/FiZegYw8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FiZegYw8\"></iframe>\n\n#### Complexity Analysis\n\nNote, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview.\n\nThe number of unique BSTs that can be formed with `n` nodes is $G(n)$ where $G(n)$ is the $n^{th}$ [Catalan number](https://en.wikipedia.org/wiki/Catalan_number). $G(n) = O(\\dfrac{4^{n}}{n^{1.5}})$.\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - There are $G(n) = \\dfrac{4^n}{n^{1.5}}$ BSTs in our answer. Each of these BSTs has $n$ nodes, so it cost us $O(n)$ to build each one. This gives us a time complexity of $O(n \\cdot G(n)) = O(\\dfrac{4^n}{\\sqrt{n}})$.\n\n* Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]})$.\n\n    We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in `memo`. Let's analyze how many nodes are stored in `memo`.\n\n    The number of nodes in a range `start, end` is `end - start + 1`. Let $k = \\text{end} - \\text{start} + 1$ represent this formula.\n\n    There are $n$ states `start, end` with one node, that is $k = 1$.\n\n    There are $n - 1$ states `start, end` with two nodes, that is $k = 2$.\n\n    There are $n - 2$ states `start, end` with three nodes, that is $k = 3$.\n\n    This continues until there is only one state with $n$ nodes (the original input). In general, a value of $k$ has $n - k + 1$ states.\n\n    For a given state with value $k$, there are $G(k) = \\dfrac{4^k}{k^{1.5}}$ BSTs. Each of these BSTs has $k$ nodes, and thus takes up $k \\cdot G(k) = \\dfrac{4^k}{\\sqrt{k}}$ space in `memo`.\n\n    A given value $k$ has $n - k + 1$ states and thus takes up $(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}$ space. In our algorithm, $k$ ranges from $1$ to $n$.\n\n    The space complexity is the summation for all values of $k$:\n\n    $\\Large{\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]}}$\n\n    This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to:\n\n    $4^{1 + n} \\cdot \\Phi(4, -0.5, 1 + n) - 4^{1 + n} \\cdot (1 + n) \\cdot \\Phi(4, 0.5, 1 + n) - \\text{Li}_{-0.5}(4) + \\text{Li}_{0.5}(4) + n \\cdot \\text{Li}_{0.5}(4)$\n\n    Where $\\Phi$ is the [Lerch transcendent](https://en.wikipedia.org/wiki/Lerch_zeta_function) and $\\text{Li}_n(x)$ is the [polylogarithm function](https://en.wikipedia.org/wiki/Polylogarithm). Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer.\n\n---\n\n### Approach 2: Iterative Dynamic Programming\n\n#### Intuition\n\nWe used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.\n\nWe create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of all BSTs that have node values ranging from `i` to `j`. Note that `dp[i][j] = allPossibleBST(i, j)` from the previous approach.\n\nWhen `i = j`, the range contains only one node with value `i`. We push a single node with value `i` in the list `dp[i][i]` for all the values of `i` from `1` to `n`. This acts as the base case of our solution while we move in bottom to top manner.\n\nWe form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from `numberOfNodes = 2` to `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. This loop controls the total number of nodes under consideration.\n\nWe further need to choose a node value we start with. Let's call it `start`. As we have `numberOfNodes` nodes under consideration with consecutive values, the maximum node value in such a BST would be `end = start + numberOfNodes - 1`. We will move `start` from `1` to `n - numberOfNodes + 1`.\n\nNow we have the `start` value and the `end` value, we can implement the same logic that we did in the `allPossibleBST` function from the previous approach. Lock a value `i`, find all left and right subtrees, and then iterate over each `left, right` pair and create a new root with value `i` for each pair.\n\nAs we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes.\n\nLocking a value `i` as the root node, we can find all left subtrees in `dp[start][i - 1]` and all right subtrees in `dp[i + 1][end]`. If `i == start`, the left subtree would be empty. Similarly, if `i == end`, the right subtree would be empty. We can handle these cases separately.\n\nWe run an outer loop from `numberOfNodes = 2` to `n`. We run an inner loop that selects the starting node value. It runs from `start = 1` to `n - numberOfNodes + 1`. We define `end = start + numberOfNodes - 1`. We run a third nested loop that selects the root of the BSTs under consideration. It runs from `i = start` to `end`.\n\nWe then iterate over the both the lists of left and right subtrees. For each root node `l` of the left subtree and `r` of the right subtree, we create a new `root` node with value `i` and set the left and right child to `l` and `r` respectively to form all the BSTs with root node as `i`. We also push each BST into `dp[start][end]` to be used later to build answer for other `dp` states with larger number of nodes.\n\n#### Algorithm\n\n1. Create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of root nodes for all possible BSTs using `j - i + 1` nodes with values from `i` to `j` nodes.\n2. We initialize each list `dp[i][i]` to a `TreeNode` having value `i` for `i = 0` to `n`.\n3. Iterate from `numberOfNodes = 2` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `start = 1` to `n - numberOfNodes + 1` incrementing `start` by `1`. We create an integer variable `end = start + numberOfNodes - 1` which stores the highest node value of the BSTs that will be formed. We run another loop from `i = start` to `end` to use all the permutations as the root node value. We perform the following in this loop:\n    - We create a list of `TreeNode` called `leftSubtrees` which will store all the BSTs that can be formed with node values from `start` to `i - 1`. If `i == start`, we just add `null` to `leftSubtrees`, else `leftSubtrees == dp[start][i - 1]`.\n    - Similarly, we create a list of `TreeNode` called `rightSubtrees` which will store all the BSTs that can be formed with node values from `i + 1` to `end`. If `i == end`, we just add `null` to `rightSubtrees`, else `rightSubtrees == dp[i + 1][end]`.\n    - We form a new BST by creating a new node which acts as a root node with value `i`. For each element `left` in `leftSubtrees` and `right` in `rightSubtrees`, we set `root.left = left` and `root.right = right`. Finally, we add `root` to `dp[start][end]`.\n4. Return `dp[1][n]`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/hj8MdGva/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hj8MdGva\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - The time complexity of this approach will be similar to the **time complexity** of the first approach because we are iterating over the same `dp` states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization.\n\n* Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]})$.\n    - The space complexity would also be the number of BSTs stored in the `dp` list which is equal to the number of BSTs stored in `memo` in the worst-case. Hence, we have the same space complexity as the first approach.\n\n---\n\n### Approach 3: Dynamic Programming with Space Optimization\n\n#### Intuition\n\nWe used a 3D list where we used `dp[start][end]` to store all the BSTs having `end - start + 1` nodes with range from `start` to `end`. Let's think if we can reduce the 3D `dp` list to a 2D list.\n\nIf we compare all the BSTs that can be created from a set of consecutive values from `start` to `end` to those that can be created with the same number of nodes from a set of values starting at `1` and ending at `end - start + 1`, we will find that **the structure of all the BSTs created with the above two ranges would be identical**. The only difference is an offset of `start - 1` in the node values.\n\nHere's a visual representation of BSTs with 3 nodes from range `[1, 3]` and all BSTs with range `[4, 6]`:\n\n![img](../Figures/95/95-2.png)\n\nWe can see the structure of all the BSTs created with the above two ranges are identical.\n\nSo, we can just store the BSTs for all the ranges starting from `1` and add the offset to convert them to required ranges.\n\nWe create a 2D list `dp[n + 1]` where `dp[i]` will store a list of all BSTs with `i` nodes having values from `1` to `i`. `dp[n]` would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner.\n\nWe push a `null` node (empty tree) to `dp[0]` which acts as the base case.\n\nTo get the list of root nodes for all possible BSTs with `numberOfNodes` nodes, we would split the `numberOfNodes` nodes with `i - 1` nodes with values `1` to `i - 1` in the left subtree, a root node with value `i` and the remaining `numberOfNodes - i` nodes with values `i + 1` to `numberOfNodes` in the right subtree where `1 <= i <= numberOfNodes`. Note that we do not need the starting of the range here, unlike the previous approach. It is always `1`. \n\nAs we are executing in bottom-up manner and figuring out the answer for `numberOfNodes` nodes, we will already have the list of root nodes for all BSTs with `i - 1` and `numberOfNodes - i` nodes (for all values of `i = 1` to `numberOfNodes`).\n\nHowever, you may realize that `dp[i - 1]` will give all the BSTs having values from `1` to `i - 1` which is exactly what we want but `dp[numberOfNodes - i]` will give all the BSTs having values from `1` to `numberOfNodes - i` which isn't what we want. We want the right subtree to have `numberOfNodes - i` nodes but the range of nodes should be from `i + 1` to `numberOfNodes`. If we add the offset `(i + 1) - 1 = i` to all the nodes, it would solve this as we would now have trees with `numberOfNodes - i` nodes from values `i + 1` to `numberOfNodes`. Let us form the BSTs now.\n\nSimilar to the previous approach, we create a new instance of `TreeNode` called `root` with the value `i`. We set the left child of `root` to an element in `dp[i - 1]`.\n\nNow, let's set the right child of `root`. We know every element in `dp[numberOfNodes - i]` is a root node that stores a BST with `numberOfNodes - 1` nodes having values from `1` to `numberOfNodes - i`. To set the right child of `root`, we create a new tree exactly similar to the tree stored by an element of `dp[numberOfNodes - i]` but increment all the node values of the new tree by `i`. We then set the right child of `root` to this newer tree.\n\nThe required tree with `i` offset can be created by using a recursive function `clone` in which we pass a `TreeNode node` which corresponds to an element in `dp[numberOfNodes - i]` and an integer `offset`. We create a new `TreeNode clonedNode` with value `node.val + offset`. We then recursively set the left and the right child of `clonedNode` by performing `clonedNode.left = clone(node.left, offset)` and `clonedNode.right = clone(node.right, offset)`. Finally, return `clonedNode`.\n\nIt is important to note that we are creating new trees to set the right child of `root` to preserve the original trees as it might be used directly (as `dp[i - 1]`) in some other iteration of `i` and `numberOfNodes`.\n\n#### Algorithm\n\n1. Create a list `dp[n + 1]` where `dp[i]` will store a list of root nodes for all possible BSTs using `i` nodes. We initialize each list `dp[i]` to an empty list for `i = 0` to `n`.\n2. We push a `null` node (empty tree) into `dp[0]` because with `n = 0` we can't have any BST. This forms the base case.\n3. Iterate from `numberOfNodes = 1` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `i = 1` to `numberOfNodes` incrementing `i` by `1`. We perform the following in this loop:\n    - Create a variable `j = numberOfNodes - i - 1`. It presents the number of nodes in the right subtree under consideration.\n    - We can form a new BST by creating a new node which acts as a root node with value `i`. We assign its left child to any element in `dp[i]` and right child to a new tree where tree is similar to an element in `dp[j]` but all node values are incremented by `i`. As a result, we need two loops to iterate through the lists `dp[i]` and `dp[j]`. We create a new `root` node with value `i`. For each element `left` in `dp[i]` and `right` in `dp[j]`, we set `root.left = left` and `root.right = clone(right, i)`. Finally, we add `root` to `dp[numberOfNodes]`.\n4. Return `dp[n]`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/a8x29E6y/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"a8x29E6y\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range `1`. However, we are creating all the BSTs for all the ranges from `[start, end]` (for `1 <= start, end  <= 1`) using the `clone` method by iterating over the BSTs starting with range `1`.\n    - As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs.\n\n* Space complexity: $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$.\n    - For any state `dp[k]`, we are storing all the BSTs that can be formed with $k$ nodes. We know there are $G(k)$ BSTs that can be formed with $k$ nodes. As we have $1$ to $n$ states, the total space consumed would be $O(\\sum_{k=1}^{n} k \\cdot G(k))$ = $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "96",
        "questionFrontendId": "96",
        "title": "Unique Binary Search Trees",
        "content": "<p>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST&#39;</strong>s (binary search trees) which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n",
        "likes": 10634,
        "dislikes": 427,
        "stats": "{\"totalAccepted\": \"748K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 747967, \"totalSubmissionRaw\": 1201769, \"acRate\": \"62.2%\"}",
        "similarQuestions": "[{\"title\": \"Unique Binary Search Trees II\", \"titleSlug\": \"unique-binary-search-trees-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-binary-search-trees/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "97",
        "questionFrontendId": "97",
        "title": "Interleaving String",
        "content": "<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p>\n\n<p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword=\"substring-nonempty\">substrings</span> respectively, such that:</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li>The <strong>interleaving</strong> is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>Note:</strong> <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Notice how it is impossible to interleave s2 with any other string to obtain s3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it using only <code>O(s2.length)</code> additional memory space?</p>\n",
        "likes": 8489,
        "dislikes": 524,
        "stats": "{\"totalAccepted\": \"632.3K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 632274, \"totalSubmissionRaw\": 1519769, \"acRate\": \"41.6%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/interleaving-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "98",
        "questionFrontendId": "98",
        "title": "Validate Binary Search Tree",
        "content": "<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>\n\n<p>A <strong>valid BST</strong> is defined as follows:</p>\n\n<ul>\n\t<li>The left <span data-keyword=\"subtree\">subtree</span> of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>Input:</strong> root = [5,1,4,null,null,3,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 17484,
        "dislikes": 1402,
        "stats": "{\"totalAccepted\": \"2.8M\", \"totalSubmission\": \"8.2M\", \"totalAcceptedRaw\": 2788571, \"totalSubmissionRaw\": 8170635, \"acRate\": \"34.1%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Mode in Binary Search Tree\", \"titleSlug\": \"find-mode-in-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/validate-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "99",
        "questionFrontendId": "99",
        "title": "Recover Binary Search Tree",
        "content": "<p>You are given the <code>root</code> of a binary search tree (BST), where the values of <strong>exactly</strong> two nodes of the tree were swapped by mistake. <em>Recover the tree without changing its structure</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,null,null,2]\n<strong>Output:</strong> [3,1,null,null,2]\n<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"width: 581px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,null,2]\n<strong>Output:</strong> [2,1,4,null,null,3]\n<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?",
        "likes": 8183,
        "dislikes": 266,
        "stats": "{\"totalAccepted\": \"531.5K\", \"totalSubmission\": \"953.4K\", \"totalAcceptedRaw\": 531499, \"totalSubmissionRaw\": 953435, \"acRate\": \"55.7%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/recover-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "100",
        "questionFrontendId": "100",
        "title": "Same Tree",
        "content": "<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>\n\n<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,3], q = [1,2,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2], q = [1,null,2]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,1], q = [1,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 12091,
        "dislikes": 263,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 2718520, \"totalSubmissionRaw\": 4203995, \"acRate\": \"64.7%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/same-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "101",
        "questionFrontendId": "101",
        "title": "Symmetric Tree",
        "content": "<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg\" style=\"width: 354px; height: 291px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,4,4,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg\" style=\"width: 308px; height: 258px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,null,3,null,3]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it both recursively and iteratively?",
        "likes": 15978,
        "dislikes": 411,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"4.1M\", \"totalAcceptedRaw\": 2395122, \"totalSubmissionRaw\": 4068201, \"acRate\": \"58.9%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/symmetric-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "102",
        "questionFrontendId": "102",
        "title": "Binary Tree Level Order Traversal",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "likes": 16046,
        "dislikes": 345,
        "stats": "{\"totalAccepted\": \"2.8M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 2752728, \"totalSubmissionRaw\": 3926195, \"acRate\": \"70.1%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Zigzag Level Order Traversal\", \"titleSlug\": \"binary-tree-zigzag-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Level Order Traversal II\", \"titleSlug\": \"binary-tree-level-order-traversal-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Depth of Binary Tree\", \"titleSlug\": \"minimum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Vertical Order Traversal\", \"titleSlug\": \"binary-tree-vertical-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Average of Levels in Binary Tree\", \"titleSlug\": \"average-of-levels-in-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"N-ary Tree Level Order Traversal\", \"titleSlug\": \"n-ary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Cousins in Binary Tree\", \"titleSlug\": \"cousins-in-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Operations to Sort a Binary Tree by Level\", \"titleSlug\": \"minimum-number-of-operations-to-sort-a-binary-tree-by-level\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Divide Nodes Into the Maximum Number of Groups\", \"titleSlug\": \"divide-nodes-into-the-maximum-number-of-groups\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use a queue to perform BFS."
        ],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "103",
        "questionFrontendId": "103",
        "title": "Binary Tree Zigzag Level Order Traversal",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[20,9],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 11349,
        "dislikes": 326,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 1441733, \"totalSubmissionRaw\": 2353390, \"acRate\": \"61.3%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Grid Traversal With Skip\", \"titleSlug\": \"zigzag-grid-traversal-with-skip\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "104",
        "questionFrontendId": "104",
        "title": "Maximum Depth of Binary Tree",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>\n\n<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 13457,
        "dislikes": 259,
        "stats": "{\"totalAccepted\": \"3.9M\", \"totalSubmission\": \"5M\", \"totalAcceptedRaw\": 3877538, \"totalSubmissionRaw\": 5042102, \"acRate\": \"76.9%\"}",
        "similarQuestions": "[{\"title\": \"Balanced Binary Tree\", \"titleSlug\": \"balanced-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Depth of Binary Tree\", \"titleSlug\": \"minimum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Depth of N-ary Tree\", \"titleSlug\": \"maximum-depth-of-n-ary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Time Needed to Inform All Employees\", \"titleSlug\": \"time-needed-to-inform-all-employees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Amount of Time for Binary Tree to Be Infected\", \"titleSlug\": \"amount-of-time-for-binary-tree-to-be-infected\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Height of Binary Tree After Subtree Removal Queries\", \"titleSlug\": \"height-of-binary-tree-after-subtree-removal-queries\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "105",
        "questionFrontendId": "105",
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "content": "<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n\t<li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>\n\t<li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n</ul>\n",
        "likes": 15754,
        "dislikes": 567,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 1520616, \"totalSubmissionRaw\": 2290524, \"acRate\": \"66.4%\"}",
        "similarQuestions": "[{\"title\": \"Construct Binary Tree from Inorder and Postorder Traversal\", \"titleSlug\": \"construct-binary-tree-from-inorder-and-postorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "106",
        "questionFrontendId": "106",
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "content": "<p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> inorder = [-1], postorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n\t<li><code>postorder.length == inorder.length</code></li>\n\t<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code> and <code>postorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n\t<li><code>postorder</code> is <strong>guaranteed</strong> to be the postorder traversal of the tree.</li>\n</ul>\n",
        "likes": 8338,
        "dislikes": 141,
        "stats": "{\"totalAccepted\": \"781.5K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 781462, \"totalSubmissionRaw\": 1185490, \"acRate\": \"65.9%\"}",
        "similarQuestions": "[{\"title\": \"Construct Binary Tree from Preorder and Inorder Traversal\", \"titleSlug\": \"construct-binary-tree-from-preorder-and-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "107",
        "questionFrontendId": "107",
        "title": "Binary Tree Level Order Traversal II",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level from leaf to root).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[15,7],[9,20],[3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "likes": 4995,
        "dislikes": 326,
        "stats": "{\"totalAccepted\": \"723.3K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 723276, \"totalSubmissionRaw\": 1102634, \"acRate\": \"65.6%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Average of Levels in Binary Tree\", \"titleSlug\": \"average-of-levels-in-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "108",
        "questionFrontendId": "108",
        "title": "Convert Sorted Array to Binary Search Tree",
        "content": "<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg\" style=\"width: 302px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> nums = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg\" style=\"width: 302px; height: 222px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree.jpg\" style=\"width: 342px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> [3,1]\n<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>\n</ul>\n",
        "likes": 11394,
        "dislikes": 599,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1442559, \"totalSubmissionRaw\": 1955651, \"acRate\": \"73.8%\"}",
        "similarQuestions": "[{\"title\": \"Convert Sorted List to Binary Search Tree\", \"titleSlug\": \"convert-sorted-list-to-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "109",
        "questionFrontendId": "109",
        "title": "Convert Sorted List to Binary Search Tree",
        "content": "<p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/linked.jpg\" style=\"width: 500px; height: 388px;\" />\n<pre>\n<strong>Input:</strong> head = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 7637,
        "dislikes": 165,
        "stats": "{\"totalAccepted\": \"595.6K\", \"totalSubmission\": \"929.4K\", \"totalAcceptedRaw\": 595607, \"totalSubmissionRaw\": 929362, \"acRate\": \"64.1%\"}",
        "similarQuestions": "[{\"title\": \"Convert Sorted Array to Binary Search Tree\", \"titleSlug\": \"convert-sorted-array-to-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Create Binary Tree From Descriptions\", \"titleSlug\": \"create-binary-tree-from-descriptions\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "110",
        "questionFrontendId": "110",
        "title": "Balanced Binary Tree",
        "content": "<p>Given a binary tree, determine if it is <span data-keyword=\"height-balanced\"><strong>height-balanced</strong></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 11289,
        "dislikes": 760,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.4M\", \"totalAcceptedRaw\": 1884961, \"totalSubmissionRaw\": 3435161, \"acRate\": \"54.9%\"}",
        "similarQuestions": "[{\"title\": \"Maximum Depth of Binary Tree\", \"titleSlug\": \"maximum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"K-th Largest Perfect Subtree Size in Binary Tree\", \"titleSlug\": \"k-th-largest-perfect-subtree-size-in-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check Balanced String\", \"titleSlug\": \"check-balanced-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/balanced-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "111",
        "questionFrontendId": "111",
        "title": "Minimum Depth of Binary Tree",
        "content": "<p>Given a binary tree, find its minimum depth.</p>\n\n<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>\n\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "likes": 7524,
        "dislikes": 1333,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.8M\", \"totalAcceptedRaw\": 1401953, \"totalSubmissionRaw\": 2789940, \"acRate\": \"50.3%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Depth of Binary Tree\", \"titleSlug\": \"maximum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "112",
        "questionFrontendId": "112",
        "title": "Path Sum",
        "content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "likes": 10134,
        "dislikes": 1168,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"3.4M\", \"totalAcceptedRaw\": 1769685, \"totalSubmissionRaw\": 3363510, \"acRate\": \"52.6%\"}",
        "similarQuestions": "[{\"title\": \"Path Sum II\", \"titleSlug\": \"path-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Maximum Path Sum\", \"titleSlug\": \"binary-tree-maximum-path-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum III\", \"titleSlug\": \"path-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/path-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "113",
        "questionFrontendId": "113",
        "title": "Path Sum II",
        "content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals </em><code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>\n\n<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>Output:</strong> [[5,4,11,2],[5,8,4,5]]\n<strong>Explanation:</strong> There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" style=\"width: 212px; height: 181px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], targetSum = 0\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "likes": 8259,
        "dislikes": 161,
        "stats": "{\"totalAccepted\": \"996K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 996030, \"totalSubmissionRaw\": 1655058, \"acRate\": \"60.2%\"}",
        "similarQuestions": "[{\"title\": \"Path Sum\", \"titleSlug\": \"path-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Paths\", \"titleSlug\": \"binary-tree-paths\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Path Sum III\", \"titleSlug\": \"path-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Step-By-Step Directions From a Binary Tree Node to Another\", \"titleSlug\": \"step-by-step-directions-from-a-binary-tree-node-to-another\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Backtracking"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/path-sum-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "114",
        "questionFrontendId": "114",
        "title": "Flatten Binary Tree to Linked List",
        "content": "<p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>\n\n<ul>\n\t<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>\n\t<li>The &quot;linked list&quot; should be in the same order as a <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,5,3,4,null,6]\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?",
        "likes": 12873,
        "dislikes": 577,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1155636, \"totalSubmissionRaw\": 1699752, \"acRate\": \"68.0%\"}",
        "similarQuestions": "[{\"title\": \"Flatten a Multilevel Doubly Linked List\", \"titleSlug\": \"flatten-a-multilevel-doubly-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Correct a Binary Tree\", \"titleSlug\": \"correct-a-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal."
        ],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "115",
        "questionFrontendId": "115",
        "title": "Distinct Subsequences",
        "content": "<p>Given two strings s and t, return <i>the number of distinct</i> <b><i>subsequences</i></b><i> of </i>s<i> which equals </i>t.</p>\n\n<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nAs shown below, there are 3 ways you can generate &quot;rabbit&quot; from s.\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babgbag&quot;, t = &quot;bag&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nAs shown below, there are 5 ways you can generate &quot;bag&quot; from s.\n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code></pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> and <code>t</code> consist of English letters.</li>\n</ul>\n",
        "likes": 6937,
        "dislikes": 308,
        "stats": "{\"totalAccepted\": \"523.1K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 523063, \"totalSubmissionRaw\": 1052656, \"acRate\": \"49.7%\"}",
        "similarQuestions": "[{\"title\": \"Number of Unique Good Subsequences\", \"titleSlug\": \"number-of-unique-good-subsequences\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/distinct-subsequences/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "116",
        "questionFrontendId": "116",
        "title": "Populating Next Right Pointers in Each Node",
        "content": "<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]\n<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n",
        "likes": 10048,
        "dislikes": 312,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 1184536, \"totalSubmissionRaw\": 1820074, \"acRate\": \"65.1%\"}",
        "similarQuestions": "[{\"title\": \"Populating Next Right Pointers in Each Node II\", \"titleSlug\": \"populating-next-right-pointers-in-each-node-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Right Side View\", \"titleSlug\": \"binary-tree-right-side-view\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Cycle Length Queries in a Tree\", \"titleSlug\": \"cycle-length-queries-in-a-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "117",
        "questionFrontendId": "117",
        "title": "Populating Next Right Pointers in Each Node II",
        "content": "<p>Given a binary tree</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/15/117_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,null,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]\n<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 6000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n",
        "likes": 6018,
        "dislikes": 332,
        "stats": "{\"totalAccepted\": \"735.8K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 735810, \"totalSubmissionRaw\": 1334218, \"acRate\": \"55.1%\"}",
        "similarQuestions": "[{\"title\": \"Populating Next Right Pointers in Each Node\", \"titleSlug\": \"populating-next-right-pointers-in-each-node\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "118",
        "questionFrontendId": "118",
        "title": "Pascal's Triangle",
        "content": "<p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> numRows = 5\n<strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> numRows = 1\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numRows &lt;= 30</code></li>\n</ul>\n",
        "likes": 13642,
        "dislikes": 502,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 2063717, \"totalSubmissionRaw\": 2692553, \"acRate\": \"76.6%\"}",
        "similarQuestions": "[{\"title\": \"Pascal's Triangle II\", \"titleSlug\": \"pascals-triangle-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Check If Digits Are Equal in String After Operations II\", \"titleSlug\": \"check-if-digits-are-equal-in-string-after-operations-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/pascals-triangle/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "119",
        "questionFrontendId": "119",
        "title": "Pascal's Triangle II",
        "content": "<p>Given an integer <code>rowIndex</code>, return the <code>rowIndex<sup>th</sup></code> (<strong>0-indexed</strong>) row of the <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 3\n<strong>Output:</strong> [1,3,3,1]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 0\n<strong>Output:</strong> [1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 1\n<strong>Output:</strong> [1,1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you optimize your algorithm to use only <code>O(rowIndex)</code> extra space?</p>\n",
        "likes": 5013,
        "dislikes": 357,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 1028155, \"totalSubmissionRaw\": 1565801, \"acRate\": \"65.7%\"}",
        "similarQuestions": "[{\"title\": \"Pascal's Triangle\", \"titleSlug\": \"pascals-triangle\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Triangular Sum of an Array\", \"titleSlug\": \"find-triangular-sum-of-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/pascals-triangle-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "120",
        "questionFrontendId": "120",
        "title": "Triangle",
        "content": "<p>Given a <code>triangle</code> array, return <em>the minimum path sum from top to bottom</em>.</p>\n\n<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The triangle looks like:\n   <u>2</u>\n  <u>3</u> 4\n 6 <u>5</u> 7\n4 <u>1</u> 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[-10]]\n<strong>Output:</strong> -10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= triangle.length &lt;= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you&nbsp;do this using only <code>O(n)</code> extra space, where <code>n</code> is the total number of rows in the triangle?",
        "likes": 9946,
        "dislikes": 576,
        "stats": "{\"totalAccepted\": \"955.7K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 955681, \"totalSubmissionRaw\": 1624007, \"acRate\": \"58.8%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/triangle/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "121",
        "questionFrontendId": "121",
        "title": "Best Time to Buy and Sell Stock",
        "content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>\n\n<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transactions are done and the max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 32918,
        "dislikes": 1272,
        "stats": "{\"totalAccepted\": \"6.2M\", \"totalSubmission\": \"11.2M\", \"totalAcceptedRaw\": 6173749, \"totalSubmissionRaw\": 11238263, \"acRate\": \"54.9%\"}",
        "similarQuestions": "[{\"title\": \"Maximum Subarray\", \"titleSlug\": \"maximum-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock II\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock III\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock IV\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock with Cooldown\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-with-cooldown\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sum of Beauty in the Array\", \"titleSlug\": \"sum-of-beauty-in-the-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Difference Between Increasing Elements\", \"titleSlug\": \"maximum-difference-between-increasing-elements\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Profit From Trading Stocks\", \"titleSlug\": \"maximum-profit-from-trading-stocks\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "122",
        "questionFrontendId": "122",
        "title": "Best Time to Buy and Sell Stock II",
        "content": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>\n\n<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 14374,
        "dislikes": 2763,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 2447019, \"totalSubmissionRaw\": 3541028, \"acRate\": \"69.1%\"}",
        "similarQuestions": "[{\"title\": \"Best Time to Buy and Sell Stock\", \"titleSlug\": \"best-time-to-buy-and-sell-stock\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock III\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock IV\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock with Cooldown\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-with-cooldown\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock with Transaction Fee\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-with-transaction-fee\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Profit From Trading Stocks\", \"titleSlug\": \"maximum-profit-from-trading-stocks\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "123",
        "questionFrontendId": "123",
        "title": "Best Time to Buy and Sell Stock III",
        "content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 10075,
        "dislikes": 206,
        "stats": "{\"totalAccepted\": \"755.8K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 755826, \"totalSubmissionRaw\": 1495850, \"acRate\": \"50.5%\"}",
        "similarQuestions": "[{\"title\": \"Best Time to Buy and Sell Stock\", \"titleSlug\": \"best-time-to-buy-and-sell-stock\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock II\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock IV\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Sum of 3 Non-Overlapping Subarrays\", \"titleSlug\": \"maximum-sum-of-3-non-overlapping-subarrays\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Profit From Trading Stocks\", \"titleSlug\": \"maximum-profit-from-trading-stocks\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximize Win From Two Segments\", \"titleSlug\": \"maximize-win-from-two-segments\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "124",
        "questionFrontendId": "124",
        "title": "Binary Tree Maximum Path Sum",
        "content": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "likes": 17429,
        "dislikes": 763,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 1533589, \"totalSubmissionRaw\": 3737756, \"acRate\": \"41.0%\"}",
        "similarQuestions": "[{\"title\": \"Path Sum\", \"titleSlug\": \"path-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Univalue Path\", \"titleSlug\": \"longest-univalue-path\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Time Needed to Inform All Employees\", \"titleSlug\": \"time-needed-to-inform-all-employees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Difference Between Maximum and Minimum Price Sum\", \"titleSlug\": \"difference-between-maximum-and-minimum-price-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "125",
        "questionFrontendId": "125",
        "title": "Valid Palindrome",
        "content": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n",
        "likes": 10228,
        "dislikes": 8531,
        "stats": "{\"totalAccepted\": \"4.1M\", \"totalSubmission\": \"8.1M\", \"totalAcceptedRaw\": 4078267, \"totalSubmissionRaw\": 8080223, \"acRate\": \"50.5%\"}",
        "similarQuestions": "[{\"title\": \"Palindrome Linked List\", \"titleSlug\": \"palindrome-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Valid Palindrome II\", \"titleSlug\": \"valid-palindrome-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Product of the Length of Two Palindromic Subsequences\", \"titleSlug\": \"maximum-product-of-the-length-of-two-palindromic-subsequences\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find First Palindromic String in the Array\", \"titleSlug\": \"find-first-palindromic-string-in-the-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Valid Palindrome IV\", \"titleSlug\": \"valid-palindrome-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Palindromes After Operations\", \"titleSlug\": \"maximum-palindromes-after-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/valid-palindrome/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "126",
        "questionFrontendId": "126",
        "title": "Word Ladder II",
        "content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n\t<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>\n</ul>\n",
        "likes": 6225,
        "dislikes": 802,
        "stats": "{\"totalAccepted\": \"403.8K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 403809, \"totalSubmissionRaw\": 1488187, \"acRate\": \"27.1%\"}",
        "similarQuestions": "[{\"title\": \"Word Ladder\", \"titleSlug\": \"word-ladder\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Groups of Strings\", \"titleSlug\": \"groups-of-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Breadth-First Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-ladder-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "127",
        "questionFrontendId": "127",
        "title": "Word Ladder",
        "content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 12652,
        "dislikes": 1923,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 1312484, \"totalSubmissionRaw\": 3109398, \"acRate\": \"42.2%\"}",
        "similarQuestions": "[{\"title\": \"Word Ladder II\", \"titleSlug\": \"word-ladder-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Genetic Mutation\", \"titleSlug\": \"minimum-genetic-mutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Words Within Two Edits of Dictionary\", \"titleSlug\": \"words-within-two-edits-of-dictionary\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Breadth-First Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/word-ladder/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "128",
        "questionFrontendId": "128",
        "title": "Longest Consecutive Sequence",
        "content": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,4,200,1,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,2]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 21217,
        "dislikes": 1133,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"5.2M\", \"totalAcceptedRaw\": 2448538, \"totalSubmissionRaw\": 5196035, \"acRate\": \"47.1%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Longest Consecutive Sequence\", \"titleSlug\": \"binary-tree-longest-consecutive-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Three Consecutive Integers That Sum to a Given Number\", \"titleSlug\": \"find-three-consecutive-integers-that-sum-to-a-given-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Consecutive Floors Without Special Floors\", \"titleSlug\": \"maximum-consecutive-floors-without-special-floors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Length of the Longest Alphabetical Continuous Substring\", \"titleSlug\": \"length-of-the-longest-alphabetical-continuous-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Maximum Number of Elements in Subset\", \"titleSlug\": \"find-the-maximum-number-of-elements-in-subset\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Union Find"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/longest-consecutive-sequence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "129",
        "questionFrontendId": "129",
        "title": "Sum Root to Leaf Numbers",
        "content": "<p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>\n\n<p>Each root-to-leaf path in the tree represents a number.</p>\n\n<ul>\n\t<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>\n</ul>\n\n<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>A <strong>leaf</strong> node is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 25\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.\nThe root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\nTherefore, sum = 12 + 13 = <code>25</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,9,0,5,1]\n<strong>Output:</strong> 1026\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.\nThe root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.\nThe root-to-leaf path <code>4-&gt;0</code> represents the number 40.\nTherefore, sum = 495 + 491 + 40 = <code>1026</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>The depth of the tree will not exceed <code>10</code>.</li>\n</ul>\n",
        "likes": 8352,
        "dislikes": 146,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 1079291, \"totalSubmissionRaw\": 1583400, \"acRate\": \"68.2%\"}",
        "similarQuestions": "[{\"title\": \"Path Sum\", \"titleSlug\": \"path-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Maximum Path Sum\", \"titleSlug\": \"binary-tree-maximum-path-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Smallest String Starting From Leaf\", \"titleSlug\": \"smallest-string-starting-from-leaf\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "130",
        "questionFrontendId": "130",
        "title": "Surrounded Regions",
        "content": "<p>You are given an <code>m x n</code> matrix <code>board</code> containing <strong>letters</strong> <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <strong>capture regions</strong> that are <strong>surrounded</strong>:</p>\n\n<ul>\n\t<li><strong>Connect</strong>: A cell is connected to adjacent cells horizontally or vertically.</li>\n\t<li><strong>Region</strong>: To form a region <strong>connect every</strong> <code>&#39;O&#39;</code> cell.</li>\n\t<li><strong>Surround</strong>: The region is surrounded with <code>&#39;X&#39;</code> cells if you can <strong>connect the region </strong>with <code>&#39;X&#39;</code> cells and none of the region cells are on the edge of the <code>board</code>.</li>\n</ul>\n\n<p>To capture a <strong>surrounded region</strong>, replace all <code>&#39;O&#39;</code>s with <code>&#39;X&#39;</code>s <strong>in-place</strong> within the original board. You do not need to return anything.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>\n\n<p><strong>Explanation:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\" style=\"width: 367px; height: 158px;\" />\n<p>In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">board = [[&quot;X&quot;]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;X&quot;]]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>\n</ul>\n",
        "likes": 9147,
        "dislikes": 2051,
        "stats": "{\"totalAccepted\": \"918.2K\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 918248, \"totalSubmissionRaw\": 2167556, \"acRate\": \"42.4%\"}",
        "similarQuestions": "[{\"title\": \"Number of Islands\", \"titleSlug\": \"number-of-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Union Find"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/surrounded-regions/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "131",
        "questionFrontendId": "131",
        "title": "Palindrome Partitioning",
        "content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n",
        "likes": 13438,
        "dislikes": 536,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 1083404, \"totalSubmissionRaw\": 1512232, \"acRate\": \"71.6%\"}",
        "similarQuestions": "[{\"title\": \"Palindrome Partitioning II\", \"titleSlug\": \"palindrome-partitioning-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Palindrome Partitioning IV\", \"titleSlug\": \"palindrome-partitioning-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Non-overlapping Palindrome Substrings\", \"titleSlug\": \"maximum-number-of-non-overlapping-palindrome-substrings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/palindrome-partitioning/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "132",
        "questionFrontendId": "132",
        "title": "Palindrome Partitioning II",
        "content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\">palindrome</span>.</p>\n\n<p>Return <em>the <strong>minimum</strong> cuts needed for a palindrome partitioning of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
        "likes": 5629,
        "dislikes": 143,
        "stats": "{\"totalAccepted\": \"330.2K\", \"totalSubmission\": \"943.4K\", \"totalAcceptedRaw\": 330158, \"totalSubmissionRaw\": 943377, \"acRate\": \"35.0%\"}",
        "similarQuestions": "[{\"title\": \"Palindrome Partitioning\", \"titleSlug\": \"palindrome-partitioning\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Partitioning IV\", \"titleSlug\": \"palindrome-partitioning-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Non-overlapping Palindrome Substrings\", \"titleSlug\": \"maximum-number-of-non-overlapping-palindrome-substrings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Great Partitions\", \"titleSlug\": \"number-of-great-partitions\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/palindrome-partitioning-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "133",
        "questionFrontendId": "133",
        "title": "Clone Graph",
        "content": "<p>Given a reference of a node in a <strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong> undirected graph.</p>\n\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.</p>\n\n<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>\n\n<pre>\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Test case format:</strong></p>\n\n<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>\n\n<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>\n\n<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png\" style=\"width: 454px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]\n<strong>Explanation:</strong> There are 4 nodes in the graph.\n1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph.png\" style=\"width: 163px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[]]\n<strong>Output:</strong> [[]]\n<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> adjList = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> This an empty graph, it does not have any nodes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>Node.val</code> is unique for each node.</li>\n\t<li>There are no repeated edges and no self-loops in the graph.</li>\n\t<li>The Graph is connected and all nodes can be visited starting from the given node.</li>\n</ul>\n",
        "likes": 9959,
        "dislikes": 4020,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1543501, \"totalSubmissionRaw\": 2504084, \"acRate\": \"61.6%\"}",
        "similarQuestions": "[{\"title\": \"Copy List with Random Pointer\", \"titleSlug\": \"copy-list-with-random-pointer\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Clone Binary Tree With Random Pointer\", \"titleSlug\": \"clone-binary-tree-with-random-pointer\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Clone N-ary Tree\", \"titleSlug\": \"clone-n-ary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Graph"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/clone-graph/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "134",
        "questionFrontendId": "134",
        "title": "Gas Station",
        "content": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p>\n\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p>\n\n<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == gas.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 12622,
        "dislikes": 1282,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 1063190, \"totalSubmissionRaw\": 2305704, \"acRate\": \"46.1%\"}",
        "similarQuestions": "[{\"title\": \"Maximize the Topmost Element After K Moves\", \"titleSlug\": \"maximize-the-topmost-element-after-k-moves\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/gas-station/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "135",
        "questionFrontendId": "135",
        "title": "Candy",
        "content": "<p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>\n\n<p>You are giving candies to these children subjected to the following requirements:</p>\n\n<ul>\n\t<li>Each child must have at least one candy.</li>\n\t<li>Children with a higher rating get more candies than their neighbors.</li>\n</ul>\n\n<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,0,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,2,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == ratings.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 8362,
        "dislikes": 741,
        "stats": "{\"totalAccepted\": \"727.4K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 727350, \"totalSubmissionRaw\": 1633919, \"acRate\": \"44.5%\"}",
        "similarQuestions": "[{\"title\": \"Minimize Maximum Value in a Grid\", \"titleSlug\": \"minimize-maximum-value-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Operations to Satisfy Conditions\", \"titleSlug\": \"minimum-number-of-operations-to-satisfy-conditions\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check if Grid Satisfies Conditions\", \"titleSlug\": \"check-if-grid-satisfies-conditions\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/candy/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "136",
        "questionFrontendId": "136",
        "title": "Single Number",
        "content": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [2,2,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [4,1,2,1,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">4</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n",
        "likes": 17402,
        "dislikes": 794,
        "stats": "{\"totalAccepted\": \"3.6M\", \"totalSubmission\": \"4.7M\", \"totalAcceptedRaw\": 3575660, \"totalSubmissionRaw\": 4731105, \"acRate\": \"75.6%\"}",
        "similarQuestions": "[{\"title\": \"Single Number II\", \"titleSlug\": \"single-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Single Number III\", \"titleSlug\": \"single-number-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Missing Number\", \"titleSlug\": \"missing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Difference\", \"titleSlug\": \"find-the-difference\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the XOR of Numbers Which Appear Twice\", \"titleSlug\": \"find-the-xor-of-numbers-which-appear-twice\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think about the XOR (^) operator's property."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/single-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "137",
        "questionFrontendId": "137",
        "title": "Single Number II",
        "content": "<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,3,2]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]\n<strong>Output:</strong> 99\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>\n</ul>\n",
        "likes": 8260,
        "dislikes": 717,
        "stats": "{\"totalAccepted\": \"718.2K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 718174, \"totalSubmissionRaw\": 1106939, \"acRate\": \"64.9%\"}",
        "similarQuestions": "[{\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Single Number III\", \"titleSlug\": \"single-number-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the XOR of Numbers Which Appear Twice\", \"titleSlug\": \"find-the-xor-of-numbers-which-appear-twice\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/single-number-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "138",
        "questionFrontendId": "138",
        "title": "Copy List with Random Pointer",
        "content": "<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n",
        "likes": 14628,
        "dislikes": 1579,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 1563177, \"totalSubmissionRaw\": 2609634, \"acRate\": \"59.9%\"}",
        "similarQuestions": "[{\"title\": \"Clone Graph\", \"titleSlug\": \"clone-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Clone Binary Tree With Random Pointer\", \"titleSlug\": \"clone-binary-tree-with-random-pointer\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Clone N-ary Tree\", \"titleSlug\": \"clone-n-ary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.",
          "You may want to use extra space to keep old_node ---> new_node mapping to prevent creating multiple copies of the same node.",
          "We can avoid using extra space for old_node ---> new_node mapping by tweaking the original linked list. Simply interweave the nodes of the old and copied list. For example:\r\nOld List: A --> B --> C --> D\r\nInterWeaved List: A --> A' --> B --> B' --> C --> C' --> D --> D'",
          "The interweaving is done using next</b> pointers and we can make use of interweaved structure to get the correct reference nodes for random</b> pointers."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/copy-list-with-random-pointer/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "139",
        "questionFrontendId": "139",
        "title": "Word Break",
        "content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 17859,
        "dislikes": 847,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 2009019, \"totalSubmissionRaw\": 4182767, \"acRate\": \"48.0%\"}",
        "similarQuestions": "[{\"title\": \"Word Break II\", \"titleSlug\": \"word-break-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Extra Characters in a String\", \"titleSlug\": \"extra-characters-in-a-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Trie"
          },
          {
            "name": "Memoization"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Breadth-First Search\n\n**Intuition**\n\nLet's imagine the indices of `s` as a graph. Each index can be thought of as a node, which represents building `s` up to the index.\n\nAdding a word to an existing string is like an edge between nodes. For a node `start`, we can move to node `end` if the substring of `s` between `start, end` exists in `wordDict`.\n\nFor example, let's say we have `s = \"leetcode\"` and `wordDict = [\"leet\", \"code\"]`. We are currently at node `4`, which implies that we have built `\"leet\"` (the first 4 characters of `s`). We can move to node `8`, because the substring of `s` with indices `[4, 8)` is `\"code\"`, which is in `wordDict`.\n\nWe start at node `0`, which represents the empty string. We want to reach node `s.length`, which implies that we have built the entire string. We can run a BFS to accomplish this traversal. If you're not familiar with BFS, check out the relevant [Explore Card](https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/).\n\nAt each node `start`, we iterate over all the nodes `end` that come after `start`. For each `end`, we check if the substring between `start, end` is in `wordDict`. If it is, we can add `end` to the queue.\n\nWe will first convert `wordDict` into a set so that we can perform the checks in constant time. We will also use a data structure `seen` to prevent us from visiting a node more than once.\n\n**Algorithm**\n\n1. Convert `wordDict` into a set `words`.\n2. Initialize a `queue` with `0` and a set `seen`.\n3. While the `queue` is not empty:\n    - Remove the first element, `start`.\n    - If `start == s.length`, return `true`.\n    - Iterate `end` from `start + 1` up to and including `s.length`. For each `end`, if `end` has not been visited yet,\n        - Check the substring starting at `start` and ending before `end`. If it is in `words`, add `end` to the queue and mark it in `seen`.\n4. Return `false` if the BFS finishes without reaching the final node.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/evkSf6sx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"evkSf6sx\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,\n\n* Time complexity: $$O(n^3 + m \\cdot k)$$\n\n    There are $$O(n)$$ nodes. Because of `seen`, we never visit a node more than once. At each node, we iterate over the nodes in front of the current node, of which there are $$O(n)$$. For each node `end`, we create a substring, which also costs $$O(n)$$.\n\n    Therefore, handling a node costs $$O(n^2)$$, so the BFS could cost up to $$O(n^3)$$. Finally, we also spent $$O(m \\cdot k)$$ to create the set `words`.\n\n* Space complexity: $$O(n + m \\cdot k)$$\n\n    We use $$O(n)$$ space for `queue` and `seen`. We use $$O(m \\cdot k)$$ space for the set `words`.\n    \n<br/>\n\n---\n\n### Approach 2: Top-Down Dynamic Programming \n\n**Intuition**\n\n> If you're not familiar with dynamic programming, we recommend checking out the [Dynamic Programming explore card](https://leetcode.com/explore/featured/card/dynamic-programming/). This problem is on the difficult side, so we will assume that readers are already familiar with the principles of DP.\n\nLet's have a function `dp` that returns a boolean indicating if it is possible to build `s` up to and including the index `i`.\n\nFor example, given `s = \"leetcode\"` and `wordDict = [\"leet\", \"code\"]`, `dp(3)` would return `true`. `s` up to index `3` is `\"leet\"`, and we can build `\"leet\"` using the words in `wordDict`. The answer to the problem would be `dp(s.length - 1)`, which represents if we can build `s`.\n\nThe base case of this function is when `i < 0`. This would represent an empty string, and we can always build an empty string by doing nothing. Therefore, `dp(i) = true` for `i < 0`.\n\nGiven an index `i`, we need a recurrence relation to determine if `dp(i)` is `true` or `false`. For `dp(i)` to be `true`, there are two requirements:\n\n1. First, there needs to be a `word` from `wordDict` that **ends** at index `i`. Given a `word`, the substring of `s` from indices `i - word.length + 1` up to and including `i` should match `word`. We can check every `word` for this.\n2. If we manage to find a `word` that **ends** at index `i`, we would need to add it on top of another string (since we are building `s` by joining words together one by one). We need to make sure that the string we are adding onto is also buildable. If we find a `word` that passes the first check, it means `word` would start at index `i - word.length + 1`. The index before that is `i - word.length`. To check if the string ending at that index is buildable, we can refer to `dp(i - word.length)`.\n\nThis gives us our recurrence relation:\n\n$$\\large{\\text{dp(i)} = \\text{any}(\\text{s}[\\text{i - word.length + 1, i}] == \\text{word \\&\\& dp(i - \\text{word.length})})}$$\n\nThat is, there exists any `word` that satisfies both of the listed conditions.\n\nWe can implement a recursive function `dp(i)` that implements the base cases and recurrence. We need to use memoization to avoid repeated computation.\n\n!?!../Documents/139.json:960,540!?!\n\n**Algorithm**\n\n1. Declare a data structure `memo` that stores the values of `dp` for each index.\n2. Create a function `dp(i)`:\n    - If `i < 0`, return `true`.\n    - If we already calculated `i`, return the value stored in `memo`.\n    - Iterate over `wordDict`. For each `word`:\n        - Check the substring of `s` ending at `i` with the same length as `word`. If the substring matches, and `dp(i - word.length)` is `true`, return `true`.\n    - If no `word` satisfying the criteria was found, return `false`.\n3. Return `dp(s.length - 1)`.\n\n**Implementation**\n\n> In Python, the <a href=\"https://docs.python.org/3/library/functools.html\" target=\"_blank\" rel=\"noopener noreferrer\">functools</a> module provides super handy tools that automatically memoize a function for us. We're going to use the `@cache` decorator in the Python implementation.\n>\n> In Java and C++, we will use an array `memo` to save values. `memo[i] = -1` if we haven't calculated yet, `memo[i] = 0` if `dp(i) = false`, and `memo[i] = 1` if `dp(i) = true`.\n\n<iframe src=\"https://leetcode.com/playground/4pvUY8Eg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4pvUY8Eg\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,\n\n* Time complexity: $$O(n \\cdot m \\cdot k)$$\n\n    There are $$n$$ states of `dp(i)`. Because of memoization, we only calculate each state once. To calculate a state, we iterate over $$m$$ words, and for each word perform some substring operations which costs $$O(k)$$. Therefore, calculating a state costs $$O(m \\cdot k)$$, and we need to calculate $$O(n)$$ states. \n\n* Space complexity: $$O(n)$$\n\n    The data structure we use for memoization and the recursion call stack can use up to $$O(n)$$ space.\n    \n<br/>\n\n---\n\n### Approach 3: Bottom-Up Dynamic Programming\n\n**Intuition**\n\nThe same algorithm can be implemented iteratively. Instead of using a function `dp(i)`, we will use an array `dp` where `dp[i]` represents the same thing that `dp(i)` did. We can use the same recurrence relation:\n\n$$\\large{\\text{dp[i]} = \\text{any}(\\text{s}[\\text{i - word.length + 1, i}] == \\text{word \\&\\& dp[i - \\text{word.length}]})}$$\n\nIn top-down, we started at the top (`s.length - 1`) and work our way down to the base cases. In bottom-up, we start at the bottom `(i = 0)` and work our way up to the top.\n\nBefore we check `dp[i - word.length]`, we should check if `i == word.length - 1`. This would mean that the current `word` we are placing to end at index `i` is the first word. `i - word.length` would be negative, so we need to separately check this case.\n\n**Algorithm**\n\n1. Initialize an array `dp` with the same length as `s` and all values initially set to `false`.\n2. Iterate `i` over the indices of `s`. At each `i`:\n    - Iterate over each `word` in `wordDict`:\n        - Check if `i == word.length - 1` or `dp[i - word.length] = true`.\n        - If so, and the substring of `s` ending at `i` with the same length as `word` matches, set `dp[i] = true` and `break`.\n3. Return `dp[s.length - 1]`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/EWiwhkJC/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"EWiwhkJC\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,\n\n* Time complexity: $$O(n \\cdot m \\cdot k)$$\n\n    The logic behind the time complexity is identical to the previous approach. It costs us $$O(m \\cdot k)$$ to calculate each state, and we calculate $$O(n)$$ states in total. \n\n* Space complexity: $$O(n)$$\n\n    We use an array `dp` of length $$n$$.\n    \n<br/>\n\n---\n\n### Approach 4: Trie Optimization \n\n**Intuition**\n\nIn the previous approach, we iterated over each state `i` and then calculated `dp[i]`. To calculate a given `dp[i]`, we did the following:\n\n- Iterate over every `word` in `wordDict`\n- Check if each `word` ended at the current index\n\nThis cost us $$O(m \\cdot k)$$. In the problem constraints, we can see that the maximum value of $$m \\cdot k$$ is `20,000`, so this is expensive. We can optimize the time it takes to calculate a given `dp[i]` by using a trie.\n\nA trie is a data structure that can be used to efficiently search for strings. If you are not familiar with tries, we highly recommend you read the official solution to [this problem](https://leetcode.com/problems/implement-trie-prefix-tree/solution) before proceeding with this approach.\n\nTo summarize, a trie is a tree where each node is labeled. Here, we label each node with a character. The path from the root to any node represents the string that is built by the nodes on the path. The root represents the empty string.\n\n<img src=\"../Figures/139/4.png\" width=\"960\"> <br>\n\nWe can start by building a trie from the words in `wordDict`. Each trie node will have an additional attribute `isWord` which indicates if the current node represents a word from `wordDict`. Then, we will calculate the same `dp` array as in the previous approach. We will calculate each state as follows:\n\n- First, check if `i == 0` (placing first word) or `dp[i - 1]` (we could build the string up to this point). If neither are true, move on to the next state `i + 1`.\n- Otherwise, we see if `dp[i]` can be `true`. Initialize a node `curr` at the `root` of the trie.\n- Start iterating with a variable `j` from index `i`. For each character `s[j]`, check if we can traverse the trie.\n- If we can't traverse the trie, it means no words exist starting at index `i` and ending at index `j` or beyond. We can break from the loop and move on to the next state `i + 1`.\n- If we can traverse the trie, we move to the child node. We check the child's `isWord` attribute. If it is `true`, it means there is a word in `wordDict` starting at index `i` and ending at index `j`. We set `dp[j] = true`.\n- We continue traversing the trie until we reach a dead end or `j` reaches the end of the string.\n\nThis allows us to handle each state in $$O(n)$$ instead of $$O(m \\cdot k)$$, which is a big improvement since $$n \\leq 300$$.\n\n**Algorithm**\n\n1. Build a trie from `wordDict`. Each node should also have an `isWord` attribute. Store the root of the trie in `root`.\n2. Initialize an array `dp` with the same length as `s` and all values initially set to `false`.\n3. Iterate `i` over the indices of `s`. At each `i`:\n    - Check if `i == 0` or `dp[i - 1] = true`. If not, continue to the next `i`.\n    - Set `curr = root`. Iterate `j` over the indices of `s`, starting from `i`. At each `j`,\n        - Get the character at index `j` as `c = s[j]`.\n        - If `c` is not in the children of `curr`, we can `break` from the loop.\n        - Otherwise, move `curr` to the child labeled `c`.\n        - If `curr.isWord`, set `dp[j] = true`.\n4. Return `dp[s.length - 1]`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/FhHxmwHE/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FhHxmwHE\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,\n\n* Time complexity: $$O(n^2 + m \\cdot k)$$\n\n    Building the trie involves iterating over all characters of all words. This costs $$O(m \\cdot k)$$.\n\n    Once we build the trie, we calculate `dp`. For each `i`, we iterate over all the indices after `i`. We have a basic nested for loop which costs $$O(n^2)$$ to handle all `dp[i]`.\n\n* Space complexity: $$O(n + m \\cdot k)$$\n\n    The `dp` array takes $$O(n)$$ space. The trie can have up to $$m \\cdot k$$ nodes in it.\n    \n<br/>\n\n---\n\n### Approach 5: A Different DP\n\n**Intuition**\n\n> In this approach, we will take a look at another way to implement the DP algorithm. Note that this approach is the one covered in the video.\n\nHere, we let `dp[i]` hold the answer to the question: \"is it possible to form `s` up to a length of `i`? To find the answer for each index, instead of iterating over the words in `wordDict` and checking if a `word` ends at the current index `i`, we will instead iterate over **all substrings that end before index `i`**. If we find one of these substrings is in `wordDict` **and** we can form the string prior to the substring, then `dp[i] = true`.\n\nThe reason we are checking for **before** index `i` is because we have slightly changed our `dp` definition here. In the previous problem, `i` represented the index of the last character. Here, `i` represents the length, so we are offset by one.\n\nBefore starting the DP, we first convert `wordsDict` to a set so that we can perform the checks in $O(1)$. The rest of the algorithm follows similarly to the previous approaches.\n\n**Algorithm**\n\n1. Convert `wordsDict` to a set `words`.\n2. Initialize an array `dp` of length `n + 1` with all values set to `false`.\n3. Iterate `i` from `1` until and including `n`. Here, `i` represents the length of the string starting from the beginning.\n    - Iterate `j` from `0` until `i`. Here, `j` represents the first index of the substring we are checking.\n    - If `dp[j]` is true AND the substring `s[j:i]` is in `words`, set `dp[i] = true` and break. Note that `s[j:i]` represents the substring starting at `j` and ending at `i - 1`.\n4. Return `dp[n]`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/eiTDAMA4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"eiTDAMA4\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,\n\n* Time complexity: $$O(n^3 + m \\cdot k)$$\n\n    First, we spend $$O(m \\cdot k)$$ to convert `wordDict` into a set. Then we have a nested loop over `n`, which iterates $$O(n^2)$$ times. For each iteration, we have a substring operation which could cost up to $$O(n)$$. Thus this nested loop costs $$O(n^3)$$.\n\n* Space complexity: $$O(n + m \\cdot k)$$\n\n    The `dp` array takes $$O(n)$$ space. The set `words` takes up $$O(m \\cdot k)$$ space.\n    \n<br/>\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/word-break/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "140",
        "questionFrontendId": "140",
        "title": "Word Break II",
        "content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n",
        "likes": 7362,
        "dislikes": 541,
        "stats": "{\"totalAccepted\": \"734.3K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 734292, \"totalSubmissionRaw\": 1380327, \"acRate\": \"53.2%\"}",
        "similarQuestions": "[{\"title\": \"Word Break\", \"titleSlug\": \"word-break\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Concatenated Words\", \"titleSlug\": \"concatenated-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Trie"
          },
          {
            "name": "Memoization"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe have a string `s` and a dictionary of strings `wordDict`. The task is to add spaces in `s` to construct valid sentences where each word is present in `wordDict` and return all possible valid sentences. The same word from the dictionary can be reused multiple times.\n\nThis problem is an extension of [Problem 139. Word Break I](https://leetcode.com/problems/word-break/description/), where the goal was to determine if a word could be segmented into other words from a given dictionary. In this problem, however, we need to find all possible ways to split the word into valid statements. To understand this problem, it is beneficial to be familiar with [Problem 139. Word Break I](https://leetcode.com/problems/word-break/description/) as well as [Problem 208. Implement Trie Prefix Tree](https://leetcode.com/problems/implement-trie-prefix-tree/), as those questions provide the foundational concepts and intuition necessary for solving this problem.\n\nHere, we will focus on the applications of recursion, dynamic programming, and tries, rather than on understanding their underlying mechanisms.\n\nTo gain an understanding of their underlying mechanisms, we suggest you check out these explore cards: \n1. [Backtracking Explore Card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/).\n2. [Dynamic Programming Explore Card](https://leetcode.com/explore/learn/card/dynamic-programming/).\n3. [Trie Explore Card](https://leetcode.com/explore/learn/card/trie/).\n\n---\n\n### Approach 1: Backtracking\n\n#### Intuition\n\nInitially, we might think of a brute-force approach where we systematically explore all possible ways to break the string into words from the dictionary. This leads us to the backtracking strategy, where we recursively try to form words from the string and add them to a current sentence if they are in the dictionary. If the current prefix doesn't lead to a valid solution, we backtrack by removing the last added word and trying the next possible word. This ensures we explore all possible segmentations of the string.\n\nAt each step, we consider all possible end indices for substrings starting from the current index. For each substring, we check if it exists in the dictionary. If the substring is a valid word, we append it to the current sentence and recursively call the function with the updated index, which is the end index of the substring plus one.\n\nIf we reach the end of the string, it means we have found a valid segmentation, and we can add the current sentence to the results. However, if we encounter a substring that is not a valid word, we backtrack by returning from that recursive call and trying the next possible end index.\n\nThe backtracking approach will be inefficient due to the large number of recursive calls, especially for longer strings. To increase efficiency, we will convert the word dictionary into a set for constant-time lookups. However, the overall time complexity remains high because we explore all possible partitions.\n\nThe process is visualized below:\n\n![backtrack](../Figures/140/backtrack.png)\n\n#### Algorithm\n\n**`wordBreak` Function:**\n- Convert the `wordDict` array into an unordered set `wordSet` for efficient lookups.\n- Initialize an empty array `results` to store valid sentences.\n- Initialize an empty string `currentSentence` to keep track of the sentence being constructed.\n- Call the `backtrack` function with the input string `s`, `wordSet`, `currentSentence`, `results`, and a starting index set to 0, the beginning of the input string.\n- Return `results`.\n\n**`backtrack` Function:**\n- Base Case: If the `startIndex` is equal to the length of the string, add the `currentSentence` to `results` and return as it means that `currentSentence` represents a valid sentence.\n- Iterate over possible `endIndex` values from `startIndex + 1` to the end of the string.\n    - Extract the substring `word` from `startIndex` to `endIndex - 1`.\n    - If `word` is found in `wordSet`:\n        - Store the current `currentSentence` in `originalSentence`.\n        - Append `word` to `currentSentence` (with a space if needed).\n        - Recursively call `backtrack` with the updated `currentSentence` and `endIndex`.\n        - Reset `currentSentence` to its original value (`originalSentence`) to backtrack and try the next `endIndex`.\n- Return from the `backtrack` function.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/izdRa3p9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"izdRa3p9\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.  \n\n- Time complexity: $O(n \\cdot 2^n)$\n\n    The algorithm explores all possible ways to break the string into words. In the worst case, where each character can be treated as a word, the recursion tree has $2^n$ leaf nodes, resulting in an exponential time complexity. For each leaf node, $O(n)$ work is performed, so the overall complexity is $O(n \\cdot 2^n)$.\n\n- Space complexity: $O(2^n)$\n\n    The recursion stack can grow up to a depth of $n$, where each recursive call consumes additional space for storing the current state. \n    \n    Since each position in the string can be a split point or not, and for $n$ positions, there are $2^n$ possible combinations of splits. Thus, in the worst case, each combination generates a different sentence that needs to be stored, leading to exponential space complexity.\n\n---\n\n### Approach 2: Dynamic Programming - Memoization\n\n#### Intuition\n\nWe can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.\n\nWe use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table).\n\nIf the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.\n\nBy memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases. \n\n#### Algorithm\n \n**`wordBreak` Function:**\n- Convert the `wordDict` array into an unordered set `wordSet` for efficient lookups.\n- Initialize an empty unordered map `memoization` to store the results of subproblems.\n- Call the `dfs` function with the input string `s`, `wordSet`, and `memoization`.\n\n**`dfs` Function:**\n- Check if the answer for the current `remainingStr`(the remaining part of the string to be processed) are already in `memoization`. If so, return them.\n- Base Case: If `remainingStr` is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string.\n- Initialize an empty array `results`.\n- Iterate from 1 to the length of `remainingStr`:\n    - Extract the substring `currentWord` from 0 to `i` to check if it is a valid word.\n    - If `currentWord` is found in `wordSet`:\n        - Recursively call `dfs` with `remainingStr.substr(i)`, `wordSet`, and `memoization`.\n        - Append `currentWord` and the recursive results to `results`(with a space if needed) to form valid sentences.\n- Store the `results` for `remainingStr` in `memoization`.\n- Return `results`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/Ri3aMwXd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Ri3aMwXd\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.  \n\n* Time complexity: $O(n \\cdot 2^n)$\n\n    While memoization avoids redundant computations, it does not change the overall number of subproblems that need to be solved. In the worst case, there are still unique $2^n$ possible substrings that need to be explored, leading to an exponential time complexity. For each subproblem, $O(n)$ work is performed, so the overall complexity is $O(n \\cdot 2^n)$.\n\n* Space complexity: $O(n \\cdot 2^n)$\n\n    The recursion stack can grow up to a depth of $n$, where each recursive call consumes additional space for storing the current state. \n\n    The memoization map needs to store the results for all possible substrings, which can be up to $2^n$ substrings of size $n$ in the worst case, resulting in an exponential space complexity.\n\n---\n\n### Approach 3: Dynamic Programming - Tabulation\n\n#### Intuition\n\nWhile memoization improves the backtracking approach, we might consider an alternative approach using dynamic programming principles. This leads us to the tabulation method, which builds a table (or map) of valid sentences for each starting index in the string. \n\nThe tabulation approach is often more efficient than backtracking and memoization in terms of time and space complexity because it avoids the overhead of recursive calls and stack usage. It also eliminates the need for a separate memoization map, as the table itself serves as the storage for the subproblem solutions.\n\nThe tabulation approach works in a bottom-up manner, iterating from the end of the string towards the beginning. At each step, we construct all possible sentences that can be formed starting from the current index by checking if substrings form valid words in the dictionary.\n\nIf a valid word is found, we combine it with the valid sentences formed from the remaining substring. This process continues until we reach the beginning of the string, building up the table of valid sentences for each starting index.\n\nThe key idea behind tabulation is that we ensure all subproblems are solved before they are needed, enabling the construction of complete solutions in an organized manner. By iterating from the end to the beginning of the string, we guarantee that the necessary subproblems have already been solved when we need them.\n\n#### Algorithm\n \n- Initialize an empty unordered map `dp` to store the results of subproblems.\n- Iterate from the end of the string to the beginning (`startIdx` from `s.size()` to 0):\n    - Initialize an empty array `validSentences` to store all valid sentences starting from that index. \n    - Iterate from `startIdx` to the end of the string (`endIdx`):\n        - Extract the substring `currentWord` from `startIdx` to `endIdx`.\n        - If `currentWord` is a valid word in `wordDict`:\n            - If `endIdx` is the last index, add `currentWord` to `validSentences`.\n            - Else, append `currentWord` to each sentence formed by the remaining substring (`sentencesFromNextIndex`) from `dp[endIdx + 1]`.\n    - Store `validSentences` in `dp[startIdx]`.\n- Return `dp[0]` (valid sentences formed from the entire string).\n\nThe algorithm is visualized below:\n\n!?!../Documents/140/tabulation.json:976,631!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/gWJckozB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gWJckozB\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.  \n\n* Time complexity: $O(n \\cdot 2^n)$\n\n    Similar to memoization, the tabulation approach still needs to explore all possible substrings, which can be up to $2^n$ in the worst case, leading to an exponential time complexity. $O(n)$ work is performed to explore each substring, so the overall complexity is $O(n \\cdot 2^n)$.\n\n* Space complexity: $O(n \\cdot 2^n)$\n\n    The dynamic programming table or map needs to store the valid sentences for all possible starting indices, which can be up to $2^n$ strings of size $n$ in the worst case, resulting in an exponential space complexity.\n\n---\n\n### Approach 4: Trie Optimization\n\n#### Intuition\n\nWhile the previous approaches focus on optimizing the search and computation process, we can also consider leveraging efficient data structures to enhance the word lookup process. This leads us to the trie-based approach, which uses a trie data structure to store the word dictionary, allowing efficient word lookup and prefix matching.\n\n> The trie, also known as a prefix tree, is a tree-based data structure where each node represents a character in a word, and the path from the root to a leaf node represents a complete word. This structure is particularly useful for problems involving word segmentation because it allows for efficient prefix matching.\n\nHere, we first build a trie from the dictionary words. Each word is represented as a path in the trie, where each node corresponds to a character in the word.\n\nBy using the trie, we can quickly determine whether a substring can form a valid word without having to perform linear searches or set lookups. This reduces the search space and improves the efficiency of the algorithm.\n\nIn this approach, instead of recursively exploring the remaining substring and using memoization, we iterate from the end of the input string to the beginning (in reverse order). For each starting index (`startIdx`), we attempt to find valid sentences that can be formed from that index by iterating through the string and checking if the current substring forms a valid word using the trie data structure.\nWhen a valid word is encountered in the trie, we append it to the list of valid sentences for the current starting index. If the current valid word is not the last word in the sentence, we combine it with the valid sentences formed from the next index (`endIdx + 1`), which are retrieved from the `dp` dictionary.\n\nThe valid sentences for each starting index are stored in the `dp` dictionary, ensuring that previously computed results are reused. By using tabulation and storing the valid sentences for each starting index, we avoid redundant computations and achieve significant time and space efficiency improvements compared to the standard backtracking method with memoization.\n\nThe trie-based approach offers advantages in terms of efficient word lookup and prefix matching, making it particularly suitable for problems involving word segmentation or string manipulation. However, it comes with the additional overhead of constructing and maintaining the trie data structure, which can be more memory-intensive for large dictionaries.\n\n#### Algorithm\n \n**Initialize TrieNode Structure**\n- Each TrieNode has two properties:\n - `isEnd`: A boolean value indicating if the node marks the end of a word.\n - `children`: An array of size 26 (for lowercase English letters) to store pointers to child nodes.\n- The constructor initializes `isEnd` to `false` and all elements in `children` to `null`.\n\n**Trie Class**\n- The Trie class has a `root` pointer of type `TrieNode`.\n- The constructor initializes the `root` with a new `TrieNode` object.\n- The `insert` function:\n - Takes a string `word` as input.\n - Starts from the `root` node.\n - For each character `c` in the `word`:\n   - Calculate the index corresponding to the character.\n   - If the child node at the calculated index doesn't exist, create a new `TrieNode` and assign it to that index.\n   - Move to the child node.\n - After processing all characters, mark the current node's `isEnd` as `true`.\n\n**wordBreak Function**\n- Create a `Trie` object.\n- Insert all words from `wordDict` into the trie using the `insert` function.\n- Initialize a map `dp` to store the results of subproblems.\n- Iterate from the end of the string `s` to the beginning (in reverse order).\n - For each starting index `startIdx`:\n   - Initialize a vector `validSentences` to store valid sentences starting from `startIdx`.\n   - Initialize a `current_node` pointer to the `root` of the trie.\n   - Iterate from `startIdx` to the end of the string.\n     - For each character `c` in the string:\n       - Calculate the index corresponding to `c`.\n       - Check if the child node at the calculated index exists in the trie.\n        - If the child node doesn't exist, break out of the inner loop. This means that the current substring cannot form a valid word, so there is no need to continue checking the remaining characters.\n       - Move to the child node.\n     - Check if the current node's `isEnd` is `true`, indicating a valid word.\n     - If a valid word is found:\n       - Extract the current word from the string using `substr`.\n       - If it's the last word in the sentence (`endIdx` is the last index):\n         - Add the current word to `validSentences`.\n       - If it's not the last word:\n         - Retrieve the valid sentences formed by the remaining substring from `dp[endIdx + 1]`.\n         - Combine the current word with each sentence and add it to `validSentences`.\n   - Store the `validSentences` for the current `startIdx` in `dp`.\n- Return the valid sentences stored in `dp[0]`, which represents the valid sentences formed from the entire string.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/YBoyT88T/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"YBoyT88T\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string. \n\n* Time complexity: $O(n \\cdot 2^n)$\n\n    Even though the trie-based approach uses an efficient data structure for word lookup, it still needs to explore all possible ways to break the string into words. In the worst case, there are $2^n$ unique possible partitions, leading to an exponential time complexity. $O(n)$ work is performed for each partition, so the overall complexity is $O(n \\cdot 2^n)$.\n\n* Space complexity: $O(n \\cdot 2^n)$\n\n    The trie data structure itself can have a maximum of $2^n$ nodes in the worst case, where each character in the string represents a separate word. Additionally, the tabulation map used in this approach can also store up to $2^n$ strings of size $n$, resulting in an overall exponential space complexity.\n\n---\n\n**Further Thoughts On Complexity Analysis:**\n\nThe complexity of this problem cannot be reduced from $n \\cdot 2^n$; the worst-case scenario will still be $(n \\cdot 2^n)$. However, using dynamic programming (DP) will make it a bit more efficient than backtracking overall because of the below test case.\n\nConsider the input `\"aaaaaa\"`, with `wordDict = [\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaa\"]`. \nEvery possible partition is a valid sentence, and there are $2^{n-1}$ such partitions. The algorithms cannot perform better than this since they must generate all valid sentences. The cost of iterating over cached results will be exponential, as every possible partition will be cached, resulting in the same runtime as regular backtracking. Likewise, the space complexity will also be $O(n \\cdot 2^n)$ for the same reason\u2014every partition is stored in memory.\n\nAnother way to explain why the worst-case complexity is $O(n \\cdot 2^n)$ for all the algorithms is that, given an array of length $n$, there are $n+1$ ways/intervals to partition it into two parts. Each interval has two choices: to split or not to split. In the worst case, we will have to check all possibilities, which results in a time complexity of $O(n \\cdot 2^{n+1})$, which simplifies to $O(n \\cdot 2^n)$. This analysis is extremely similar to palindrome partitioning.\n\nOverall, this question is interesting because of the nature of this complexity. In an interview setting, if an interviewer asks this question, the most expected solutions would be Backtracking and Trie, as they become natural choices for the conditions and outputs we need."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-break-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "141",
        "questionFrontendId": "141",
        "title": "Linked List Cycle",
        "content": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>\n\n<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
        "likes": 16343,
        "dislikes": 1491,
        "stats": "{\"totalAccepted\": \"3.8M\", \"totalSubmission\": \"7.3M\", \"totalAcceptedRaw\": 3806384, \"totalSubmissionRaw\": 7293138, \"acRate\": \"52.2%\"}",
        "similarQuestions": "[{\"title\": \"Linked List Cycle II\", \"titleSlug\": \"linked-list-cycle-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Happy Number\", \"titleSlug\": \"happy-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/linked-list-cycle/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "142",
        "questionFrontendId": "142",
        "title": "Linked List Cycle II",
        "content": "<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
        "likes": 14212,
        "dislikes": 1016,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 1589698, \"totalSubmissionRaw\": 2925819, \"acRate\": \"54.3%\"}",
        "similarQuestions": "[{\"title\": \"Linked List Cycle\", \"titleSlug\": \"linked-list-cycle\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/linked-list-cycle-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "143",
        "questionFrontendId": "143",
        "title": "Reorder List",
        "content": "<p>You are given the head of a singly linked-list. The list can be represented as:</p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>\n</pre>\n\n<p><em>Reorder the list to be on the following form:</em></p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;\n</pre>\n\n<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [1,4,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,5,2,4,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "likes": 11681,
        "dislikes": 449,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1212248, \"totalSubmissionRaw\": 1957310, \"acRate\": \"61.9%\"}",
        "similarQuestions": "[{\"title\": \"Delete the Middle Node of a Linked List\", \"titleSlug\": \"delete-the-middle-node-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Take K of Each Character From Left and Right\", \"titleSlug\": \"take-k-of-each-character-from-left-and-right\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/reorder-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "144",
        "questionFrontendId": "144",
        "title": "Binary Tree Preorder Traversal",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,2,3]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,2,4,5,6,7,3,8,9]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
        "likes": 8349,
        "dislikes": 220,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1975523, \"totalSubmissionRaw\": 2719074, \"acRate\": \"72.7%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Verify Preorder Sequence in Binary Search Tree\", \"titleSlug\": \"verify-preorder-sequence-in-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"N-ary Tree Preorder Traversal\", \"titleSlug\": \"n-ary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Kth Largest Sum in a Binary Tree\", \"titleSlug\": \"kth-largest-sum-in-a-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "145",
        "questionFrontendId": "145",
        "title": "Binary Tree Postorder Traversal",
        "content": "<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[3,2,1]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[4,6,7,5,2,9,8,3,1]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "likes": 7374,
        "dislikes": 214,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 1587210, \"totalSubmissionRaw\": 2110462, \"acRate\": \"75.2%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"N-ary Tree Postorder Traversal\", \"titleSlug\": \"n-ary-tree-postorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Fuel Cost to Report to the Capital\", \"titleSlug\": \"minimum-fuel-cost-to-report-to-the-capital\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nTo traverse a tree, we use two main strategies:\n\n- Breadth-First Search (BFS): This strategy involves scanning the tree level by level from the top down, visiting nodes at higher levels before those at lower levels.\n\n- Depth-First Search (DFS): This approach explores as far down a branch as possible before backtracking. It starts at the root, proceeds to a leaf, and then returns to explore other branches. DFS can be further categorized into:\n  - Preorder: Visit the root first, then the left subtree, followed by the right subtree.\n  - Inorder: Visit the left subtree first, then the root, and then the right subtree.\n  - Postorder: Visit the left subtree first, then the right subtree, and finally the root.\n\n![Tree Traversal Example](../Figures/145/traverse2.png)\n*Figure 1. Nodes are numbered in the order they are visited; refer to the sequence `1-2-3-4-5` to compare different traversal strategies.*\n\nFor a binary tree with the root `[1, null, 2, 3]`, the tree structure is as follows:\n\n```\n1\n \\\n  2\n /\n3\n```\n\nIn Postorder traversal, nodes are visited in the sequence: `3` (left subtree), `2` (right subtree), and finally `1` (root). Thus, the output for this input should be `[3, 2, 1]`.\n\n---\n\n### Approach 1: Recursive Postorder Traversal\n\n#### Intuition\n\n![recursion](../Figures/145/recursion.png)\n*Figure 2. Recursive DFS traversals.*\n\nIn this approach, we treat each node as the root of its subtree. We start by recursively traversing the left subtree. If the left child is not null, we continue exploring until the left subtree is fully traversed. Then, we move to the right subtree and repeat the process. After both subtrees are explored, we process the current node by adding its value to the result list.\n\nThe base case occurs when the current node is null, indicating no further subtree to explore. At this point, we simply return and backtrack.\n\n#### Algorithm\n\n1. Define a helper function `postorderTraversalHelper`:\n   - If `currentNode` is `null`, return to stop further recursion.\n   - Recursively call `postorderTraversalHelper` with `currentNode->left` to process the left subtree.\n   - Recursively call `postorderTraversalHelper` with `currentNode->right` to process the right subtree.\n   - Append `currentNode->val` to the `result` array to collect values in postorder.\n2. In the `postorderTraversal` function:\n   - Initialize an empty `result` array to store the postorder ordering of the nodes in`root`.\n   - Call `postorderTraversalHelper` with the root node and `result` to start the traversal.\n   - Return the `result` array containing the postorder traversal.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/X7v7GcVB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"X7v7GcVB\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the number of nodes.\n\n- Time complexity: $O(n)$\n\n    Each node is visited once during the traversal, so the time complexity is linear with respect to the number of nodes `n`.\n\n- Space complexity: $O(n)$\n\n    The space complexity is $O(n)$ due to the recursion stack. In the worst case (e.g., a completely unbalanced tree), the recursion stack could hold all `n` nodes.\n\n---\n\n### Approach 2: Manipulating Preorder Traversal (Iterative Hack)\n\n#### Intuition\n\nLet's take a creative leap in this approach by exploiting the relationship between preorder and postorder traversals. In a standard preorder traversal, we visit the root node before we visit the left and right subtrees. However, postorder traversal requires us to visit the left and right subtrees before the root node.\n\nWe can adapt the preorder traversal by visiting nodes in the order of root, right subtree, and then left subtree. Reversing the resulting list from this modified preorder traversal gives us the correct postorder sequence.\n\nWe use a stack to traverse the tree iteratively, starting with the root node. We push the current node onto the stack and add its value to the result list. Instead of moving to the left child, we move to the right child. If there's no right child, we pop a node from the stack and move to its left child. This approach processes the right subtree before the left subtree, aligning with the modified preorder traversal.\n\nAfter traversing the entire tree, we reverse the result list to get the postorder sequence: left subtree, right subtree, root.\n\n#### Algorithm\n \n1. Initialize an empty `result` list to store the traversal result, a `traversalStack` for nodes, and set `currentNode` to `root`.\n2. While `currentNode` is not `null` or `traversalStack` is not empty:\n   - If `currentNode` is not `null`, add `currentNode->val` to the `result` list before processing its children.\n   - Push `currentNode` onto the `traversalStack` to revisit it later.\n   - Move `currentNode` to `currentNode->right` to continue traversal in the right subtree.\n   - If `currentNode` is `null`, pop the top node from `traversalStack` and set it to `currentNode`.\n   - Move `currentNode` to `currentNode->left` to process the left subtree.\n3. Reverse the `result` list to correct the order from preorder to postorder.\n4. Return the `result` list with postorder traversal values.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/5wrszGxT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"5wrszGxT\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the number of nodes. \n\n* Time complexity: $O(n)$\n\n    Each node is processed a constant number of times (essentially twice), so the time complexity remains linear with respect to `n`.\n\n* Space complexity: $O(n)$\n\n    The space complexity is $O(2n) = O(n)$ due to the stack used for traversing the tree nodes. This stack could hold up to `n` nodes in the worst case. \n\n---\n\n### Approach 3: Two Stack Postorder Traversal (Iterative)\n\n#### Intuition\n\nInstead of relying on hacks and tricks, this time we will build on the idea that we need to control the order in which nodes are processed to achieve postorder traversal.  \n\nTo achieve postorder traversal without recursion, we use two stacks to control the node processing order systematically.\n\nFirst, we push the root node onto the first stack. This stack simulates the recursive traversal of the tree. To process nodes in postorder (left-right-root), we need a second stack to reverse the order. As we pop nodes from the first stack, we push them onto the second stack. This reversal ensures that nodes are processed in the correct order.\n\nAfter all nodes are transferred to the second stack, popping from it gives us the nodes in postorder sequence. This method efficiently achieves the desired traversal order by leveraging the two stacks to manage the processing sequence without needing a final reversal step.\n\nIn summary, the two-stack approach uses the first stack for tree traversal and the second stack to reverse the order, resulting in a postorder traversal. Despite initially seeming like a manipulation of preorder traversal, the final order of nodes from the second stack aligns with postorder traversal.\n\n#### Algorithm\n \n1. Initialize an empty `result` list, and create `mainStack` and `pathStack` for nodes.\n2. Check if `root` is `null`; if so, return `result` immediately, indicating there are no nodes to process.\n3. Push `root` onto `mainStack` to start the traversal.\n4. While `mainStack` is not empty:\n   - Peek at the top of `mainStack` to examine the current node.\n   - If the top of `pathStack` is the same as the top of `mainStack`, add `root->val` to the `result` list.\n   - Pop the top node from both `mainStack` and `pathStack` after processing.\n   - Otherwise, push the current node onto `pathStack`.\n   - Push `root->right` and `root->left` onto `mainStack` if they exist to process their children.\n5. Return the `result` list containing postorder traversal values.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/GkvWqGqp/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GkvWqGqp\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the number of nodes. \n\n* Time complexity: $O(n)$\n\n    Each node is processed a constant number of times (once when pushed to the first stack and once when popped to the second stack), so the time complexity is linear with respect to `n`.\n\n* Space complexity: $O(n)$\n\n    The space complexity is $O(n)$ due to the use of two stacks. Each stack can hold up to `n` nodes in the worst case.\n\n---\n\n### Approach 4: Single Stack Postorder Traversal (Iterative)\n\n#### Intuition\n\nAfter exploring the two-stack approach, we might seek to optimize further by reducing space complexity. While two stacks effectively manage traversal order, they double our space usage. Instead, we can use a single stack combined with a `previousNode` pointer to track the traversal.\n\nWe start by pushing nodes onto the stack while traversing left, similar to inorder traversal. In postorder traversal, we must process each node after its right subtree. To manage this, the `previousNode` pointer helps remember the last processed node.\n\nWhen a node is reached on the stack, we first check if it has an unvisited right child. If so, we move to that right child since we can't process the current node until after its right subtree. If the node has no right child or its right child has already been processed (indicated by `previousNode`), we process the node by popping it from the stack and adding its value to the result list, then update `previousNode` to this node.\n\n#### Algorithm\n \n1. Initialize an empty `result` list, set `previousNode` to `null`, and initialize `traversalStack`.\n2. Check if `root` is `null`; if so, return `result` immediately, indicating there are no nodes to process.\n3. While `root` is not `null` or `traversalStack` is not empty:\n   - If `root` is not `null`, push `root` onto `traversalStack`.\n   - Move `root` to `root->left` to process the left subtree.\n   - If `root` is `null`, peek at the top of `traversalStack`.\n   - If `root->right` is `null` or `root->right` equals `previousNode`, add `root->val` to `result`.\n   - Pop `root` from `traversalStack`, set `previousNode` to `root`, and set `root` to `null`.\n   - If `root->right` is not `null`, move `root` to `root->right` to continue the traversal.\n4. Return the `result` list containing postorder traversal values.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/PMTa9tEv/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PMTa9tEv\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the number of nodes.\n\n* Time complexity: $O(n)$\n\n    Each node is processed a constant number of times. The stack operations and pointer manipulations also contribute to a linear time complexity with respect to `n`.\n\n* Space complexity: $O(n)$\n\n    Although this approach uses only a single stack, in the worst case, the stack can still hold up to `n` nodes, so the space complexity remains $O(n)$. However, this approach optimizes the space usage compared to using two stacks.\n\n---\n\n### Approach 5: Morris Traversal (No stack)\n\n#### Intuition\n\nAll the approaches so far have been using some auxiliary space. To optimize for space complexity, we can use a traversal algorithm called Morris traversal. In Morris traversal, the tree structure is temporarily modified to create temporary links that simulate the effect of a stack or recursion. As a result, there is no overhead from additional data structures and the space complexity is constant. This traversal is tricky to understand at first, but the high level idea is to link each predecessor back to the current node, which allows us to trace back to the top of the tree. We encourage you to simulate the traversal on a piece of paper to get a stronger understanding.\n\nIn setting up Morris traversal, we introduce a `dummyNode` with a value that is not part of the original tree and link it to the root. Our traversal begins with this dummyNode, treating it as the new root of the tree.\n\nFor each node, we look for its in-order predecessor, the rightmost node in its left subtree. We do this so that the in-order predecessor can be used to create a temporary link back to the current node, simulating the recursive call stack.\n- If the current node has a left child, we find the rightmost node in the left subtree. This rightmost node is the in-order predecessor.\n- We then create a temporary link from this predecessor to the current node by setting its right pointer to the current node.\n\nIf the predecessor\u2019s right pointer is `null`, set it to point to the current node and move to the left child. This simulates the recursive call by allowing us to return to the current node after processing the left subtree.\n\nWhen a node\u2019s predecessor\u2019s right pointer points back to the current node, it indicates the left subtree is processed. Process the current node and reverse the temporary link to restore the tree\u2019s structure.\n\nFinally, move to the right child and continue the traversal.\n\nMorris traversal operates in $O(n)$ time because finding the predecessor is not done for every node but only for nodes with a valid left child.\n\n> Note: Morris traversal may be a surprise topic in interviews. It\u2019s useful to know but not always the main focus; prioritize understanding basic traversal methods first.\n\n#### Algorithm\n \n1. Initialize an empty `result` list and create a dummy node with the value `-1`. Set `dummyNode->left` to `root` and update `root` to `dummyNode`.\n2. Check if `root` is `null`; if so, return `result` immediately, indicating there are no nodes to process.\n3. While `root` is not `null`:\n   - If `root->left` is not `null`, find the rightmost node (predecessor) in the `root->left` subtree.\n   - If the right child of the predecessor is `null`, set the right child to `root` and move `root` to `root->left`.\n   - If the right child of the predecessor is `root`, perform reverse traversal of the `root->left` subtree and add values to `result`.\n   - Reverse the subtree back to its original state by restoring pointers.\n   - Remove the temporary link from the predecessor to `root` and move `root` to `root->right`.\n   - If `root->left` is `null`, move `root` to `root->right`.\n4. Return the `result` list containing postorder traversal values.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/XKjo3KQc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XKjo3KQc\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the number of nodes.\n\n* Time complexity: $O(n)$\n\n    Each node is visited a constant number of times, and the traversal through the tree is linear in terms of `n`.\n\n* Space complexity: $O(1)$\n\n    The Morris Traversal technique uses no extra space beyond the pointers used for traversal. The temporary modifications to the tree structure are reversed before the traversal ends, so the space complexity is constant.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "146",
        "questionFrontendId": "146",
        "title": "LRU Cache",
        "content": "<p>Design a data structure that follows the constraints of a <strong><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a></strong>.</p>\n\n<p>Implement the <code>LRUCache</code> class:</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>\n\t<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>\n\t<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>\n</ul>\n\n<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>Output</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>Explanation</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>\n</ul>\n",
        "likes": 21674,
        "dislikes": 1121,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"4.6M\", \"totalAcceptedRaw\": 2043611, \"totalSubmissionRaw\": 4568131, \"acRate\": \"44.7%\"}",
        "similarQuestions": "[{\"title\": \"LFU Cache\", \"titleSlug\": \"lfu-cache\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Design In-Memory File System\", \"titleSlug\": \"design-in-memory-file-system\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Design Compressed String Iterator\", \"titleSlug\": \"design-compressed-string-iterator\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Design Most Recently Used Queue\", \"titleSlug\": \"design-most-recently-used-queue\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Linked List"
          },
          {
            "name": "Design"
          },
          {
            "name": "Doubly-Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/lru-cache/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "147",
        "questionFrontendId": "147",
        "title": "Insertion Sort List",
        "content": "<p>Given the <code>head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list&#39;s head</em>.</p>\n\n<p>The steps of the <strong>insertion sort</strong> algorithm:</p>\n\n<ol>\n\t<li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>\n\t<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>\n\t<li>It repeats until no input elements remain.</li>\n</ol>\n\n<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" style=\"height:180px; width:300px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n",
        "likes": 3238,
        "dislikes": 873,
        "stats": "{\"totalAccepted\": \"420.1K\", \"totalSubmission\": \"749.7K\", \"totalAcceptedRaw\": 420063, \"totalSubmissionRaw\": 749712, \"acRate\": \"56.0%\"}",
        "similarQuestions": "[{\"title\": \"Sort List\", \"titleSlug\": \"sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Insert into a Sorted Circular Linked List\", \"titleSlug\": \"insert-into-a-sorted-circular-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Overview\n\n\n[Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) is an intuitive sorting algorithm, although it is much less efficient than the more advanced algorithms such as quicksort or merge sort.\n\nOften that we perform the sorting algorithm on an [Array](https://leetcode.com/explore/learn/card/fun-with-arrays) structure,\nthis problem though asks us to perform the insertion sort on a **linked list** data structure, which makes the implementation a bit challenging.\n\nIn this article, we will present some tricks to manipulate the linked list, which would help us to simplify the logics of implementation.\n\n\n---\n\n### Approach 1: Insertion Sort\n\n#### Intuition\n\nLet us first review the idea of insertion sort algorithm, which can be broke down into the following steps:\n\n- First of all, we create an empty list which would be used to hold the results of sorting.\n\n- We then iterate through each element in the _input_ list. For each element, we need to find a proper position in the resulting list to insert the element, so that the order of the resulting list is maintained.\n\n- As one can see, once the iteration in the above step terminates, we will obtain the resulting list where the elements are _ordered_.\n\nNow, let us walk through a simple example, by applying the above intuition.\n\nGiven the input list `input=[4, 3, 5]`, we have initially an empty resulting list `result=[]`.\n\n- We then iterate over the input list. For the first element `4`, we need to find a proper position in the resulting list to place it.\nSince the resulting list is still empty, we then simply _append_ it to the resulting list, _i.e._ `result=[4]`.\n\n![step 1](../Figures/147/147_linked_list_step_1.png)\n\n- Now for the second element (_i.e._ `3`) in the input list, similarly we need to insert it properly into the resulting list.\nAs one can see, we need to insert it right before the element `4`.\nAs a result, the resulting list becomes `[3, 4]`.\n\n![step 2](../Figures/147/147_linked_list_step_2.png)\n\n- Finally, for the last element (_i.e._ `5`) in the input list, as it turns out, the proper position to place it is the _tail_ of the resulting list.\nWith this last iteration, we obtain a _sorted_ list as `result=[3, 4, 5]`.\n\n![step 3](../Figures/147/147_linked_list_step_3.png)\n\n\n#### Algorithm\n\nTo translate the above intuition into the implementation, we applied two **tricks**.\n\n>The first trick is that we will create a `dummy` (`pseudo_head`) node which serves as a pointer pointing to the resulting list.\n\nMore precisely, this node facilitates us to always get a _hold_ on the resulting list, especially when we need to insert a new element to the head of the resulting list.\nOne will see later in more details how it can greatly simplify the logic.\n\nIn a _singly-linked list_, each node has only one pointer that points to the next node.\nIf we would like to insert a new node (say `B`) before certain node (say `A`), we need to know the node (say `C`) that is currently before the node `A`, _i.e._ `C -> A`.\nWith the reference in the node `C`, we could now insert the new node, _i.e._ `C -> B -> A`.\n\nGiven the above insight, in order to insert a new element into a singly-linked list, we apply another trick.\n\n>The idea is that we use a _**pair of pointers**_ (namely `prev -> next`) which serve as place-holders to guard the position where in-between we would insert a new element (_i.e._ `prev -> new_node -> next`).\n\nWith the same example before, _i.e._ `input=[4, 3, 5]`, we illustrate what the above helper pointers look like at the moment of insertion, in the following graph:\n\n![pointers](../Figures/147/147_pointers.png)\n\n#### Implementation\n\nHere are some sample implementations based on the above ideas:\n\n<iframe src=\"https://leetcode.com/playground/gDxDYr3y/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"gDxDYr3y\"></iframe>\n\n\n\n#### Complexity Analysis\n\nLet $N$ be the number of elements in the input list.\n\n- Time Complexity: $\\mathcal{O}(N^2)$\n\n    - First of all, we run an iteration over the input list.\n\n    - At each iteration, we insert an element into the resulting list. In the worst case where the position to insert is the tail of the list, we have to walk through the entire resulting list.\n\n    - As a result, the total steps that we need to walk in the worst case would be $\\sum_{i=1}^{N} i = \\frac{N(N+1)}{2}$.\n\n    - To sum up, the overall time complexity of the algorithm is $\\mathcal{O}(N^2)$.\n\n\n- Space Complexity: $\\mathcal{O}(1)$\n\n    - We used some pointers within the algorithm. However, their memory consumption is constant regardless of the input.\n\n    - **Note**, we did not create new nodes to hold the values of input list, but simply _reorder_ the existing nodes.\n\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/insertion-sort-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "148",
        "questionFrontendId": "148",
        "title": "Sort List",
        "content": "<p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px; height: 184px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>\n",
        "likes": 12228,
        "dislikes": 385,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 1002152, \"totalSubmissionRaw\": 1637134, \"acRate\": \"61.2%\"}",
        "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sort Colors\", \"titleSlug\": \"sort-colors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Insertion Sort List\", \"titleSlug\": \"insertion-sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sort Linked List Already Sorted Using Absolute Values\", \"titleSlug\": \"sort-linked-list-already-sorted-using-absolute-values\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Merge Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sort-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "149",
        "questionFrontendId": "149",
        "title": "Max Points on a Line",
        "content": "<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[2,2],[3,3]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 300</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>All the <code>points</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 4335,
        "dislikes": 542,
        "stats": "{\"totalAccepted\": \"454.5K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 454470, \"totalSubmissionRaw\": 1587399, \"acRate\": \"28.6%\"}",
        "similarQuestions": "[{\"title\": \"Line Reflection\", \"titleSlug\": \"line-reflection\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Lines to Cover Points\", \"titleSlug\": \"minimum-number-of-lines-to-cover-points\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Lines to Represent a Line Chart\", \"titleSlug\": \"minimum-lines-to-represent-a-line-chart\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Special Subsequences\", \"titleSlug\": \"count-special-subsequences\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "Geometry"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/max-points-on-a-line/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "150",
        "questionFrontendId": "150",
        "title": "Evaluate Reverse Polish Notation",
        "content": "<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\">Reverse Polish Notation</a>.</p>\n\n<p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li>Each operand may be an integer or another expression.</li>\n\t<li>The division between two integers always <strong>truncates toward zero</strong>.</li>\n\t<li>There will not be any division by zero.</li>\n\t<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>\n\t<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> ((2 + 1) * 3) = 9\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> (4 + (13 / 5)) = 6\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>Output:</strong> 22\n<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>\n</ul>\n",
        "likes": 8060,
        "dislikes": 1133,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1344711, \"totalSubmissionRaw\": 2471924, \"acRate\": \"54.4%\"}",
        "similarQuestions": "[{\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Expression Add Operators\", \"titleSlug\": \"expression-add-operators\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "151",
        "questionFrontendId": "151",
        "title": "Reverse Words in a String",
        "content": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n",
        "likes": 9331,
        "dislikes": 5339,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"4.4M\", \"totalAcceptedRaw\": 2259024, \"totalSubmissionRaw\": 4443016, \"acRate\": \"50.8%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Words in a String II\", \"titleSlug\": \"reverse-words-in-a-string-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/reverse-words-in-a-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "152",
        "questionFrontendId": "152",
        "title": "Maximum Product Subarray",
        "content": "<p>Given an integer array <code>nums</code>, find a <span data-keyword=\"subarray-nonempty\">subarray</span> that has the largest product, and return <em>the product</em>.</p>\n\n<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,-2,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [2,3] has the largest product 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,0,-1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>The product of any subarray of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n",
        "likes": 19288,
        "dislikes": 777,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"4.6M\", \"totalAcceptedRaw\": 1588046, \"totalSubmissionRaw\": 4579160, \"acRate\": \"34.7%\"}",
        "similarQuestions": "[{\"title\": \"Maximum Subarray\", \"titleSlug\": \"maximum-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Product of Array Except Self\", \"titleSlug\": \"product-of-array-except-self\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Product of Three Numbers\", \"titleSlug\": \"maximum-product-of-three-numbers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Subarray Product Less Than K\", \"titleSlug\": \"subarray-product-less-than-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximum-product-subarray/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "153",
        "questionFrontendId": "153",
        "title": "Find Minimum in Rotated Sorted Array",
        "content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n",
        "likes": 14084,
        "dislikes": 620,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"4.5M\", \"totalAcceptedRaw\": 2347410, \"totalSubmissionRaw\": 4484990, \"acRate\": \"52.3%\"}",
        "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array\", \"titleSlug\": \"search-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Minimum in Rotated Sorted Array II\", \"titleSlug\": \"find-minimum-in-rotated-sorted-array-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2].",
          "You can divide the search space into two and see which direction to go.\r\nCan you think of an algorithm which has O(logN) search complexity?",
          "<ol>\r\n<li>All the elements to the left of inflection point > first element of the array.</li>\r\n<li>All the elements to the right of inflection point < first element of the array.</li>\r\n<ol>"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "154",
        "questionFrontendId": "154",
        "title": "Find Minimum in Rotated Sorted Array II",
        "content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,3,5]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,2,0,1]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n\n<p>&nbsp;</p>\n",
        "likes": 4849,
        "dislikes": 504,
        "stats": "{\"totalAccepted\": \"519.3K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 519295, \"totalSubmissionRaw\": 1179028, \"acRate\": \"44.0%\"}",
        "similarQuestions": "[{\"title\": \"Find Minimum in Rotated Sorted Array\", \"titleSlug\": \"find-minimum-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "155",
        "questionFrontendId": "155",
        "title": "Min Stack",
        "content": "<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n\n<p>Implement the <code>MinStack</code> class:</p>\n\n<ul>\n\t<li><code>MinStack()</code> initializes the stack object.</li>\n\t<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>\n\t<li><code>void pop()</code> removes the element on the top of the stack.</li>\n\t<li><code>int top()</code> gets the top element of the stack.</li>\n\t<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>\n</ul>\n\n<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>Output</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>Explanation</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>\n</ul>\n",
        "likes": 14955,
        "dislikes": 940,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.8M\", \"totalAcceptedRaw\": 2122160, \"totalSubmissionRaw\": 3781300, \"acRate\": \"56.1%\"}",
        "similarQuestions": "[{\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Max Stack\", \"titleSlug\": \"max-stack\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Consider each node in the stack having a minimum value. (Credits to @aakarshmadhavan)"
        ],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Design"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/min-stack/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "156",
        "questionFrontendId": "156",
        "title": "Binary Tree Upside Down",
        "content": null,
        "likes": 283,
        "dislikes": 377,
        "stats": "{\"totalAccepted\": \"111K\", \"totalSubmission\": \"172.6K\", \"totalAcceptedRaw\": 110972, \"totalSubmissionRaw\": 172583, \"acRate\": \"64.3%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Linked List\", \"titleSlug\": \"reverse-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-upside-down/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "157",
        "questionFrontendId": "157",
        "title": "Read N Characters Given Read4",
        "content": null,
        "likes": 593,
        "dislikes": 3569,
        "stats": "{\"totalAccepted\": \"201.3K\", \"totalSubmission\": \"477.7K\", \"totalAcceptedRaw\": 201319, \"totalSubmissionRaw\": 477714, \"acRate\": \"42.1%\"}",
        "similarQuestions": "[{\"title\": \"Read N Characters Given read4 II - Call Multiple Times\", \"titleSlug\": \"read-n-characters-given-read4-ii-call-multiple-times\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Simulation"
          },
          {
            "name": "Interactive"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/read-n-characters-given-read4/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "158",
        "questionFrontendId": "158",
        "title": "Read N Characters Given read4 II - Call Multiple Times",
        "content": null,
        "likes": 877,
        "dislikes": 1814,
        "stats": "{\"totalAccepted\": \"190.7K\", \"totalSubmission\": \"445.6K\", \"totalAcceptedRaw\": 190694, \"totalSubmissionRaw\": 445569, \"acRate\": \"42.8%\"}",
        "similarQuestions": "[{\"title\": \"Read N Characters Given Read4\", \"titleSlug\": \"read-n-characters-given-read4\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Simulation"
          },
          {
            "name": "Interactive"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "159",
        "questionFrontendId": "159",
        "title": "Longest Substring with At Most Two Distinct Characters",
        "content": null,
        "likes": 2241,
        "dislikes": 37,
        "stats": "{\"totalAccepted\": \"279.9K\", \"totalSubmission\": \"498.2K\", \"totalAcceptedRaw\": 279870, \"totalSubmissionRaw\": 498211, \"acRate\": \"56.2%\"}",
        "similarQuestions": "[{\"title\": \"Longest Substring Without Repeating Characters\", \"titleSlug\": \"longest-substring-without-repeating-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Substring with At Most K Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-k-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Subarrays with K Different Integers\", \"titleSlug\": \"subarrays-with-k-different-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "160",
        "questionFrontendId": "160",
        "title": "Intersection of Two Linked Lists",
        "content": "<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>\n\n<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_statement.png\" style=\"width: 500px; height: 162px;\" />\n<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>\n\n<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>\n\n<ul>\n\t<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>\n\t<li><code>listA</code> - The first linked list.</li>\n\t<li><code>listB</code> - The second linked list.</li>\n\t<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>\n\t<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>\n</ul>\n\n<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"width: 500px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n<strong>Output:</strong> Intersected at &#39;8&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"width: 500px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>Output:</strong> Intersected at &#39;2&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png\" style=\"width: 300px; height: 189px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>Output:</strong> No intersection\n<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>\n\t<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;= m</code></li>\n\t<li><code>0 &lt;= skipB &lt;= n</code></li>\n\t<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>\n\t<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?",
        "likes": 15653,
        "dislikes": 1421,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.2M\", \"totalAcceptedRaw\": 1920452, \"totalSubmissionRaw\": 3170316, \"acRate\": \"60.6%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Index Sum of Two Lists\", \"titleSlug\": \"minimum-index-sum-of-two-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "161",
        "questionFrontendId": "161",
        "title": "One Edit Distance",
        "content": null,
        "likes": 1426,
        "dislikes": 192,
        "stats": "{\"totalAccepted\": \"223.4K\", \"totalSubmission\": \"648.4K\", \"totalAcceptedRaw\": 223441, \"totalSubmissionRaw\": 648354, \"acRate\": \"34.5%\"}",
        "similarQuestions": "[{\"title\": \"Edit Distance\", \"titleSlug\": \"edit-distance\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/one-edit-distance/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "162",
        "questionFrontendId": "162",
        "title": "Find Peak Element",
        "content": "<p>A peak element is an element that is strictly greater than its neighbors.</p>\n\n<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>\n\n<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>\n\n<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,5,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>\n</ul>\n",
        "likes": 13153,
        "dislikes": 4828,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"4M\", \"totalAcceptedRaw\": 1860143, \"totalSubmissionRaw\": 4008585, \"acRate\": \"46.4%\"}",
        "similarQuestions": "[{\"title\": \"Peak Index in a Mountain Array\", \"titleSlug\": \"peak-index-in-a-mountain-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find a Peak Element II\", \"titleSlug\": \"find-a-peak-element-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Pour Water Between Buckets to Make Water Levels Equal\", \"titleSlug\": \"pour-water-between-buckets-to-make-water-levels-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Hills and Valleys in an Array\", \"titleSlug\": \"count-hills-and-valleys-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Peaks\", \"titleSlug\": \"find-the-peaks\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/find-peak-element/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "163",
        "questionFrontendId": "163",
        "title": "Missing Ranges",
        "content": null,
        "likes": 1152,
        "dislikes": 3007,
        "stats": "{\"totalAccepted\": \"285.7K\", \"totalSubmission\": \"814.3K\", \"totalAcceptedRaw\": 285743, \"totalSubmissionRaw\": 814281, \"acRate\": \"35.1%\"}",
        "similarQuestions": "[{\"title\": \"Summary Ranges\", \"titleSlug\": \"summary-ranges\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Maximal Uncovered Ranges\", \"titleSlug\": \"find-maximal-uncovered-ranges\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/missing-ranges/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "164",
        "questionFrontendId": "164",
        "title": "Maximum Gap",
        "content": "<p>Given an integer array <code>nums</code>, return <em>the maximum difference between two successive elements in its sorted form</em>. If the array contains less than two elements, return <code>0</code>.</p>\n\n<p>You must write an algorithm that runs in linear time and uses linear extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,9,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 3410,
        "dislikes": 416,
        "stats": "{\"totalAccepted\": \"266.4K\", \"totalSubmission\": \"545.5K\", \"totalAcceptedRaw\": 266445, \"totalSubmissionRaw\": 545494, \"acRate\": \"48.8%\"}",
        "similarQuestions": "[{\"title\": \"Widest Vertical Area Between Two Points Containing No Points\", \"titleSlug\": \"widest-vertical-area-between-two-points-containing-no-points\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Consecutive Floors Without Special Floors\", \"titleSlug\": \"maximum-consecutive-floors-without-special-floors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Bucket Sort"
          },
          {
            "name": "Radix Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximum-gap/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "165",
        "questionFrontendId": "165",
        "title": "Compare Version Numbers",
        "content": "<p>Given two <strong>version strings</strong>, <code>version1</code> and <code>version2</code>, compare them. A version string consists of <strong>revisions</strong> separated by dots <code>&#39;.&#39;</code>. The <strong>value of the revision</strong> is its <strong>integer conversion</strong> ignoring leading zeros.</p>\n\n<p>To compare version strings, compare their revision values in <strong>left-to-right order</strong>. If one of the version strings has fewer revisions, treat the missing revision values as <code>0</code>.</p>\n\n<p>Return the following:</p>\n\n<ul>\n\t<li>If <code>version1 &lt; version2</code>, return -1.</li>\n\t<li>If <code>version1 &gt; version2</code>, return 1.</li>\n\t<li>Otherwise, return 0.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>version1&#39;s second revision is &quot;2&quot; and version2&#39;s second revision is &quot;10&quot;: 2 &lt; 10, so version1 &lt; version2.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Ignoring leading zeroes, both &quot;01&quot; and &quot;001&quot; represent the same integer &quot;1&quot;.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">version1 = &quot;1.0&quot;, version2 = &quot;1.0.0.0&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>version1 has less revisions, which means every missing revision are treated as &quot;0&quot;.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;only contain digits and <code>&#39;.&#39;</code>.</li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;<strong>are valid version numbers</strong>.</li>\n\t<li>All the given revisions in&nbsp;<code>version1</code> and <code>version2</code>&nbsp;can be stored in&nbsp;a&nbsp;<strong>32-bit integer</strong>.</li>\n</ul>\n",
        "likes": 2740,
        "dislikes": 2758,
        "stats": "{\"totalAccepted\": \"539.9K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 539877, \"totalSubmissionRaw\": 1282645, \"acRate\": \"42.1%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You can use two pointers for each version string to traverse them together while comparing the corresponding segments.",
          "Utilize the substring method to extract each version segment delimited by '.'. Ensure you're extracting the segments correctly by adjusting the start and end indices accordingly."
        ],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/compare-version-numbers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "166",
        "questionFrontendId": "166",
        "title": "Fraction to Recurring Decimal",
        "content": "<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n",
        "likes": 2154,
        "dislikes": 3723,
        "stats": "{\"totalAccepted\": \"251.8K\", \"totalSubmission\": \"967.7K\", \"totalAcceptedRaw\": 251751, \"totalSubmissionRaw\": 967691, \"acRate\": \"26.0%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [
          "No scary math, just apply elementary math knowledge. Still remember how to perform a <i>long division</i>?",
          "Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern?",
          "Notice that once the remainder starts repeating, so does the divided result.",
          "Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "167",
        "questionFrontendId": "167",
        "title": "Two Sum II - Input Array Is Sorted",
        "content": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n",
        "likes": 12424,
        "dislikes": 1465,
        "stats": "{\"totalAccepted\": \"2.6M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 2619451, \"totalSubmissionRaw\": 4153227, \"acRate\": \"63.1%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Two Sum IV - Input is a BST\", \"titleSlug\": \"two-sum-iv-input-is-a-bst\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Two Sum Less Than K\", \"titleSlug\": \"two-sum-less-than-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "168",
        "questionFrontendId": "168",
        "title": "Excel Sheet Column Title",
        "content": "<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 28\n<strong>Output:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 701\n<strong>Output:</strong> &quot;ZY&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnNumber &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 5782,
        "dislikes": 867,
        "stats": "{\"totalAccepted\": \"614.4K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 614449, \"totalSubmissionRaw\": 1425876, \"acRate\": \"43.1%\"}",
        "similarQuestions": "[{\"title\": \"Excel Sheet Column Number\", \"titleSlug\": \"excel-sheet-column-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Cells in a Range on an Excel Sheet\", \"titleSlug\": \"cells-in-a-range-on-an-excel-sheet\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Design Spreadsheet\", \"titleSlug\": \"design-spreadsheet\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Convert\n\n#### Intuition\n\nIn Excel, the columns are letters that correspond to numbers. We start with `A = 1`. Similarly, `2` corresponds to `B`  until `26` for `Z`. Once we run out of letters, we start appending them. `27` will correspond to `AA`, `28` for `AB`, and so on. In this problem, we are given the integer which is the column number and we need to return the corresponding letters for it.\n\nAt first glance, it might be tempting to say that these numbers are just base 26, but the catch is that in a base 26 system, the numbers would start from `0`. The mapping would be like below:\n\n![fig](../Figures/168/168A_resize.png)\n\nHowever, in the problem, we have the number starting from `1`, not `0`. But we can change them to process them like base 26 numbers. The important point to observe here is that every column title has the corresponding column number as a number in base 26 plus one. For example, let's convert the number `2002` to the letters `BXZ` by representing it as a number in base 26. Note that each part will have an extra `1` added to compensate for the fact that we are starting from `1` in our system. See the below example for a better understanding of the algorithm:\n\n`N = 2002` corresponds to `BXZ`.\n\nIn terms of base 26:\n\n$N = (B + 1) \\cdot 26^2 + (X + 1) \\cdot 26^1 + (Z + 1) * 26^0$\n\n$N = (1 + 1) \\cdot 676 + (23 + 1) \\cdot 26 + (25 + 1) \\cdot 1 = 2002$\n\nSteps to get the letters:\n\n1. Subtract `1` from `N`. Now, `N = 2001`. Take N modulo 26 and convert the result to the corresponding position in the alphabet. `2001 % 26 = 25`, which corresponds to `Z`, since we start with `A = 0`.\n2. Divide `N` by 26. We have $N = \\frac{2001}{26} = 76$.\n3. Repeat the process until `N = 0`. We subtract `1`, so now `N = 75`. Take it modulo 26: `75 % 26 = 23`. This corresponds to `X`.\n4. Divide `N` by 26. We have $N = \\frac{75}{26} = 2$.\n5. Subtract `1`, so now `N = 1`. Take it modulo 26: `1 % 26 = 1`. This corresponds to `B`.\n\nFinally, we are done, because $\\frac{N}{26} = 0$. The result is `BXZ`, the reverse order in which we found the letters.\n\n#### Algorithm\n\n1. Initialize an empty string `ans` which would store the column title.\n2. Do the following as long as `columnNumber` is greater than `0`:\n\n    1. Subtract `1` from the `columnNumber`\n    2. Find the character corresponding to `columnNumber % 26` and append it to the `ans` in the end.\n    3. Assign `columnNumber` to `columnNumber / 26`.\n3. Reverse the string `columnNumber` and return it.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/EhA2CHh8/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"EhA2CHh8\"></iframe>\n\n#### Complexity Analysis\n\nHere, $N$ is the column number given in the problem.\n\n* Time complexity: $O(\\log N)$\n\n  The number of operations would be equal to the number of while loop iterations. In each iteration, the number $N$ gets divided by $26$. Hence the time complexity would be $O(\\log{_{26}}{N})$. Note that the base of the logarithm is not relevant when it comes to big O, since all logarithms are related by a constant factor.\n\n* Space complexity: $O(1)$\n\n  We only need one string to store the output, but generally the space to store the output is not considered as part of space complexity and hence the space complexity is constant.\n  <br/>\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/excel-sheet-column-title/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "169",
        "questionFrontendId": "169",
        "title": "Majority Element",
        "content": "<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>\n\n<p>The majority element is the element that appears more than <code>&lfloor;n / 2&rfloor;</code> times. You may assume that the majority element always exists in the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?",
        "likes": 20711,
        "dislikes": 723,
        "stats": "{\"totalAccepted\": \"4.1M\", \"totalSubmission\": \"6.3M\", \"totalAcceptedRaw\": 4122409, \"totalSubmissionRaw\": 6286431, \"acRate\": \"65.6%\"}",
        "similarQuestions": "[{\"title\": \"Majority Element II\", \"titleSlug\": \"majority-element-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check If a Number Is Majority Element in a Sorted Array\", \"titleSlug\": \"check-if-a-number-is-majority-element-in-a-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Most Frequent Even Element\", \"titleSlug\": \"most-frequent-even-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Index of a Valid Split\", \"titleSlug\": \"minimum-index-of-a-valid-split\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Exceed Threshold Value I\", \"titleSlug\": \"minimum-operations-to-exceed-threshold-value-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Valid Pair of Adjacent Digits in String\", \"titleSlug\": \"find-valid-pair-of-adjacent-digits-in-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Counting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/majority-element/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "170",
        "questionFrontendId": "170",
        "title": "Two Sum III - Data structure design",
        "content": null,
        "likes": 688,
        "dislikes": 455,
        "stats": "{\"totalAccepted\": \"168.1K\", \"totalSubmission\": \"435.3K\", \"totalAcceptedRaw\": 168052, \"totalSubmissionRaw\": 435309, \"acRate\": \"38.6%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Unique Word Abbreviation\", \"titleSlug\": \"unique-word-abbreviation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum IV - Input is a BST\", \"titleSlug\": \"two-sum-iv-input-is-a-bst\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Design"
          },
          {
            "name": "Data Stream"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/two-sum-iii-data-structure-design/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "171",
        "questionFrontendId": "171",
        "title": "Excel Sheet Column Number",
        "content": "<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;A&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;AB&quot;\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;ZY&quot;\n<strong>Output:</strong> 701\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnTitle.length &lt;= 7</code></li>\n\t<li><code>columnTitle</code> consists only of uppercase English letters.</li>\n\t<li><code>columnTitle</code> is in the range <code>[&quot;A&quot;, &quot;FXSHRXW&quot;]</code>.</li>\n</ul>\n",
        "likes": 4904,
        "dislikes": 385,
        "stats": "{\"totalAccepted\": \"777.6K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 777612, \"totalSubmissionRaw\": 1188325, \"acRate\": \"65.4%\"}",
        "similarQuestions": "[{\"title\": \"Excel Sheet Column Title\", \"titleSlug\": \"excel-sheet-column-title\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Cells in a Range on an Excel Sheet\", \"titleSlug\": \"cells-in-a-range-on-an-excel-sheet\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/excel-sheet-column-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "172",
        "questionFrontendId": "172",
        "title": "Factorial Trailing Zeroes",
        "content": "<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n",
        "likes": 3342,
        "dislikes": 1973,
        "stats": "{\"totalAccepted\": \"545K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 544998, \"totalSubmissionRaw\": 1222246, \"acRate\": \"44.6%\"}",
        "similarQuestions": "[{\"title\": \"Number of Digit One\", \"titleSlug\": \"number-of-digit-one\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Preimage Size of Factorial Zeroes Function\", \"titleSlug\": \"preimage-size-of-factorial-zeroes-function\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Abbreviating the Product of a Range\", \"titleSlug\": \"abbreviating-the-product-of-a-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Trailing Zeros in a Cornered Path\", \"titleSlug\": \"maximum-trailing-zeros-in-a-cornered-path\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/factorial-trailing-zeroes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "173",
        "questionFrontendId": "173",
        "title": "Binary Search Tree Iterator",
        "content": "<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a></strong> of a binary search tree (BST):</p>\n\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>\n</ul>\n\n<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>\n\n<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>Explanation</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>\n</ul>\n",
        "likes": 8863,
        "dislikes": 540,
        "stats": "{\"totalAccepted\": \"936.2K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 936195, \"totalSubmissionRaw\": 1256553, \"acRate\": \"74.5%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Peeking Iterator\", \"titleSlug\": \"peeking-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST\", \"titleSlug\": \"inorder-successor-in-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Search Tree Iterator II\", \"titleSlug\": \"binary-search-tree-iterator-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Design"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          },
          {
            "name": "Iterator"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-search-tree-iterator/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "174",
        "questionFrontendId": "174",
        "title": "Dungeon Game",
        "content": "<p>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.</p>\n\n<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.</p>\n\n<p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight&#39;s health (represented by positive integers).</p>\n\n<p>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.</p>\n\n<p>Return <em>the knight&#39;s minimum initial health so that he can rescue the princess</em>.</p>\n\n<p><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dungeon = [[0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == dungeon.length</code></li>\n\t<li><code>n == dungeon[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 5969,
        "dislikes": 115,
        "stats": "{\"totalAccepted\": \"253.8K\", \"totalSubmission\": \"646.5K\", \"totalAcceptedRaw\": 253750, \"totalSubmissionRaw\": 646455, \"acRate\": \"39.3%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths\", \"titleSlug\": \"unique-paths\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Sum\", \"titleSlug\": \"minimum-path-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Cherry Pickup\", \"titleSlug\": \"cherry-pickup\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Health to Beat Game\", \"titleSlug\": \"minimum-health-to-beat-game\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if There is a Path With Equal Number of 0's And 1's\", \"titleSlug\": \"check-if-there-is-a-path-with-equal-number-of-0s-and-1s\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/dungeon-game/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "175",
        "questionFrontendId": "175",
        "title": "Combine Two Tables",
        "content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| personId    | int     |\n| lastName    | varchar |\n| firstName   | varchar |\n+-------------+---------+\npersonId is the primary key (column with unique values) for this table.\nThis table contains information about the ID of some persons and their first and last names.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Address</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| addressId   | int     |\n| personId    | int     |\n| city        | varchar |\n| state       | varchar |\n+-------------+---------+\naddressId is the primary key (column with unique values) for this table.\nEach row of this table contains information about the city and state of one person with ID = PersonId.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the first name, last name, city, and state of each person in the <code>Person</code> table. If the address of a <code>personId</code> is not present in the <code>Address</code> table, report <code>null</code> instead.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1        | Wang     | Allen     |\n| 2        | Alice    | Bob       |\n+----------+----------+-----------+\nAddress table:\n+-----------+----------+---------------+------------+\n| addressId | personId | city          | state      |\n+-----------+----------+---------------+------------+\n| 1         | 2        | New York City | New York   |\n| 2         | 3        | Leetcode      | California |\n+-----------+----------+---------------+------------+\n<strong>Output:</strong> \n+-----------+----------+---------------+----------+\n| firstName | lastName | city          | state    |\n+-----------+----------+---------------+----------+\n| Allen     | Wang     | Null          | Null     |\n| Bob       | Alice    | New York City | New York |\n+-----------+----------+---------------+----------+\n<strong>Explanation:</strong> \nThere is no address in the address table for the personId = 1 so we return null in their city and state.\naddressId = 1 contains information about the address of personId = 2.\n</pre>\n",
        "likes": 3701,
        "dislikes": 232,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 1239154, \"totalSubmissionRaw\": 1593849, \"acRate\": \"77.7%\"}",
        "similarQuestions": "[{\"title\": \"Employee Bonus\", \"titleSlug\": \"employee-bonus\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n# Solution\n---\n\n## pandas\n\n### Approach 1: Using `merge`\n\n**Visualization of approach 1**\n\n![fig](../Figures/175/175-1.png)\n\n#### Intuition\n\nLet's breakdown the steps given the following input DataFrames:\n\n`person`:\n<table>\n  <tr>\n    <th>personId</th>\n    <th>lastName</th>\n    <th>firstName</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>Wang</td>\n    <td>Allen</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>Alice</td>\n    <td>Bob</td>\n  </tr>\n</table>\n<br>\n\n`address`:\n<table>\n  <tr>\n    <th>addressId</th>\n    <th>personId</th>\n    <th>city</th>\n    <th>state</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>2</td>\n    <td>New York City</td>\n    <td>New York</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>3</td>\n    <td>Leetcode</td>\n    <td>California</td>\n  </tr>\n</table>\n<br>\n\n1. **Merging the DataFrames**\n   \n   ```python\n   result = pd.merge(person, address, on='personId', how='left')\n   ```\n   In this step, we are merging the `person` and `address` dataframes using a left join operation with the `pd.merge()` function. Here:\n   - `on='personId'` specifies that we are using the 'personId' column as the key for merging the data. This column is present in both dataframes, and it holds unique identifiers for the individuals.\n   - `how='left'` specifies that we are performing a left join, meaning all the records from the `person` dataframe (the left dataframe) will be retained, and the matching records from the `address` dataframe (the right dataframe) will be merged where the 'personId' values match. If a 'personId' from the `person` dataframe does not have a matching 'personId' in the `address` dataframe, the 'city' and 'state' columns for that record will contain Null values (representing missing data).\n\n<table>\n  <tr>\n    <th>personId</th>\n    <th>lastName</th>\n    <th>firstName</th>\n    <th>addressId</th>\n    <th>city</th>\n    <th>state</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>Wang</td>\n    <td>Allen</td>\n    <td>Null</td>\n    <td>Null</td>\n    <td>Null</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>Alice</td>\n    <td>Bob</td>\n    <td>1.0</td>\n    <td>New York City</td>\n    <td>New York</td>\n  </tr>\n</table>\n<br>\n\n2. **Selecting Relevant Columns**\n\n   ```python\n   result = result[['firstName', 'lastName', 'city', 'state']]\n   ```\n   In this step, we select only the columns that we are interested in for the final output. Since the merging operation can potentially bring in other columns from the `address` dataframe, we are explicitly selecting only the 'firstName', 'lastName', 'city', and 'state' columns to be in our final result. This helps in maintaining a clean and focused dataset which contains only the information we are interested in.\n\n<table>\n  <tr>\n    <th>firstName</th>\n    <th>lastName</th>\n    <th>city</th>\n    <th>state</th>\n  </tr>\n  <tr>\n    <td>Allen</td>\n    <td>Wang</td>\n    <td>Null</td>\n    <td>Null</td>\n  </tr>\n  <tr>\n    <td>Bob</td>\n    <td>Alice</td>\n    <td>New York City</td>\n    <td>New York</td>\n  </tr>\n</table>\n<br>\n\nIn summary, this script is taking two separate dataframes and merging them into a single dataframe where each row represents a person and contains their first name, last name, city, and state. This is done using the person's unique identifier to correctly match each person with their address. It's a common operation when you want to bring together information from different sources into a unified view.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/XRUKdTyk/shared\" frameBorder=\"0\" width=\"100%\" height=\"174\" name=\"XRUKdTyk\"></iframe>\n\n\n---\n\n## Database\n\n### Approach 1: Using `outer join`\n\n#### Intuition\n\nSince the *PersonId* in table **Address** is the foreign key of table **Person**, we can join these two tables to get the address information of a person.\n\nConsidering there might be no address information for every person, we should use `outer join` instead of the default `inner join`.\n\n#### Implementation\n\n> Note: For MySQL, an `outer join` is performed either using `left join` or `right join`. \n\n\n```sql\nselect FirstName, LastName, City, State\nfrom Person left join Address\non Person.PersonId = Address.PersonId\n;\n```\n\n> Note: Using the `where` clause to filter the records will fail if there is no address information for a person because it will not display the name information."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/combine-two-tables/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "176",
        "questionFrontendId": "176",
        "title": "Second Highest Salary",
        "content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains information about the salary of an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find&nbsp;the second highest <strong>distinct</strong> salary from the <code>Employee</code> table. If there is no second highest salary,&nbsp;return&nbsp;<code>null (return&nbsp;None in Pandas)</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n<strong>Output:</strong> \n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\n<strong>Output:</strong> \n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| null                |\n+---------------------+\n</pre>\n",
        "likes": 3801,
        "dislikes": 988,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1102284, \"totalSubmissionRaw\": 2547932, \"acRate\": \"43.3%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/second-highest-salary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "177",
        "questionFrontendId": "177",
        "title": "Nth Highest Salary",
        "content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains information about the salary of an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <code>n<sup>th</sup></code> highest <strong>distinct</strong> salary from the <code>Employee</code> table. If there are less than <code>n</code> distinct salaries, return&nbsp;<code>null</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\nn = 2\n<strong>Output:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\nn = 2\n<strong>Output:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| null                   |\n+------------------------+\n</pre>\n",
        "likes": 2090,
        "dislikes": 1086,
        "stats": "{\"totalAccepted\": \"474.5K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 474472, \"totalSubmissionRaw\": 1252847, \"acRate\": \"37.9%\"}",
        "similarQuestions": "[{\"title\": \"The Number of Users That Are Eligible for Discount\", \"titleSlug\": \"the-number-of-users-that-are-eligible-for-discount\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/nth-highest-salary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "178",
        "questionFrontendId": "178",
        "title": "Rank Scores",
        "content": "<p>Table: <code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:</p>\n\n<ul>\n\t<li>The scores should be ranked from the highest to the lowest.</li>\n\t<li>If there is a tie between two scores, both should have the same ranking.</li>\n\t<li>After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.</li>\n</ul>\n\n<p>Return the result table ordered by <code>score</code> in descending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nScores table:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>Output:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n",
        "likes": 2256,
        "dislikes": 283,
        "stats": "{\"totalAccepted\": \"476.8K\", \"totalSubmission\": \"735.9K\", \"totalAcceptedRaw\": 476771, \"totalSubmissionRaw\": 735889, \"acRate\": \"64.8%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rank-scores/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "179",
        "questionFrontendId": "179",
        "title": "Largest Number",
        "content": "<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p>\n\n<p>Since the result may be very large, so you need to return a string instead of an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2]\n<strong>Output:</strong> &quot;210&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,30,34,5,9]\n<strong>Output:</strong> &quot;9534330&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 9060,
        "dislikes": 770,
        "stats": "{\"totalAccepted\": \"705.4K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 705445, \"totalSubmissionRaw\": 1720448, \"acRate\": \"41.0%\"}",
        "similarQuestions": "[{\"title\": \"Smallest Value of the Rearranged Number\", \"titleSlug\": \"smallest-value-of-the-rearranged-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Key of the Numbers\", \"titleSlug\": \"find-the-key-of-the-numbers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview \n\nWe need to arrange a list of non-negative integers such that their concatenation results in the largest possible number. Return this largest number as a string.\n\nTo solve this, we use a custom comparator\u2014a function or object that defines how two elements are compared for sorting. It\u2019s used when the default comparison operations (like `<` or `>`) do not fit the requirements of a particular task. In this case, we want to compare numbers based on the result of their concatenation in two different orders.\n\nFirst, we convert each integer to a string. Then, we sort the array of strings.\n\nSorting the numbers in descending order might seem like a good idea, but it leads to issues when numbers share the same leading digit. For example, sorting `[9, 5, 34, 3, 30]` in descending order gives `\"9534303\"`, but the correct answer is `\"9534330\"`. The problem arises because `\"3\"` and `\"30\"` share the same leading digit. \n\nTo fix this, we compare the concatenated results of pairs of numbers. For example, given two numbers `a` and `b`, we compare `a + b` and `b + a` (where `+` denotes string concatenation). If `a + b` is larger, we place `a` before `b`. This ensures that the numbers are ordered correctly for the largest possible result.\n\nThe key is that this comparison ensures that the greedy approach of comparing pairs of numbers leads to the correct result. The difficult part is proving that this greedy logic always gives the correct answer.\n\n##### Proof of Correctness\n\nObjective: To ensure that our custom comparator for sorting numbers produces the largest possible concatenated number.\n\n1. Transitivity of the Comparator:\n\n    To verify the validity of the comparator, we need to prove that it is transitive. In other words, if number `A` should come before `B`, and `B` should come before `C`, then `A` must come before `C` in the final order.\n\n    We define the function:\n\n    $$\n    \\begin{aligned}\n        f(X) &= 10^{\\text{lg}(X) + 1}\n    \\end{aligned}\n    $$\n\n    where $\\text{lg}(X)$ denotes the logarithm base 10 of $X$. This function helps in determining the power of 10 needed to position `X` correctly when concatenating.\n\n2. Comparator Verification:\n\n    If concatenating `A` and `B` as `AB` is less than or equal to `BA`, we need to verify that:\n\n    $$\n    \\begin{aligned}\n        f(B)A + B &\\leq f(A)B + A \\\\\n        (f(B) - 1)A &\\leq (f(A) - 1)B \\\\\n        A &\\leq \\frac{B \\cdot (f(A) - 1)}{f(B) - 1}\n    \\end{aligned}\n    $$\n\n    Similarly, if `B` and `C` satisfy:\n\n    $$\n    \\begin{aligned}\n        BC &\\leq CB \\\\\n        (f(C) - 1)B &\\leq (f(B) - 1)C \\\\\n        B &\\leq \\frac{C \\cdot (f(B) - 1)}{f(C) - 1}\n    \\end{aligned}\n    $$\n\n3. By Combining These Inequalities:\n\n    $$\n    \\begin{aligned}\n        A &\\leq \\frac{C \\cdot (f(A) - 1)}{f(C) - 1} \\\\\n        (f(C) - 1)A &\\leq (f(A) - 1)C \\\\\n        f(C)A + C &\\leq f(A)C + A \\\\\n        AC &\\leq CA\n    \\end{aligned}\n    $$\n\n    This demonstrates that if `A` is before `B` and `B` is before `C`, then `A` must come before `C`, maintaining a consistent ordering.\n\n4. By Establishing the Consistency of the Comparator:\n\n    We confirm that sorting numbers with this comparator yields the largest concatenated number. For example, sorting `[3, 30, 34, 5, 9]` yields `[9, 5, 34, 3, 30]`, which concatenates to `\"9534330\"`, the largest possible number.\n\n---\n\n### Approach 1: Using Built-in Function  \n\n#### Intuition\n\nTo begin with, we need to determine the best order for the numbers to form the largest possible number when concatenated. We first convert each integer in the list to a string. This conversion allows us to compare different concatenated results. For instance, if we have the numbers `56` and `9`, converting them to strings allows us to compare `\"569\"` and `\"956\"`.\n\nNext, we use a custom sorting function to order these strings. This function compares two strings, `a` and `b`, by evaluating `a + b` against `b + a`. If `a + b` is greater, then `a` should come before `b` in the sorted list to maximize the final result.\n\nOnce sorted, we concatenate all the strings. If the first element in this sorted list is \"0\", it indicates that all numbers were zeros, so the largest number possible is \"0\". In this case, we return \"0\". If not, we return the concatenated result. \n\n#### Algorithm\n\n- Initialize `numStrings` as an array of strings to hold string representations of numbers.\n\n- Convert each integer in `nums` to a string and store it in `numStrings`.\n\n- Sort `numStrings` based on concatenated values:\n  - Use a lambda function to compare concatenated results (`a + b` and `b + a`).\n  - Ensure that the concatenation which forms a larger number determines the order.\n\n- Check if the largest number formed is \"0\":\n  - If the first element in `numStrings` is \"0\", return \"0\" (handles cases where all numbers are zero).\n\n- Concatenate all strings in `numStrings` to form the largest number.\n\n- Return the concatenated result as the largest number.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/me8hcMir/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"me8hcMir\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$\n\n    The most time-consuming operation is the sorting step, which uses a custom comparator. The sorting algorithm has a time complexity of $O(n \\log n)$. The conversion of numbers to strings and concatenation operations are linear with respect to the number of elements.\n\n- Space Complexity: $O(n + S)$\n\n    Additional space is used for storing the string representations of the numbers and the final concatenated result, which scales linearly with the size of the input array.\n\n    Some extra space is used when we sort an array of size $n$ in place. The space complexity of the sorting algorithm ($S$) depends on the programming language. The value of $S$ depends on the programming language and the sorting algorithm being used:\n    - In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O( \\log n )$\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$\n\n    Thus, the total space complexity of the algorithm is $O(n + S)$.\n\n---\n\n### Approach 2: Quick Sort\n\n#### Intuition\n\nQuick Sort uses a divide-and-conquer method to sort the numbers. We start by selecting a pivot and partitioning the list into two parts based on how each number compares with the pivot. Specifically, we compare concatenated results like `a + pivot` with `pivot + a`.\n\nWe recursively sort the two partitions and then combine them. This recursive sorting ensures that the entire list is ordered such that concatenating all numbers results in the largest possible number.\n\nAfter sorting, we concatenate the numbers. If the final string starts with '0', it means all numbers were zeros, so we return \"0\". Otherwise, we return the concatenated result. This approach efficiently sorts and merges numbers to achieve the desired outcome.\n\nEach of these approaches aims to sort the numbers in such a way that their concatenation produces the largest possible number. By using different sorting techniques and comparison methods, we can achieve the correct order efficiently.\n\n</br>\n \nLet\u2019s take the list `[3, 30, 34, 5, 9]`. To apply quick sort, we first select a pivot, such as `34`. We then partition the list so that numbers that produce a larger concatenated result with the pivot come before it, and those that produce a smaller result come after it.\n\nFor each number compared to `34`:\n- Compare `\"3\"` with `\"34\"`. Concatenate as `\"34\" + \"3\" = \"343\"` and `\"3\" + \"34\" = \"334\"`. Since `\"343\"` is greater, `\"3\"` is placed after `\"34\"`.\n- Compare `\"30\"` with `\"34\"`. Concatenate as `\"34\" + \"30\" = \"3430\"` and `\"30\" + \"34\" = \"3034\"`. Since `\"3430\"` is greater, `\"30\"` is placed after `\"34\"`.\n\nThe same process applies to `\"5\"` and `\"9\"`. The result of the partitioning places `\"9\"`, `\"5\"`, and `\"34\"` correctly relative to each other, but in the final list, we sort based on which numbers yield larger concatenated results when placed in various orders.\n\nAfter applying quick sort recursively to each partition, the list gets sorted to `[9, 5, 34, 3, 30]`. Concatenating these numbers results in `\"9534330\"`, which is the largest number possible.\n\n#### Algorithm\n\n- Call `quickSort(nums, 0, nums.size() - 1)` to sort the numbers in descending order based on their concatenated values.\n\n- `quickSort` function:\n  - If `left` is greater than or equal to `right`, return (base case: the array or sub-array is already sorted).\n  - Call `partition(nums, left, right)` to partition the array around a pivot and get the pivot index.\n  - Recursively call `quickSort` on the left sub-array (`left` to `pivotIndex - 1`).\n  - Recursively call `quickSort` on the right sub-array (`pivotIndex + 1` to `right`).\n\n- `partition` function:\n  - Choose the rightmost element as the pivot.\n  - Rearrange elements so that elements that, when concatenated with the pivot, form a larger number are moved to the left.\n  - Swap elements to place the pivot in its correct position.\n  - Return the pivot index.\n\n- `compare` function:\n  - Compare the concatenated strings of `firstNum` and `secondNum` to determine their order.\n\n- Concatenate the sorted numbers into a string to form the largest number.\n\n- Handle the edge case where the largest number is zero:\n  - Return \"0\" if the first character of the concatenated string is '0'.\n  - Otherwise, return the concatenated string.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/M4JEvsXx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"M4JEvsXx\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$ on average, $O(n^2)$ in the worst case\n\n    Quick sort generally has an average time complexity of $O(n \\log n)$, though its worst-case time complexity is $O(n^2)$ if the pivot selection consistently results in unbalanced partitions. The average case is efficient due to its partitioning strategy.\n\n- Space Complexity: $O(\\log n)$ on average, $O(n)$ in the worst case\n\n    The space complexity for quick sort is $O(\\log n)$ due to the depth of the recursion stack in the average case. In the worst case, it can be $O(n)$ if the recursion depth is not balanced.\n\n---\n\n### Approach 3: Merge Sort\n\n#### Intuition\n\nMerge sort involves recursively dividing the list into smaller parts until each part contains a single number. Sorting single-number parts is straightforward, so we focus on merging these parts in the correct order.\n\nDuring the merging process, we compare numbers by concatenating their string representations. We ensure that larger concatenated results come first in the merged list. This is done by comparing combinations like `a + b` and `b + a` and placing the larger result first.\n\nAfter merging all parts, we obtain a sorted list where concatenating all numbers forms the largest number. If this result starts with '0', all numbers are zero, so we return \"0\". Otherwise, we return the concatenated result.\n\nFor example, with the list `[3, 30, 34, 5, 9]`, we first split it into `[3, 30]` and `[34, 5, 9]`.\n\nWe recursively divide these segments further until each segment contains a single number. We then merge these single-number segments, comparing concatenated results to determine the order. For example, merging `[3]` and `[30]`, we find `\"330\"` is greater than `\"303\"`, so `\"30\"` should precede `\"3\"`.\n\nMerging all segments with similar comparisons results in the list `[9, 5, 34, 3, 30]`. Concatenating these numbers gives `\"9534330\"`, the largest possible number.\n\n#### Algorithm\n\n- Sort the `nums` array using a custom merge sort to arrange numbers in a way that forms the largest possible concatenated number.\n\n- `mergeSort` function:\n  - If the range of elements to be sorted (`left` to `right`) is a single element, return it as it is already sorted.\n  - Divide the array into two halves (`left` and `right`) by finding the middle index.\n  - Recursively sort the left and right halves.\n  - Merge the sorted halves using the `merge` function.\n\n- `merge` function:\n  - Initialize two indices to iterate over the left and right halves of the array.\n  - Compare elements from the left and right halves based on custom concatenation order (using the `compare` function).\n  - Append the larger element to the sorted array and move the corresponding index.\n  - After processing all elements from one half, append the remaining elements from the other half.\n\n- `compare` function:\n  - Concatenate `firstNum` and `secondNum` in both possible orders and compare them.\n  - Return `true` if `firstNum` should appear before `secondNum` in the final sorted order based on the concatenated result.\n\n- After sorting, concatenate the sorted numbers to form the largest number.\n  - Return \"0\" if the largest number starts with '0' (handles cases where all numbers are zero); otherwise, return the concatenated result.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/4f5VffNf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4f5VffNf\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$\n\n    Merge sort divides the array into halves and merges them in $O(n \\log n)$ time. Each merge operation is linear in the size of the array being merged, and the recursive divide-and-conquer approach ensures a logarithmic depth of recursion.\n\n- Space Complexity: $O(n)$\n\n    Merge sort requires additional space for the temporary arrays used during merging. For each recursive call, we use extra space proportional to the size of the array being merged.\n   \n    The depth of the recursion stack is $O(\\log n)$, and the space used per level of recursion for merging is $O(n)$. So, the total space complexity is $O(n)$.\n\n    Creating the final string involves space proportional to the size of the final string, which is $O(n)$.\n\n---\n\n### Approach 4: HeapSort\n\n#### Intuition\n\n\nHeapsort helps us find the largest concatenated number by using a priority queue, which we often call a max heap.\n\nFirst, we need to turn each number into a string. This way, we can compare different concatenations of these strings. We then insert these string representations into a max heap. The max heap will arrange these strings based on our custom comparison function and The heap uses this comparison to decide which string should come first.\n\nSay we have the numbers `[3, 30, 34, 5, 9]`. We start by converting each number to a string, resulting in `[\"3\", \"30\", \"34\", \"5\", \"9\"]`. We insert these strings into the heap. The heap sorts these strings based on which concatenation yields a larger number. \n\nFor instance, comparing `\"30\"` and `\"3\"` involves checking if `\"303\"` is larger than `\"330\"`. Since `\"330\"` is larger, `\"3\"` will be prioritized over `\"30\"` in the heap. After inserting all strings, the heap will arrange them in a way that ensures the largest number comes out first.\n\nNext, we remove elements from the heap one by one and build our result string. By concatenating these strings in the order they come out of the heap, we get the largest possible number. Finally, if the result starts with '0', we return \"0\" because this means all numbers were zeros.\n\n</br>\n\nThe algorithm is visualized below:\n\n!?!../Documents/179/heapsort.json:925,695!?!\n\n#### Algorithm\n\n- Initialize a max heap to store numbers as strings in a custom sorted order, using the `compare` function.\n\n- Initialize a variable `totalLength` to track the total length of all numbers converted to strings.\n\n- Iterate over each number `num` in `nums`:\n  - Convert the integer `num` to a string `strNum`.\n  - Add the length of `strNum` to `totalLength`.\n  - Push `strNum` into the max heap using the custom comparison function to maintain the order.\n\n- Initialize an empty string `result` and reserve space based on `totalLength` for efficiency.\n\n- While the max heap is not empty:\n  - Append the top element (largest string based on custom comparison) from the max heap to `result`.\n  - Pop the top element from the max heap.\n\n- Check if the resulting string is empty or starts with `'0'`:\n  - If true, return `\"0\"` to handle the edge case where the result might be a string of zeros.\n\n- Otherwise, return the final `result` string, which represents the largest possible number.\n\n- `compare` function:\n  - Given two strings `first` and `second`, compare them by concatenating them in two different orders (`first + second` and `second + first`).\n  - Return `true` if `(first + second)` is less than `(second + first)`, ensuring the correct order for the largest number construction.\\\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/VUHJjLZT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VUHJjLZT\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$\n\n    Converting each integer to a string takes $O(\\log k)$ time per integer, where $k$ is the integer value. If there are $n$ integers, the total time for conversion is $O(n \\log k)$.\n    \n    Inserting each string into the priority queue takes $O(\\log n)$ time per insertion. Since there are $n$ strings, this step contributes $O(n \\log n)$.\n    \n    Extracting elements from the priority queue and concatenating them into the result string takes $O(n \\log n)$ time due to the heap operations and string concatenations.\n\n    Combining these steps, the overall time complexity is dominated by the heap operations, so:\n    \n    Converting integers to strings takes $O(n \\log k)$ time, and inserting each string into the priority queue takes $O(n \\log n)$. Building the result string takes $O(n \\log n)$. Thus, the overall time complexity is $O(n \\log n)$.\n\n- Space Complexity: $O(n)$\n\n    The priority queue stores $n$ strings, each of which can be up to $O(\\log k)$ in length. Hence, the space required for the priority queue is $O(n \\log k)$.\n\n    The result string stores all $n$ integers, so its space complexity is $O(n \\log k)$. Since these are the main contributors to space complexity, the overall space complexity is $O(n \\log k) = O(n)$.\n\n---\n\n### Approach 5: TimSort \n\n#### Intuition\n\nTimSort is a sorting algorithm that combines insertion sort and merge sort.\n\nWe start by dividing the list into small segments called runs. Each run is a segment of the list that is sorted independently using insertion sort. Insertion sort is well-suited for this task because it efficiently handles small or already partially sorted segments. For instance, in our example list `[3, 30, 34, 5, 9]`, TimSort first breaks it into runs. Since the list is small, it might treat the entire list as a single run or split it into smaller manageable runs like `[3, 30]` and `[34, 5, 9]` [Usually runs are not this small but for the sake of this example lets say its 2].\n\n> Minrun is chosen from the range 32 to 64 inclusive, such that the size of the data, divided by minrun, is equal to, or slightly less than, a power of two.\n\nNext, we merge these sorted runs into larger, sorted segments. During the merging phase, we use a custom comparison function to determine the order of numbers based on which concatenated result is larger.\n\nAfter all runs are merged, we get a fully sorted list arranged to form the largest possible number. Finally, we check if the result starts with '0'. If it does, this indicates that all numbers are zeros, so we return \"0\".\n\nConsider the list `[3, 30, 34, 5, 9]`. TimSort starts by sorting small runs like `[3, 30]` and `[34, 5, 9]` using insertion sort. It then merges these runs, comparing concatenated results to determine the correct order. For instance, it would compare `\"330\"` with `\"303\"` and place `\"3\"` before `\"30\"` because `\"330\"` is larger. The final merge step sorts the list to `[9, 5, 34, 3, 30]`. Concatenating these gives us the largest number, `\"9534330\"`.\n\nTimsort aims to optimize the merging process by ensuring that the number of runs is close to a power of two. Merging is most effective when the number of runs is equal to or just under a power of two, while it becomes less efficient when the number of runs exceeds a power of two. To achieve this, Timsort selects the value of `RUN` so that the total number of runs is close to a power of two.\n\n`RUN` is chosen within the range of 32 to 64. It is set so that the total size of the data divided by `RUN` is either equal to or slightly less than a power of two. The method for determining `RUN` involves taking the six most significant bits of the array size, adding one if any of the remaining bits are set, and using this result for `RUN`. This approach accommodates all array sizes, including those smaller than 64. For arrays with 63 or fewer elements, `RUN` is set equal to the array size, effectively reducing Timsort to insertion sort for those smaller arrays.\n\n> Fun fact: Timsort is highly regarded for its efficiency and stability. It is more advanced compared to older algorithms like bubble sort or insertion sort. Invented by Tim Peters in 2002, it was named after him. Timsort is used in Python sort.\n\n#### Algorithm\n\n- Sort the `nums` array using the custom `timSort` algorithm.\n  \n- `timSort` function:\n  - For each small run of size `RUN` (32 elements), call `insertionSort` to sort the subarrays.\n  - After sorting small runs, iteratively merge them using the `merge` function until the entire array is sorted.\n\n- `insertionSort` function:\n  - Iterate through the subarray from `left + 1` to `right`.\n  - For each element, store it in a temporary variable `temp`.\n  - Compare `temp` with its previous elements (from right to left) using the `compare` function:\n    - If the comparison returns `true` (i.e., `temp` should precede the compared element), shift the previous element to the right.\n  - Insert `temp` in its correct position once all comparisons are done.\n\n- `merge` function:\n  - Split the array into two subarrays: `leftArr` (from `left` to `mid`) and `rightArr` (from `mid + 1` to `right`).\n  - Merge the two subarrays back into the original array:\n    - Compare the elements from both subarrays using the `compare` function.\n    - Insert the smaller element into the original array and proceed until both subarrays are fully merged.\n\n- `compare` function:\n  - Convert the two numbers `firstNum` and `secondNum` into strings.\n  - Concatenate them in both possible orders and return `true` if the first concatenation results in a larger number.\n\n- Once `nums` is sorted, concatenate all elements in `nums` to form the `largestNum` string.\n\n- If the first character of `largestNum` is `'0'`, return `\"0\"` to handle the case where all numbers are zero.\n\n- Otherwise, return `largestNum` as the final result.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/2SDuwQiU/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"2SDuwQiU\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n \\log n)$\n\n    The main time-consuming operation here is the sorting step using TimSort. Its time complexity is $O(n \\log n)$ in the average and worst cases. \n\n    Specifically:\n    - The insertion sort runs in $O(n^2)$ time on small segments (runs), but since it operates on a limited size of $RUN$, the total cost for insertion sorting all runs is $O(n)$ in practice.\n    - The merge step involves merging pairs of runs and is performed $\\log n$ times, leading to the overall time complexity of $O(n \\log n)$ for TimSort.\n\n    Concatenating the numbers to form the final string has a linear time complexity $O(n)$, but it doesn't affect the overall complexity since $O(n \\log n)$ dominates.\n\n- Space complexity: $O(n)$\n\n    The space complexity is dominated by the space used for temporary storage during merging:\n    - The `leftArr` and `rightArr` vectors in the merge function require $O(n)$ space in total.\n    - The extra space used for the `largestNum` string is $O(n)$.\n\n    Other auxiliary space used in the algorithm, such as variables and function call stacks, is minimal compared to the space required for arrays.\n\n    Thus, the overall space complexity is $O(n)$.\n\n---\n\n</br>\n\n</br>\n\n### Further Thoughts:\n\nYou might be wondering why merging is most effective when the number of runs is equal to or just below a power of two, and why it becomes less efficient when the number of runs exceeds this number.\n\nThe main reason for this is that merging is most balanced when the number of runs is a power of two. In general, if the data is randomly ordered, each run will typically be about the size of `minrun`. When the number of runs matches a power of two, merging operations can proceed in a perfectly balanced manner throughout the process. This balance minimizes the number of comparisons and data movements needed.\n\nIf the number of runs is slightly more than a power of two, the merging process becomes less balanced. This imbalance results in inefficient merges, as you end up with uneven merge sizes, leading to increased comparisons and data movement.\n\nConversely, if the number of runs is slightly fewer than a power of two, the merges remain relatively balanced, although not perfectly. This slight imbalance causes only a minor increase in inefficiency compared to the ideal scenario.\n\nFor example, if you have nine natural runs with lengths of 800, 100, 100, 100, 100, 100, 100, 100, and 100 elements, the merges will still be well-balanced, even though the number of runs is slightly above a power of two.\n\nTim Peters talks about this in his [listsort.txt](https://github.com/python/cpython/blob/main/Objects/listsort.txt) file. He points out that using a `minrun` of 32 isn't always the best choice. For example, if you have 2,112 elements, splitting them into runs of 32 means it will take 7 steps to merge everything. The first 6 runs merge smoothly, but after reaching 2,048 elements, the final merge becomes less efficient. This leads to more comparisons and extra data movement.\n\nNow, if the run size is 33, it will take 6 steps to merge everything: 33, 66(33 * 2), 132(66 * 2), 264(132 * 2), 528(264 * 2), 1,056(528 * 2) and then 2,112(1,056 * 2). But with a run size of 32, you'll need 7 steps: 32, 64, 128, 256, 512, 1,024, 2,048, and then 2,112.\n\n</br>\n\nYou can view the full implementation of TimSort, including all the detailed aspects, in the file located at [https://svn.python.org/projects/python/trunk/Objects/listobject.c](https://svn.python.org/projects/python/trunk/Objects/listobject.c). This implementation was crafted by Tim Peters.\n\n</br>\n\nHere\u2019s a snippet taken from `listobject.c` showing how to determine the minimum run size for a subarray in the Timsort algorithm based on the size of the initial array `n`.\n\n```c\n/* Compute a good value for the minimum run length; natural runs shorter\n * than this are boosted artificially via binary insertion.\n *\n * If n < 64, return n (it's too small to bother with fancy stuff).\n * Else if n is an exact power of 2, return 32.\n * Else return an int k, 32 <= k <= 64, such that n/k is close to, but\n * strictly less than, an exact power of 2.\n *\n * See listsort.txt for more info.\n */\nstatic Py_ssize_t\nmerge_compute_minrun(Py_ssize_t n)\n{\n    Py_ssize_t r = 0;           /* becomes 1 if any 1 bits are shifted off */\n\n    assert(n >= 0);\n    while (n >= 64) {\n        r |= n & 1;\n        n >>= 1;\n    }\n    return n + r;\n}\n```\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/largest-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "180",
        "questionFrontendId": "180",
        "title": "Consecutive Numbers",
        "content": "<p>Table: <code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column starting from 1.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find all numbers that appear at least three times consecutively.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>Output:</strong> \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>Explanation:</strong> 1 is the only number that appears consecutively for at least three times.\n</pre>\n",
        "likes": 2342,
        "dislikes": 339,
        "stats": "{\"totalAccepted\": \"529.9K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 529885, \"totalSubmissionRaw\": 1160388, \"acRate\": \"45.7%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n---\n### Approach: Using `DISTINCT` and `WHERE` clause [Accepted]\n\n**Algorithm**\n\nConsecutive appearing means the Id of the Num are next to each others. Since this problem asks for numbers appearing at least three times consecutively, we can use 3 aliases for this table **Logs**, and then check whether 3 consecutive numbers are all the same.\n\n```sql\nSELECT *\nFROM\n    Logs l1,\n    Logs l2,\n    Logs l3\nWHERE\n    l1.Id = l2.Id - 1\n    AND l2.Id = l3.Id - 1\n    AND l1.Num = l2.Num\n    AND l2.Num = l3.Num\n;\n```\n| Id | Num | Id | Num | Id | Num |\n|----|-----|----|-----|----|-----|\n| 1  | 1   | 2  | 1   | 3  | 1   |\n>Note: The first two columns are from l1, then the next two are from l2, and the last two are from l3.\n\nThen we can select any *Num* column from the above table to get the target data. However, we need to add a keyword `DISTINCT` because it will display a duplicated number if one number appears more than 3 times consecutively.\n\n**MySQL**\n\n```sql\nSELECT DISTINCT\n    l1.Num AS ConsecutiveNums\nFROM\n    Logs l1,\n    Logs l2,\n    Logs l3\nWHERE\n    l1.Id = l2.Id - 1\n    AND l2.Id = l3.Id - 1\n    AND l1.Num = l2.Num\n    AND l2.Num = l3.Num\n;\n```"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/consecutive-numbers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "181",
        "questionFrontendId": "181",
        "title": "Employees Earning More Than Their Managers",
        "content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| salary      | int     |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of an employee, their name, salary, and the ID of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to find the employees who earn more than their managers.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+-----------+\n| id | name  | salary | managerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | Null      |\n| 4  | Max   | 90000  | Null      |\n+----+-------+--------+-----------+\n<strong>Output:</strong> \n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n<strong>Explanation:</strong> Joe is the only employee who earns more than his manager.\n</pre>\n",
        "likes": 2750,
        "dislikes": 271,
        "stats": "{\"totalAccepted\": \"784.8K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 784845, \"totalSubmissionRaw\": 1102015, \"acRate\": \"71.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/employees-earning-more-than-their-managers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "182",
        "questionFrontendId": "182",
        "title": "Duplicate Emails",
        "content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n",
        "likes": 2199,
        "dislikes": 75,
        "stats": "{\"totalAccepted\": \"817.4K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 817386, \"totalSubmissionRaw\": 1132011, \"acRate\": \"72.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/duplicate-emails/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "183",
        "questionFrontendId": "183",
        "title": "Customers Who Never Order",
        "content": "<p>Table: <code>Customers</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all customers who never order anything.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n<strong>Output:</strong> \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n",
        "likes": 2768,
        "dislikes": 143,
        "stats": "{\"totalAccepted\": \"972.6K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 972561, \"totalSubmissionRaw\": 1380862, \"acRate\": \"70.4%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/customers-who-never-order/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "184",
        "questionFrontendId": "184",
        "title": "Department Highest Salary",
        "content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference columns) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table. It is guaranteed that department name is not <code>NULL.</code>\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find employees who have the highest salary in each of the departments.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Jim   | 90000  | 1            |\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Jim      | 90000  |\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.\n</pre>\n",
        "likes": 2161,
        "dislikes": 195,
        "stats": "{\"totalAccepted\": \"472.7K\", \"totalSubmission\": \"872.8K\", \"totalAcceptedRaw\": 472726, \"totalSubmissionRaw\": 872791, \"acRate\": \"54.2%\"}",
        "similarQuestions": "[{\"title\": \"Highest Grade For Each Student\", \"titleSlug\": \"highest-grade-for-each-student\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/department-highest-salary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "185",
        "questionFrontendId": "185",
        "title": "Department Top Three Salaries",
        "content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A company&#39;s executives are interested in seeing who earns the most money in each of the company&#39;s departments. A <strong>high earner</strong> in a department is an employee who has a salary in the <strong>top three unique</strong> salaries for that department.</p>\n\n<p>Write a solution to find the employees who are <strong>high earners</strong> in each of the departments.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>There are no employees with the <strong>exact</strong> same name, salary <em>and</em> department.</li>\n</ul>\n",
        "likes": 2292,
        "dislikes": 258,
        "stats": "{\"totalAccepted\": \"466K\", \"totalSubmission\": \"815.1K\", \"totalAcceptedRaw\": 465979, \"totalSubmissionRaw\": 815131, \"acRate\": \"57.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "\u200b\n<!-- Don't delete this -->\n[TOC]\n\u200b\n# Solution\n\u200b\n---\n\u200b\n## pandas\n\n<!-- h3 for approaches -->\n### Approach 1: Return the First n Rows Using nlargest()\n\n<!-- h4 for sections -->\n#### Algorithm\n\n<!-- Describe your approach to solving the problem. -->\nFor this problem, we can either identify the top earners first using DataFrame `employee` and then join the DataFrame `department` to get the department name, or join the DataFrame `department` first to get the department name before identifying the top earners. In this approach, we use the latter logic. \n\nIn this step, we can also update the column name in the DataFrame `department` from `name` to `Department` as requested by the final output.\n\n```python\nEmployee_Department = employee.merge(department, left_on='departmentId', right_on='id').rename(columns = {'name_y': 'Department'})\n```\n\nNow we have the employee and department information stored in the same DataFrame: \n\n| id_x | name_x | salary | departmentId | id_y | Department |\n| ---- | ------ | ------ | ------------ | ---- | ---------- |\n| 1    | Joe    | 85000  | 1            | 1    | IT         |\n| 4    | Max    | 90000  | 1            | 1    | IT         |\n| 5    | Janet  | 69000  | 1            | 1    | IT         |\n| 6    | Randy  | 85000  | 1            | 1    | IT         |\n| 7    | Will   | 70000  | 1            | 1    | IT         |\n| 2    | Henry  | 80000  | 2            | 2    | Sales      |\n| 3    | Sam    | 60000  | 2            | 2    | Sales      |\n\nSince the definition of a **high earner** is an employee who has a salary in the top three **unique** salaries for the department, we want to make sure the salary is unique at the department level for later calculation. To do this, we select only the department and salary from the DataFrame created in the last step and drop any duplicated records if existed. \n\n```python\nEmployee_Department = Employee_Department[['Department', 'departmentId', 'salary']].drop_duplicates()\n```\n\nHere's the output after this step:\n\n| Department | departmentId | salary |\n| ---------- | ------------ | ------ |\n| IT         | 1            | 85000  |\n| IT         | 1            | 90000  |\n| IT         | 1            | 69000  |\n| IT         | 1            | 70000  |\n| Sales      | 2            | 80000  |\n| Sales      | 2            | 60000  |\n\nNow we can identify the top 3 unique salaries for each department. We use the function [`nlargest()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nlargest.html) to get this value. The parameter '3' is passed to the function as it defines the number of rows to return. \n\n```python\ntop_salary = Employee_Department.groupby(['Department', 'departmentId']).salary.nlargest(3).reset_index()\n```\n\n| Department | departmentId | level_2 | salary |\n| ---------- | ------------ | ------- | ------ |\n| IT         | 1            | 1       | 90000  |\n| IT         | 1            | 0       | 85000  |\n| IT         | 1            | 4       | 70000  |\n| Sales      | 2            | 5       | 80000  |\n| Sales      | 2            | 6       | 60000  |\n\n\nNow we only need to identify the employees are in these departments and making the same amount of salary. To do this, we can merge the DataFrame `top_salary`, which contains the top three unique salary for each department, to the DataFrame `employee` on `departmentId` and `salary`, so only the employees that match both criteria will be retained. \n\n```python\ndf = top_salary.merge(employee, on=['departmentId', 'salary'])\n```\n\n| Department | departmentId | level_2 | salary | id | name  |\n| ---------- | ------------ | ------- | ------ | -- | ----- |\n| IT         | 1            | 1       | 90000  | 4  | Max   |\n| IT         | 1            | 0       | 85000  | 1  | Joe   |\n| IT         | 1            | 0       | 85000  | 6  | Randy |\n| IT         | 1            | 4       | 70000  | 7  | Will  |\n| Sales      | 2            | 5       | 80000  | 2  | Henry |\n| Sales      | 2            | 6       | 60000  | 3  | Sam   |\n\nLastly, we clean the DataFrame as per requested by the final output. We keep only the columns needed and rename the columns accordingly.\n\n```python\ndf[['Department', 'name', 'salary']].rename(columns = {'name': 'Employee', 'salary': 'Salary'})\n```\n\n<!-- h4 for sections -->\n#### Implementation\n\u200b<iframe src=\"https://leetcode.com/playground/5nLUgFZZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"276\" name=\"5nLUgFZZ\"></iframe>\n<!-- an empty line to separate approaches -->\n\n\n<!-- h3 for approaches -->\n### Approach 2: Return the First n Rows Using rank()\n\n<!-- h4 for sections -->\n#### Algorithm\n\n<!-- Describe your approach to solving the problem. -->\nFor this approach, we first identify the top earners from the DataFrame `employee` and then join the DataFrame `department` to get the department name. \n\nTo identify the high earners for each department, we use the function [`rank()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html) to apply dense rank on the column `salary` so we can get the top three **unique** salaries. The parameter `ascending=False` is passed so the salary is sorted from the maximum to the minimum. Within the same step, we can also add the filter to keep only the records with a rank smaller than or equal to 3. \n\n```python\ntop_salary = employee[employee.groupby('departmentId').salary.rank(method='dense', ascending=False) <= 3]\n```\n\nOnly employees who are `high earners` retained in the new DataFrame:\n\n| id | name  | salary | departmentId |\n| -- | ----- | ------ | ------------ |\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n\nNow we want to `merge` to the DataFrame `department` to get the `name` of the department. In the same step, we can also select only the columns needed for the final output. \n\n```python\nemployee_department = top_salary.merge(department, left_on='departmentId', right_on='id')[['name_y', 'name_x', 'salary']]\n```\n| name_y | name_x | salary |\n| ------ | ------ | ------ |\n| IT     | Joe    | 85000  |\n| IT     | Max    | 90000  |\n| IT     | Randy  | 85000  |\n| IT     | Will   | 70000  |\n| Sales  | Henry  | 80000  |\n| Sales  | Sam    | 60000  |\n\n\nWe are almost there! To get the final output, we need to update the column name as per requested.\n\n```python\nreturn employee_department.rename(columns = {'name_y': 'Department', 'name_x': 'Employee', 'salary': 'Salary'})\n```\n\n<!-- h4 for sections -->\n#### Implementation\n<iframe src=\"https://leetcode.com/playground/WbvUZqck/shared\" frameBorder=\"0\" width=\"100%\" height=\"208\" name=\"WbvUZqck\"></iframe>\n---\n\n## Database\n\n### Approach 1: Return the First n Rows Using Correlated Subquery\n\n<!-- h4 for sections -->\n#### Algorithm\n\u200b<!-- Describe your approach to solving the problem. -->\nWe can build a [correlated subquery](https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html) to identify the top N records from more than one category. Since the correlated subquery is dependent on the main query, the idea behind this approach is to compare the values between the main query and the subquery, so that in the subquery, at most N-1 salaries can be greater than each selected salary from the main query.\n\nTo do this, we first build the main query. In the main query, we can also join the table `Employee` to the table `Department` on `departmentId` to get the `name` of the departments and rename the columns as requested by the final output. \n\n```sql\nSELECT d.name AS 'Department', \n       e1.name AS 'Employee', \n       e1.salary AS 'Salary' \nFROM Employee e1\nJOIN Department d\nON e1.departmentId = d.id \n```\n\nIn the correlated subquery, we select the number of salaries from the same table `Employee`. To compare the salaries between the main query and the subquery, we make sure the department is the same from both queries, but the salary from the subquery is always bigger than the salary from the main query. \n\n```sql\n(\n    SELECT COUNT(DISTINCT e2.salary)\n    FROM Employee e2\n    WHERE e2.salary > e1.salary AND e1.departmentId = e2.departmentId\n)\n```\n\nSince we need to identify the top three high earners in the main query, and the subquery always has larger salaries than the salaries from the main query, the maximum count of the larger salaries in the subquery is two. We add this criteria as a filter to the main query.\n\n<!-- h4 for sections -->\n#### Implementation\n\n```sql\nSELECT d.name AS 'Department', \n       e1.name AS 'Employee', \n       e1.salary AS 'Salary' \nFROM Employee e1\nJOIN Department d\nON e1.departmentId = d.id \nWHERE\n    3 > (SELECT COUNT(DISTINCT e2.salary)\n        FROM Employee e2\n        WHERE e2.salary > e1.salary AND e1.departmentId = e2.departmentId);\n```\n\u200b\n<!-- an empty line to separate approaches -->\n\n<!-- h3 for approaches -->\n### Approach 2: Return the First n Rows Using DENSE_RANK()\n\n<!-- h4 for sections -->\n#### Algorithm\n\u200b<!-- Describe your approach to solving the problem. -->\nUnlike the previous approach that utilized a correlated subquery, in this approach, we sorted the salaries in descending order, ranked employees based on their salaries within the department, and selected only the first 3 employees for the final output.\n\nWe first create a subquery or CTE to rank the employees. Since the definition of a high earner is the employee who has a salary in the top three **unique** salaries for the department, we can use the function `DENSE_RANK()` to avoid the scenario that employees from the same department make the same amount of salary. In this step, we can also join the table `Department` on `departmentId` to get the `name` of the departments and rename the columns for the final output. \n\n```sql\nWITH employee_department AS\n    (\n    SELECT d.id, \n        d.name AS Department, \n        salary AS Salary, \n        e.name AS Employee, \n        DENSE_RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rnk\n    FROM Department d\n    JOIN Employee e\n    ON d.id = e.departmentId\n    )\n```\n\nNow, each employee has a rank based on the `salary` in a descending order for each department. \n\n| id | Department | Salary | Employee | rnk |\n| -- | ---------- | ------ | -------- | --- |\n| 1  | IT         | 90000  | Max      | 1   |\n| 1  | IT         | 85000  | Joe      | 2   |\n| 1  | IT         | 85000  | Randy    | 2   |\n| 1  | IT         | 70000  | Will     | 3   |\n| 1  | IT         | 69000  | Janet    | 4   |\n| 2  | Sales      | 80000  | Henry    | 1   |\n| 2  | Sales      | 60000  | Sam      | 2   |\n\nWith the rank, we can select the high earners. We can add the filter to select employees that have a rank smaller than or equal to 3 in the main query. \n\n```sql\nSELECT Department, Employee, Salary\nFROM employee_department\nWHERE rnk <= 3\n```\n<!-- h4 for sections -->\n#### Implementation\n\n```mysql []\nWITH employee_department AS\n    (\n    SELECT d.id, \n        d.name AS Department, \n        salary AS Salary, \n        e.name AS Employee, \n        DENSE_RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rnk\n    FROM Department d\n    JOIN Employee e\n    ON d.id = e.departmentId\n    )\nSELECT Department, Employee, Salary\nFROM employee_department\nWHERE rnk <= 3\n```\n\u200b\n----\n<!-- an empty line to separate approaches -->"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/department-top-three-salaries/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "186",
        "questionFrontendId": "186",
        "title": "Reverse Words in a String II",
        "content": null,
        "likes": 1096,
        "dislikes": 145,
        "stats": "{\"totalAccepted\": \"172.8K\", \"totalSubmission\": \"309.2K\", \"totalAcceptedRaw\": 172802, \"totalSubmissionRaw\": 309227, \"acRate\": \"55.9%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Words in a String\", \"titleSlug\": \"reverse-words-in-a-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Rotate Array\", \"titleSlug\": \"rotate-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-words-in-a-string-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "187",
        "questionFrontendId": "187",
        "title": "Repeated DNA Sequences",
        "content": "<p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>\n</ul>\n\n<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>\n\n<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n<strong>Output:</strong> [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAAAAAAAAAA\"\n<strong>Output:</strong> [\"AAAAAAAAAA\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.</li>\n</ul>\n",
        "likes": 3456,
        "dislikes": 553,
        "stats": "{\"totalAccepted\": \"441.7K\", \"totalSubmission\": \"867.2K\", \"totalAcceptedRaw\": 441705, \"totalSubmissionRaw\": 867169, \"acRate\": \"50.9%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Sliding Window"
          },
          {
            "name": "Rolling Hash"
          },
          {
            "name": "Hash Function"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/repeated-dna-sequences/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "188",
        "questionFrontendId": "188",
        "title": "Best Time to Buy and Sell Stock IV",
        "content": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>k</code>.</p>\n\n<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [2,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 7686,
        "dislikes": 218,
        "stats": "{\"totalAccepted\": \"569.9K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 569907, \"totalSubmissionRaw\": 1228570, \"acRate\": \"46.4%\"}",
        "similarQuestions": "[{\"title\": \"Best Time to Buy and Sell Stock\", \"titleSlug\": \"best-time-to-buy-and-sell-stock\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock II\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock III\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Profit From Trading Stocks\", \"titleSlug\": \"maximum-profit-from-trading-stocks\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "189",
        "questionFrontendId": "189",
        "title": "Rotate Array",
        "content": "<p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3\n<strong>Output:</strong> [5,6,7,1,2,3,4]\n<strong>Explanation:</strong>\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-100,3,99], k = 2\n<strong>Output:</strong> [3,99,-1,-100]\n<strong>Explanation:</strong> \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Try to come up with as many solutions as you can. There are at least <strong>three</strong> different ways to solve this problem.</li>\n\t<li>Could you do it in-place with <code>O(1)</code> extra space?</li>\n</ul>\n",
        "likes": 19278,
        "dislikes": 2091,
        "stats": "{\"totalAccepted\": \"3M\", \"totalSubmission\": \"7.1M\", \"totalAcceptedRaw\": 3023079, \"totalSubmissionRaw\": 7085525, \"acRate\": \"42.7%\"}",
        "similarQuestions": "[{\"title\": \"Rotate List\", \"titleSlug\": \"rotate-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reverse Words in a String II\", \"titleSlug\": \"reverse-words-in-a-string-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Make K-Subarray Sums Equal\", \"titleSlug\": \"make-k-subarray-sums-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Matching Indices After Right Shifts\", \"titleSlug\": \"maximum-number-of-matching-indices-after-right-shifts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "The easiest solution would use additional memory and that is perfectly fine.",
          "The actual trick comes when trying to solve this problem without using any additional memory. This means you need to use the original array somehow to move the elements around. Now, we can place each element in its original location and shift all the elements around it to adjust as that would be too costly and most likely will time out on larger input arrays.",
          "One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example.",
          "The other line of thought is a tad bit complicated but essentially it builds on the idea of placing each element in its original position while keeping track of the element originally in that position. Basically, at every step, we place an element in its rightful position and keep track of the element already there or the one being overwritten in an additional variable. We can't do this in one linear pass and the idea here is based on <b>cyclic-dependencies</b> between elements."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rotate-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "190",
        "questionFrontendId": "190",
        "title": "Reverse Bits",
        "content": "<p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&#39;s internal binary representation is the same, whether it is signed or unsigned.</li>\n\t<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2&#39;s complement notation</a>. Therefore, in <strong class=\"example\">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 00000010100101000001111010011100\n<strong>Output:</strong>    964176192 (00111001011110000010100101000000)\n<strong>Explanation: </strong>The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11111111111111111111111111111101\n<strong>Output:</strong>   3221225471 (10111111111111111111111111111111)\n<strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input must be a <strong>binary string</strong> of length <code>32</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If this function is called many times, how would you optimize it?</p>\n",
        "likes": 5324,
        "dislikes": 1567,
        "stats": "{\"totalAccepted\": \"974.7K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 974744, \"totalSubmissionRaw\": 1558200, \"acRate\": \"62.6%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Integer\", \"titleSlug\": \"reverse-integer\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of 1 Bits\", \"titleSlug\": \"number-of-1-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"A Number After a Double Reversal\", \"titleSlug\": \"a-number-after-a-double-reversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/reverse-bits/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "191",
        "questionFrontendId": "191",
        "title": "Number of 1 Bits",
        "content": "<p>Given a positive integer <code>n</code>, write a function that returns the number of <span data-keyword=\"set-bit\">set bits</span> in its binary representation (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">Hamming weight</a>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 11</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>1011</strong> has a total of three set bits.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 128</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>10000000</strong> has a total of one set bit.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 2147483645</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">30</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>1111111111111111111111111111101</strong> has a total of thirty set bits.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If this function is called many times, how would you optimize it?",
        "likes": 6781,
        "dislikes": 1347,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 1756534, \"totalSubmissionRaw\": 2372517, \"acRate\": \"74.0%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Bits\", \"titleSlug\": \"reverse-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Power of Two\", \"titleSlug\": \"power-of-two\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Counting Bits\", \"titleSlug\": \"counting-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Watch\", \"titleSlug\": \"binary-watch\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Hamming Distance\", \"titleSlug\": \"hamming-distance\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Number with Alternating Bits\", \"titleSlug\": \"binary-number-with-alternating-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Prime Number of Set Bits in Binary Representation\", \"titleSlug\": \"prime-number-of-set-bits-in-binary-representation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Convert Date to Binary\", \"titleSlug\": \"convert-date-to-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/number-of-1-bits/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "192",
        "questionFrontendId": "192",
        "title": "Word Frequency",
        "content": "<p>Write a bash script to calculate the <span data-keyword=\"frequency-textfile\">frequency</span> of each word in a text file <code>words.txt</code>.</p>\n\n<p>For simplicity sake, you may assume:</p>\n\n<ul>\n\t<li><code>words.txt</code> contains only lowercase characters and space <code>&#39; &#39;</code> characters.</li>\n\t<li>Each word must consist of lowercase characters only.</li>\n\t<li>Words are separated by one or more whitespace characters.</li>\n</ul>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>words.txt</code> has the following content:</p>\n\n<pre>\nthe day is sunny the the\nthe sunny is is\n</pre>\n\n<p>Your script should output the following, sorted by descending frequency:</p>\n\n<pre>\nthe 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p><b>Note:</b></p>\n\n<ul>\n\t<li>Don&#39;t worry about handling ties, it is guaranteed that each word&#39;s frequency count is unique.</li>\n\t<li>Could you write it in one-line using <a href=\"http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html\">Unix pipes</a>?</li>\n</ul>\n",
        "likes": 556,
        "dislikes": 309,
        "stats": "{\"totalAccepted\": \"61K\", \"totalSubmission\": \"225.9K\", \"totalAcceptedRaw\": 60982, \"totalSubmissionRaw\": 225877, \"acRate\": \"27.0%\"}",
        "similarQuestions": "[{\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Shell",
        "hints": [],
        "topicTags": [
          {
            "name": "Shell"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-frequency/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "193",
        "questionFrontendId": "193",
        "title": "Valid Phone Numbers",
        "content": "<p>Given a text file <code>file.txt</code> that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>\n\n<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>\n\n<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>file.txt</code> has the following content:</p>\n\n<pre>\n987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>Your script should output the following valid phone numbers:</p>\n\n<pre>\n987-123-4567\n(123) 456-7890\n</pre>\n",
        "likes": 452,
        "dislikes": 973,
        "stats": "{\"totalAccepted\": \"100.5K\", \"totalSubmission\": \"370.6K\", \"totalAcceptedRaw\": 100529, \"totalSubmissionRaw\": 370623, \"acRate\": \"27.1%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Shell",
        "hints": [],
        "topicTags": [
          {
            "name": "Shell"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/valid-phone-numbers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "194",
        "questionFrontendId": "194",
        "title": "Transpose File",
        "content": "<p>Given a text file <code>file.txt</code>, transpose its content.</p>\n\n<p>You may assume that each row has the same number of columns, and each field is separated by the <code>&#39; &#39;</code> character.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>If <code>file.txt</code> has the following content:</p>\n\n<pre>\nname age\nalice 21\nryan 30\n</pre>\n\n<p>Output the following:</p>\n\n<pre>\nname alice ryan\nage 21 30\n</pre>\n",
        "likes": 153,
        "dislikes": 288,
        "stats": "{\"totalAccepted\": \"31.7K\", \"totalSubmission\": \"112.9K\", \"totalAcceptedRaw\": 31729, \"totalSubmissionRaw\": 112861, \"acRate\": \"28.1%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Shell",
        "hints": [],
        "topicTags": [
          {
            "name": "Shell"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/transpose-file/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "195",
        "questionFrontendId": "195",
        "title": "Tenth Line",
        "content": "<p>Given a text file&nbsp;<code>file.txt</code>, print&nbsp;just the 10th line of the&nbsp;file.</p>\r\n\r\n<p><strong class=\"example\">Example:</strong></p>\r\n\r\n<p>Assume that <code>file.txt</code> has the following content:</p>\r\n\r\n<pre>\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n</pre>\r\n\r\n<p>Your script should output the tenth line, which is:</p>\r\n\r\n<pre>\r\nLine 10\r\n</pre>\r\n\r\n<div class=\"spoilers\"><b>Note:</b><br />\r\n1. If the file contains less than 10 lines, what should you output?<br />\r\n2. There&#39;s at least three different solutions. Try to explore all possibilities.</div>\r\n",
        "likes": 402,
        "dislikes": 474,
        "stats": "{\"totalAccepted\": \"126.6K\", \"totalSubmission\": \"369K\", \"totalAcceptedRaw\": 126622, \"totalSubmissionRaw\": 368980, \"acRate\": \"34.3%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Shell",
        "hints": [],
        "topicTags": [
          {
            "name": "Shell"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/tenth-line/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "196",
        "questionFrontendId": "196",
        "title": "Delete Duplicate Emails",
        "content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to<strong> delete</strong> all duplicate emails, keeping only one unique email with the smallest <code>id</code>.</p>\n\n<p>For SQL users, please note that you are supposed to write a <code>DELETE</code> statement and not a <code>SELECT</code> one.</p>\n\n<p>For Pandas users, please note that you are supposed to modify <code>Person</code> in place.</p>\n\n<p>After running your script, the answer shown is the <code>Person</code> table. The driver will first compile and run your piece of code and then show the <code>Person</code> table. The final order of the <code>Person</code> table <strong>does not matter</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\n<strong>Output:</strong> \n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n<strong>Explanation:</strong> john@example.com is repeated two times. We keep the row with the smallest Id = 1.\n</pre>\n",
        "likes": 1790,
        "dislikes": 368,
        "stats": "{\"totalAccepted\": \"693.6K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 693614, \"totalSubmissionRaw\": 1083952, \"acRate\": \"64.0%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/delete-duplicate-emails/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "197",
        "questionFrontendId": "197",
        "title": "Rising Temperature",
        "content": "<p>Table: <code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nThere are no different rows with the same recordDate.\nThis table contains information about the temperature on a certain day.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all dates&#39; <code>id</code> with higher temperatures compared to its previous dates (yesterday).</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWeather table:\n+----+------------+-------------+\n| id | recordDate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n<strong>Output:</strong> \n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n<strong>Explanation:</strong> \nIn 2015-01-02, the temperature was higher than the previous day (10 -&gt; 25).\nIn 2015-01-04, the temperature was higher than the previous day (20 -&gt; 30).\n</pre>\n",
        "likes": 3549,
        "dislikes": 681,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 1050946, \"totalSubmissionRaw\": 2102893, \"acRate\": \"50.0%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n# Solution\n---\n\n### Overview\n\n**Problem Statement Reference**\n> Write a solution to find all dates' Id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order.\n\nLet's further elaborate on the given example to deepen our understanding of the problem at hand.\n\nIf we conduct a time series analysis of the temperature data, we would notice distinct points where there is a rise in temperature compared to the previous day. This phenomenon is precisely what we are interested in identifying.\n\nBy analyzing the given data:\n\n<table>\n  <header>\n    <tr>\n      <th>id</th>\n      <th>recordDate</th>\n      <th>temperature</th>\n    </tr>\n  </header>\n  <tbody>\n    <tr>\n      <td>1</td>\n      <td>2015-01-01</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>2015-01-02</td>\n      <td>25</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>2015-01-03</td>\n      <td>20</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>2015-01-04</td>\n      <td>30</td>\n    </tr>\n  </tbody>\n</table>\n\nWe can graphically represent the temperature readings across the consecutive dates. When we plot these points on a graph, with the `recordDate` on the X-axis and the `temperature` on the Y-axis, we observe a graphical representation of the temperature variations over the specified period.\n\n![fig](../Figures/197/197-1.png)\n\nFrom this graphical analysis, we notice two instances where there is a rise in the temperature compared to the day before:\n\n1. **January 2, 2015 (id: 2)**: On this day, the temperature is recorded to be 25, which is higher than the 10 recorded on January 1st.\n   \n2. **January 4, 2015 (id: 4)**: Here, the temperature escalated to 30, surpassing the temperature of 20 noted on January 3rd.\n\nThus, based on our criteria of identifying days with a temperature rise compared to the immediate preceding day, we should return the ids for January 2nd and January 4th, which are 2 and 4 respectively.\n\n---\n\n## pandas\n\n### Approach 1: Shifted Dataframe Merge on Record Date\n\n#### Intuition\n\nWe are creating a new DataFrame that represents the data shifted by one day and merging it with the original DataFrame based on the `recordDate`. This way, for each record, we will have information on both the current day and the previous day in the same row, enabling easy comparison of temperatures across consecutive days.\n\nLet's break this down step by step:\n\n**Step 1: Converting `recordDate` to Datetime Type**\n\n```python\n# Ensure the 'recordDate' column is a datetime type\nweather['recordDate'] = pd.to_datetime(weather['recordDate'])\n```\n\n- Before working with date data, it is good practice to ensure that the date column is of the datetime data type to facilitate date-based operations correctly.\n  \n**Step 2: Creating a Shifted DataFrame**\n\n```python\n# Create a copy of the weather DataFrame with a 1 day shift \nweather_shifted = weather.copy()\nweather_shifted['recordDate'] = weather_shifted['recordDate'] + pd.to_timedelta(1, unit='D')\n```\n\n- A copy of the original DataFrame is created, where the `recordDate` for each entry is shifted forward by one day. This allows us to later merge this DataFrame with the original one to compare the temperatures of each day with the previous day.\n\n**Step 3: Merging the Original and Shifted DataFrames**\n\n```python\n# Merging the DataFrames on the 'recordDate' column to find consecutive dates\nmerged_df = pd.merge(weather, weather_shifted, on='recordDate', suffixes=('_today', '_yesterday'))\n```\n\n- The original and shifted DataFrames are merged based on the `recordDate` column, which now contains consecutive dates. This merge operation forms pairs of consecutive days so that we can directly compare the temperatures of each day with the previous day.\n\n**Step 4: Identifying Days with Higher Temperatures than the Previous Day**\n\n```python\n# Finding rows where the temperature is greater on the current day compared to the previous day\nresult = merged_df[merged_df['temperature_today'] > merged_df['temperature_yesterday']][['id_today']].rename(columns={'id_today': 'Id'})\n```\n\n- Within the merged DataFrame, we apply a condition to retain only those rows where the temperature of the current day (`temperature_today`) is greater than that of the previous day (`temperature_yesterday`). This effectively identifies all the days where the temperature was higher than the previous day.\n- We select only the ID column corresponding to the days that satisfy this condition, renaming it to `Id` to meet the output specification.\n\n**Step 5: Returning the Result**\n\n```python\nreturn result\n```\n\n- The final step is to return the DataFrame containing the IDs of the days where the temperature was higher than on the previous day.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/H8hou3Zo/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"H8hou3Zo\"></iframe>\n\n\n### Approach 2: Shift Function with Precise Date Match\n\n#### Intuition\n\nIn this approach, we sort the DataFrame by `recordDate` and then use the shift function to create new columns that hold the data for the previous day. After that, we filter the DataFrame to only include the rows where the temperature is greater than that of the previous day and the dates are precisely one day apart.\n\nLet's break this down step by step:\n\n**Step 1: Converting `recordDate` to Datetime Type**\n\n```python\nweather['recordDate'] = pd.to_datetime(weather['recordDate'])\n```\n- Before performing operations based on dates, we first ensure that the `recordDate` column is of datetime type. This allows us to easily perform date-specific operations later in the function.\n\n**Step 2: Sorting the DataFrame**\n\n```python\nweather.sort_values('recordDate', inplace=True)\n```\n- We sort the data based on the `recordDate` to maintain a chronological order. This step is crucial because the next steps involve operations that are dependent on the order of the dates.\n\n**Step 3: Creating Columns for Previous Day's Data**\n\n```python\nweather['PreviousTemperature'] = weather['temperature'].shift(1)\nweather['PreviousRecordDate'] = weather['recordDate'].shift(1)\n```\n- We create two new columns in the `weather` DataFrame:\n  - `PreviousTemperature`: This column is constructed by shifting the `temperature` column down by one row using `shift(1)`. This means that the value in each row of `PreviousTemperature` is the temperature value from the immediately preceding row in the DataFrame, not necessarily from the immediately preceding day in terms of time.\n  - `PreviousRecordDate`: Similarly, this column is formed by shifting the `recordDate` column down by one row. Hence, each value in `PreviousRecordDate` corresponds to the date from the immediately preceding row, not necessarily the day immediately before the current `recordDate`.\n\nBy having these new columns, we align each row with the temperature and record date of its preceding row in the DataFrame, allowing for comparisons between a day's temperature and that of the previous row. It\u2019s crucial to note that these \u201cprevious\u201d values come from the DataFrame's order and do not always represent the chronological day before, as there might be gaps in the dates within the data.\n\n**Step 4: Filtering for Days with Higher Temperature than the Previous Day**\n\n```python\nresult = weather[\n    (weather['temperature'] > weather['PreviousTemperature']) & \n    (weather['recordDate'] == weather['PreviousRecordDate'] + pd.Timedelta(days=1))\n][['id']].rename(columns={'id': 'Id'})\n```\n\n- We are filtering the DataFrame for rows where the temperature is higher than the previous day's temperature: `(weather['temperature'] > weather['PreviousTemperature'])`.\n- We also ensure that the record date is exactly one day more than the previous record date: `(weather['recordDate'] == weather['PreviousRecordDate'] + pd.Timedelta(days=1))`. This is done using `pd.Timedelta(days=1)` to add a day to the previous record date and checking if it equals the current record date.\n\n**Step 5: Returning the Result**\n\n```python\nreturn result\n```\n- Finally, we return the filtered DataFrame which contains only the `Id` column that satisfies both conditions specified in step 4. This DataFrame represents all the dates where the temperature was higher than the temperature of the previous day.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/gkesEsMj/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"gkesEsMj\"></iframe>\n\n\n---\n\n## Database\n\n### Approach 1: Using `JOIN` and `DATEDIFF()` \n\n#### Intuition\n\nBy doing a self-join on the `Weather` table, we create a Cartesian product of the table with itself, creating pairs of days. We then use the `DATEDIFF` function to restrict these pairs to only include consecutive days. Lastly, we filter these pairs of consecutive days further to only include pairs where the temperature is higher on the second day. The resulting ids represent the days where the temperature was higher than the previous day.\n\nLet's break this down step by step:\n\n**Step 1: Defining the Main Query Structure**\n\n```sql\nSELECT \n    w1.id\nFROM \n    Weather w1\nJOIN \n    Weather w2\n```\n\nHere, we are setting up a query to retrieve the `id` from the `Weather` table aliased as `w1`. To find the records where the temperature is greater than the previous day, we are performing a self-join on the `Weather` table, creating a second alias `w2`. This allows us to compare each record in `w1` with each record in `w2`.\n\n**Step 2: Join Condition**\n\n```sql\nON \n    DATEDIFF(w1.recordDate, w2.recordDate) = 1\n```\n\nIn the join condition, we are using the `DATEDIFF` function to find pairs of records where the `recordDate` differs by exactly one day. This condition ensures that we are comparing each day's temperature with the temperature of the previous day.\n\n**Step 3: Filter Records with Higher Temperature**\n\n```sql\nWHERE \n    w1.temperature > w2.temperature;\n```\n\nAfter finding pairs of days that are consecutive, we apply a filter in the `WHERE` clause to only get the records where the temperature on a day (represented by a record in `w1`) is greater than the temperature on the previous day (represented by a record in `w2`). This is the main condition to fulfill the requirement of finding the ids where the temperature is higher than the previous day.\n\n\n#### Implementation\n\n\n\n```mysql []\nSELECT \n    w1.id\nFROM \n    Weather w1\nJOIN \n    Weather w2\nON \n    DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE \n    w1.temperature > w2.temperature;\n\n```\n\n### Approach 2: Using `LAG()` Function\n\n#### Intuition\n\nLet's break this down step by step:\n\n**Step 1: Creating a Common Table Expression (CTE) with Lag Function**\n\n```sql\nWITH PreviousWeatherData AS\n(\n    SELECT \n        id,\n        recordDate,\n        temperature, \n        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,\n        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate\n    FROM \n        Weather\n)\n```\n\nIn this step, we create a Common Table Expression (CTE) named `PreviousWeatherData` using a `WITH` clause. Inside this CTE, we are selecting all the rows from the \"Weather\" table along with two additional columns:\n\n1. `PreviousTemperature`: The temperature from the previous day, which is obtained using the `LAG()` function with an offset of 1, ordered by `recordDate`.\n2. `PreviousRecordDate`: The record date of the previous day, similarly obtained using the `LAG()` function with an offset of 1, ordered by `recordDate`.\n\nThis setup helps us associate each record with the respective details from the previous day in the same row.\n\n**Step 2: Selecting IDs with Conditions on Temperature and Date**\n\n```sql\nSELECT \n    id \nFROM \n    PreviousWeatherData\nWHERE \n    temperature > PreviousTemperature\nAND \n    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);\n```\n\nIn this step, we execute a query on the `PreviousWeatherData` CTE with two conditions in the WHERE clause to filter the required IDs:\n\n1. `temperature > PreviousTemperature`: This condition filters for the days where the temperature was higher than the previous day's temperature.\n2. `recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY)`: This condition ensures that we are comparing consecutive days. It uses the `DATE_ADD()` function to add an interval of 1 day to the `PreviousRecordDate` and checks if it equals the current `recordDate`.\n\nBy combining these two conditions with an `AND` clause, we ensure that we only select the IDs where both conditions are met, which are the days when the temperature is higher than the day before.\n\n\n#### Implementation\n\n\n```mysql []\nWITH PreviousWeatherData AS\n(\n    SELECT \n        id,\n        recordDate,\n        temperature, \n        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,\n        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate\n    FROM \n        Weather\n)\nSELECT \n    id \nFROM \n    PreviousWeatherData\nWHERE \n    temperature > PreviousTemperature\nAND \n    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);\n\n```\n\n### Approach 3: Using Subquery\n\n#### Intuition\n\nLet's break this down step by step:\n\n**Step 1: Inner Subquery to Get the Previous Day\u2019s Temperature**\n\n```sql\n        SELECT \n            w2.temperature\n        FROM \n            Weather w2\n        WHERE \n            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)\n```\n\nThe inner query is responsible for retrieving the temperature of the day before the date currently under consideration in the outer query. \n\nIt utilizes the `DATE_SUB` function to find the date one day before the `recordDate` in the outer query (`w1.recordDate`) and then fetches the temperature recorded on that previous date from the same Weather table (alias `w2`).\n\n**Step 2: Outer Query to Find Days with Higher Temperature**\n\n```sql\nSELECT \n    w1.id\nFROM \n    Weather w1\nWHERE \n    w1.temperature > (\n        -- ... (inner subquery)\n    );\n```\n\nThe outer query iterates over each row (each day) in the Weather table (alias `w1`) and checks if the temperature on that day is greater than the temperature on the previous day, the latter being obtained from the inner subquery.\n\n**Step 3: Comparing Temperatures**\n\n```sql\n    w1.temperature > (\n        -- ... (inner subquery)\n    )\n```\n\nHere, we have the crucial comparison that serves our goal. For each day in the outer query, it checks whether the temperature is greater than the temperature fetched from the inner subquery (which is the temperature of the previous day).\n\n**Step 4: Selecting the ID**\n\n```sql\nSELECT \n    w1.id\n```\n\nIf the condition in the `WHERE` clause is satisfied (today\u2019s temperature is greater than yesterday\u2019s), we select the ID of the current day (from the outer query\u2019s perspective). This ID indicates a day where the temperature was higher than the temperature on the previous day.\n\n#### Implementation\n\n\n\n```mysql []\nSELECT \n    w1.id\nFROM \n    Weather w1\nWHERE \n    w1.temperature > (\n        SELECT \n            w2.temperature\n        FROM \n            Weather w2\n        WHERE \n            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)\n    );\n\n```\n\n### Approach 4: Using Cartesian Product and `WHERE` Clause\n\n#### Intuition\n\nLet's break this down step by step:\n\n**Step 1: Cartesian Product**\n```sql\nFROM \n    Weather w1, Weather w2\n```\n\nIn this step, we are performing a Cartesian product (or cross join) of the `Weather` table with itself. This means we create a new table where each row from `w1` (first instance of the Weather table) is paired with every row from `w2` (second instance of the Weather table), resulting in a table with n\u00b2 rows (where n is the number of rows in the Weather table).\n\n**Step 2: Filtering Based on Date Difference**\n```sql\nWHERE \n    DATEDIFF(w2.recordDate, w1.recordDate) = 1 \n```\n\nNext, we use the `DATEDIFF` function to find pairs of rows where the difference between the 'recordDate' in w2 and w1 is exactly 1 day. This effectively filters down to pairs of rows representing consecutive days.\n\n**Step 3: Filtering Based on Temperature Difference**\n```sql\nAND \n    w2.temperature > w1.temperature;\n```\n\nIn this step, we are filtering the pairs further to retain only those where the temperature on the second day (`w2.temperature`) is greater than the temperature on the first day (`w1.temperature`). This finds the days where the temperature is rising compared to the previous day.\n\n**Step 4: Selecting the Result**\n```sql\nSELECT \n    w2.id\n```\n\nFinally, from all the pairs that satisfy the conditions set in the WHERE clause, we select the ID of the day from the w2 table (i.e., the ID of the day with the higher temperature).\n\n\n#### Implementation\n\n\n\n```mysql []\nSELECT \n    w2.id\nFROM \n    Weather w1, Weather w2\nWHERE \n    DATEDIFF(w2.recordDate, w1.recordDate) = 1 \nAND \n    w2.temperature > w1.temperature;\n\n```"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rising-temperature/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "198",
        "questionFrontendId": "198",
        "title": "House Robber",
        "content": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,9,3,1]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n",
        "likes": 22073,
        "dislikes": 466,
        "stats": "{\"totalAccepted\": \"2.8M\", \"totalSubmission\": \"5.4M\", \"totalAcceptedRaw\": 2811738, \"totalSubmissionRaw\": 5396842, \"acRate\": \"52.1%\"}",
        "similarQuestions": "[{\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House\", \"titleSlug\": \"paint-house\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint Fence\", \"titleSlug\": \"paint-fence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber III\", \"titleSlug\": \"house-robber-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Non-negative Integers without Consecutive Ones\", \"titleSlug\": \"non-negative-integers-without-consecutive-ones\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Coin Path\", \"titleSlug\": \"coin-path\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Delete and Earn\", \"titleSlug\": \"delete-and-earn\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Solving Questions With Brainpower\", \"titleSlug\": \"solving-questions-with-brainpower\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Number of Ways to Place Houses\", \"titleSlug\": \"count-number-of-ways-to-place-houses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber IV\", \"titleSlug\": \"house-robber-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Mice and Cheese\", \"titleSlug\": \"mice-and-cheese\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Largest Element in an Array after Merge Operations\", \"titleSlug\": \"largest-element-in-an-array-after-merge-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/house-robber/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "199",
        "questionFrontendId": "199",
        "title": "Binary Tree Right Side View",
        "content": "<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,null,5,null,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,4]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png\" style=\"width: 400px; height: 207px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,null,null,null,5]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,4,5]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png\" style=\"width: 400px; height: 214px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 12638,
        "dislikes": 1057,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1757530, \"totalSubmissionRaw\": 2653956, \"acRate\": \"66.2%\"}",
        "similarQuestions": "[{\"title\": \"Populating Next Right Pointers in Each Node\", \"titleSlug\": \"populating-next-right-pointers-in-each-node\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Boundary of Binary Tree\", \"titleSlug\": \"boundary-of-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/binary-tree-right-side-view/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "200",
        "questionFrontendId": "200",
        "title": "Number of Islands",
        "content": "<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>\n\n<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "likes": 23681,
        "dislikes": 559,
        "stats": "{\"totalAccepted\": \"3.4M\", \"totalSubmission\": \"5.4M\", \"totalAcceptedRaw\": 3352775, \"totalSubmissionRaw\": 5418267, \"acRate\": \"61.9%\"}",
        "similarQuestions": "[{\"title\": \"Surrounded Regions\", \"titleSlug\": \"surrounded-regions\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Islands II\", \"titleSlug\": \"number-of-islands-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Connected Components in an Undirected Graph\", \"titleSlug\": \"number-of-connected-components-in-an-undirected-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Battleships in a Board\", \"titleSlug\": \"battleships-in-a-board\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Distinct Islands\", \"titleSlug\": \"number-of-distinct-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Max Area of Island\", \"titleSlug\": \"max-area-of-island\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Sub Islands\", \"titleSlug\": \"count-sub-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All Groups of Farmland\", \"titleSlug\": \"find-all-groups-of-farmland\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Unreachable Pairs of Nodes in an Undirected Graph\", \"titleSlug\": \"count-unreachable-pairs-of-nodes-in-an-undirected-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Fish in a Grid\", \"titleSlug\": \"maximum-number-of-fish-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Union Find"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/number-of-islands/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "201",
        "questionFrontendId": "201",
        "title": "Bitwise AND of Numbers Range",
        "content": "<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 5, right = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 0, right = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 1, right = 2147483647\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 4127,
        "dislikes": 309,
        "stats": "{\"totalAccepted\": \"448K\", \"totalSubmission\": \"942.1K\", \"totalAcceptedRaw\": 447973, \"totalSubmissionRaw\": 942063, \"acRate\": \"47.6%\"}",
        "similarQuestions": "[{\"title\": \"Longest Nice Subarray\", \"titleSlug\": \"longest-nice-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "202",
        "questionFrontendId": "202",
        "title": "Happy Number",
        "content": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>\n\n<p>A <strong>happy number</strong> is a number defined by the following process:</p>\n\n<ul>\n\t<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>\n\t<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>\n\t<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 19\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\n1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 11026,
        "dislikes": 1553,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"3.2M\", \"totalAcceptedRaw\": 1819149, \"totalSubmissionRaw\": 3150029, \"acRate\": \"57.8%\"}",
        "similarQuestions": "[{\"title\": \"Linked List Cycle\", \"titleSlug\": \"linked-list-cycle\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Digits\", \"titleSlug\": \"add-digits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Ugly Number\", \"titleSlug\": \"ugly-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Digits of String After Convert\", \"titleSlug\": \"sum-of-digits-of-string-after-convert\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Addition to Make Integer Beautiful\", \"titleSlug\": \"minimum-addition-to-make-integer-beautiful\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Value After Replacing With Sum of Prime Factors\", \"titleSlug\": \"smallest-value-after-replacing-with-sum-of-prime-factors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count the Digits That Divide a Number\", \"titleSlug\": \"count-the-digits-that-divide-a-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/happy-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "203",
        "questionFrontendId": "203",
        "title": "Remove Linked List Elements",
        "content": "<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,6,3,4,5,6], val = 6\n<strong>Output:</strong> [1,2,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [], val = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [7,7,7,7], val = 7\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n",
        "likes": 8637,
        "dislikes": 265,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 1333558, \"totalSubmissionRaw\": 2593304, \"acRate\": \"51.4%\"}",
        "similarQuestions": "[{\"title\": \"Remove Element\", \"titleSlug\": \"remove-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Delete Node in a Linked List\", \"titleSlug\": \"delete-node-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete the Middle Node of a Linked List\", \"titleSlug\": \"delete-the-middle-node-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete Nodes From Linked List Present in Array\", \"titleSlug\": \"delete-nodes-from-linked-list-present-in-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Convert Doubly Linked List to Array I\", \"titleSlug\": \"convert-doubly-linked-list-to-array-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Convert Doubly Linked List to Array II\", \"titleSlug\": \"convert-doubly-linked-list-to-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-linked-list-elements/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "204",
        "questionFrontendId": "204",
        "title": "Count Primes",
        "content": "<p>Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 5 * 10<sup>6</sup></code></li>\n</ul>\n",
        "likes": 8299,
        "dislikes": 1506,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"3M\", \"totalAcceptedRaw\": 1030497, \"totalSubmissionRaw\": 2982335, \"acRate\": \"34.6%\"}",
        "similarQuestions": "[{\"title\": \"Ugly Number\", \"titleSlug\": \"ugly-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Perfect Squares\", \"titleSlug\": \"perfect-squares\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Common Factors\", \"titleSlug\": \"number-of-common-factors\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Prime Pairs With Target Sum\", \"titleSlug\": \"prime-pairs-with-target-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Count of Numbers Which Are Not Special\", \"titleSlug\": \"find-the-count-of-numbers-which-are-not-special\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Checking all the integers in the range [1, n - 1] is not efficient. Think about a better approach.",
          "Since most of the numbers are not primes, we need a fast approach to exclude the non-prime integers.",
          "Use Sieve of Eratosthenes."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Enumeration"
          },
          {
            "name": "Number Theory"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-primes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "205",
        "questionFrontendId": "205",
        "title": "Isomorphic Strings",
        "content": "<p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>\n\n<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>\n\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;egg&quot;, t = &quot;add&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The strings <code>s</code> and <code>t</code> can be made identical by:</p>\n\n<ul>\n\t<li>Mapping <code>&#39;e&#39;</code> to <code>&#39;a&#39;</code>.</li>\n\t<li>Mapping <code>&#39;g&#39;</code> to <code>&#39;d&#39;</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;foo&quot;, t = &quot;bar&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The strings <code>s</code> and <code>t</code> can not be made identical as <code>&#39;o&#39;</code> needs to be mapped to both <code>&#39;a&#39;</code> and <code>&#39;r&#39;</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;paper&quot;, t = &quot;title&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>t.length == s.length</code></li>\n\t<li><code>s</code> and <code>t</code> consist of any valid ascii character.</li>\n</ul>\n",
        "likes": 9640,
        "dislikes": 2193,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 1726115, \"totalSubmissionRaw\": 3706032, \"acRate\": \"46.6%\"}",
        "similarQuestions": "[{\"title\": \"Word Pattern\", \"titleSlug\": \"word-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find and Replace Pattern\", \"titleSlug\": \"find-and-replace-pattern\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/isomorphic-strings/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "206",
        "questionFrontendId": "206",
        "title": "Reverse Linked List",
        "content": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [5,4,3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n",
        "likes": 22750,
        "dislikes": 517,
        "stats": "{\"totalAccepted\": \"5.1M\", \"totalSubmission\": \"6.5M\", \"totalAcceptedRaw\": 5126005, \"totalSubmissionRaw\": 6500034, \"acRate\": \"78.9%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Linked List II\", \"titleSlug\": \"reverse-linked-list-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Upside Down\", \"titleSlug\": \"binary-tree-upside-down\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Linked List\", \"titleSlug\": \"palindrome-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Reverse Nodes in Even Length Groups\", \"titleSlug\": \"reverse-nodes-in-even-length-groups\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Twin Sum of a Linked List\", \"titleSlug\": \"maximum-twin-sum-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Remove Nodes From Linked List\", \"titleSlug\": \"remove-nodes-from-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Insert Greatest Common Divisors in Linked List\", \"titleSlug\": \"insert-greatest-common-divisors-in-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-linked-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "207",
        "questionFrontendId": "207",
        "title": "Course Schedule",
        "content": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 16968,
        "dislikes": 796,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"4.1M\", \"totalAcceptedRaw\": 2014908, \"totalSubmissionRaw\": 4134500, \"acRate\": \"48.7%\"}",
        "similarQuestions": "[{\"title\": \"Course Schedule II\", \"titleSlug\": \"course-schedule-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Graph Valid Tree\", \"titleSlug\": \"graph-valid-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Height Trees\", \"titleSlug\": \"minimum-height-trees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Course Schedule III\", \"titleSlug\": \"course-schedule-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Build a Matrix With Conditions\", \"titleSlug\": \"build-a-matrix-with-conditions\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
          "<a href=\"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf\" target=\"_blank\">Topological Sort via DFS</a> - A great tutorial explaining the basic concepts of Topological Sort.",
          "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
        ],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Topological Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/course-schedule/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "208",
        "questionFrontendId": "208",
        "title": "Implement Trie (Prefix Tree)",
        "content": "<p>A <a href=\"https://en.wikipedia.org/wiki/Trie\" target=\"_blank\"><strong>trie</strong></a> (pronounced as &quot;try&quot;) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>\n\n<p>Implement the Trie class:</p>\n\n<ul>\n\t<li><code>Trie()</code> Initializes the trie object.</li>\n\t<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>\n\t<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>\n\t<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]\n[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]\n<strong>Output</strong>\n[null, null, true, false, true, null, true]\n\n<strong>Explanation</strong>\nTrie trie = new Trie();\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // return True\ntrie.search(&quot;app&quot;);     // return False\ntrie.startsWith(&quot;app&quot;); // return True\ntrie.insert(&quot;app&quot;);\ntrie.search(&quot;app&quot;);     // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n\t<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li>\n</ul>\n",
        "likes": 11973,
        "dislikes": 148,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1283664, \"totalSubmissionRaw\": 1896306, \"acRate\": \"67.7%\"}",
        "similarQuestions": "[{\"title\": \"Design Add and Search Words Data Structure\", \"titleSlug\": \"design-add-and-search-words-data-structure\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Design Search Autocomplete System\", \"titleSlug\": \"design-search-autocomplete-system\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Replace Words\", \"titleSlug\": \"replace-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Implement Magic Dictionary\", \"titleSlug\": \"implement-magic-dictionary\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Encrypt and Decrypt Strings\", \"titleSlug\": \"encrypt-and-decrypt-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Implement Trie II (Prefix Tree)\", \"titleSlug\": \"implement-trie-ii-prefix-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Prefix and Suffix Pairs II\", \"titleSlug\": \"count-prefix-and-suffix-pairs-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Prefix and Suffix Pairs I\", \"titleSlug\": \"count-prefix-and-suffix-pairs-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Design"
          },
          {
            "name": "Trie"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/implement-trie-prefix-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "209",
        "questionFrontendId": "209",
        "title": "Minimum Size Subarray Sum",
        "content": "<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword=\"subarray-nonempty\"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 4, nums = [1,4,4]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.",
        "likes": 13311,
        "dislikes": 491,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 1405055, \"totalSubmissionRaw\": 2868613, \"acRate\": \"49.0%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Size Subarray Sum Equals k\", \"titleSlug\": \"maximum-size-subarray-sum-equals-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Length of Repeated Subarray\", \"titleSlug\": \"maximum-length-of-repeated-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Reduce X to Zero\", \"titleSlug\": \"minimum-operations-to-reduce-x-to-zero\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"K Radius Subarray Averages\", \"titleSlug\": \"k-radius-subarray-averages\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Product After K Increments\", \"titleSlug\": \"maximum-product-after-k-increments\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Subarray With OR at Least K I\", \"titleSlug\": \"shortest-subarray-with-or-at-least-k-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Positive Sum Subarray \", \"titleSlug\": \"minimum-positive-sum-subarray\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Sliding Window"
          },
          {
            "name": "Prefix Sum"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an array of positive integers `nums` and a positive integer `target`, our task is to return the minimal length of a subarray whose sum is greater than or equal to `target`. If there is no such subarray, we have to return `0`.\n\n---\n\n### Approach: Sliding Window\n\n#### Intuition\n\nAn intuitive technique is to go through all the subarrays one by one and check the sum of each one. If the total of the subarray under consideration is larger than or equal to `target`, we attempt to update our answer variable by using the minimum of the current answer and the length of this subarray. To get all the subarrays, we can run two loops: the outer loop selects a starting point and the inner loop selects an ending point. This solution, however, will take $O(n^2)$ time, resulting in a time limit exceeded (TLE).\n\nLet's think whether we really need to iterate over all the subarrays. \n\nGiven that we only have positive integers, there is no purpose in adding further elements to a subarray if its sum exceeds or equals `target`. Adding more elements to such a subarray will result in the construction of longer subarrays, which is useless because we have already found a smaller subarray that meets our requirements.\n\nOnly if the sum of the current subarray under consideration is smaller than `target`, we should append elements to the subarray. When the sum of the subarrays exceeds or equals `target`, we will attempt to update our answer with the length of the current subarray.\n\nWe now try to remove the elements from the start and see if we can form a smaller subarray that meets our requirements. We remove the first element from the subarray and check if we still have the total higher than or equal to `target`. If the total exceeds or equals `target`, we have a smaller subarray that meets our requirement. As a result, we again try to update our answer with the length of the current subarray and repeat the process of eliminating the first element from the current subarray until the sum no longer exceeds or equals `target`.\n\nNow after removing elements, if the sum of the subarray is less than `target`, we have to append more elements to it until the sum becomes larger than or equal to `target`. We append elements until the sum equals or exceeds `target`, then try to update our answer variable and repeat the process of eliminating the first element.\n\nThe above approach can be efficiently solved using the **sliding window approach**.\n\nIf you are not familiar with sliding window, please refer to our explore cards [Sliding Window Explore Card](https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/).\n\nA sliding window is achieved by using two pointers `left` and `right`, which point to the starting and ending indices of the subarray. We set them to a value of `0`.\n\nTo \"add\" elements to the window, we loop over the array by incrementing `right`. In this problem, if the sum of the window exceeds or equals `target`, we try to update our answer and then \"remove\" elements from the window by incrementing `left` until the sum is less than `target` again.\n\nHere's a visual representation of how the approach works:\n\n!?!../Documents/209/209-slides.json:601,301!?!\n\n#### Algorithm\n\n1. Create three integer variables `left`, `right` and `sumOfCurrentWindow`. The variables `left` and `right` form a subarray by pointing to the starting and ending indices of the current subarray (or window), and `sumOfCurrentWindow` stores the sum of this window. Initialize all of them with `0`.\n2. Create another variable `res` to store the answer to the problem. We initialize it to a large integer value.\n3. We iterate over `nums` using `right` starting from `right = 0` till `nums.length - 1` incrementing `right` by `1` after each iteration. We perform the following inside this iteration: \n    - Add element at index `right` to the current window, incrementing `sumOfCurrentWindow` by `nums[right]`.\n    - We check if `sumOfCurrentWindow >= target`. If so, we have a subarray that satisfies our condition. As a result, we attempt to update our answer variable with the length of this subarray. We perform `res = min(res, right - left + 1)`. We then remove the first element from this window by reducing `sumOfCurrentWindow` by `nums[left]` and incrementing `left` by `1`. This step is repeated in an inner loop as long as `sumOfCurrentWindow >= target`.\n    - The current window's sum is now smaller than `target`. We need to add more elements to it. As a result, `right` is incremented by `1`.\n4. Return `res`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/AX72e7bN/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"AX72e7bN\"></iframe>\n\n#### Complexity Analysis\n\nHere $n$ is the length of `nums`.\n\n* Time complexity: $O(n)$.\n    - You may be thinking: there is an inner while loop inside another for loop, isn't the time complexity $O(n^2)$? The reason it is still $O(n)$ is because the right pointer `right` can move $n$ times and the left pointer `left` can move also $n$ times in total. The inner loop is not running $n$ times for each iteration of the outer loop. A sliding window guarantees a maximum of $2n$ window iterations. This is what is referred to as [amortized analysis](https://en.wikipedia.org/wiki/Amortized_analysis) - even though the worst case for an iteration inside the for loop is $O(n)$, it averages out to $O(1)$ when you consider the entire runtime of the algorithm.\n\n* Space complexity: $O(1)$.\n    - We are not using any extra space other than a few integer variables:`left`, `right`, `sumOfCurrentWindow`, and `res`, which takes up constant space each."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-size-subarray-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "210",
        "questionFrontendId": "210",
        "title": "Course Schedule II",
        "content": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n",
        "likes": 11263,
        "dislikes": 361,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1327006, \"totalSubmissionRaw\": 2507014, \"acRate\": \"52.9%\"}",
        "similarQuestions": "[{\"title\": \"Course Schedule\", \"titleSlug\": \"course-schedule\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Alien Dictionary\", \"titleSlug\": \"alien-dictionary\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Height Trees\", \"titleSlug\": \"minimum-height-trees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sequence Reconstruction\", \"titleSlug\": \"sequence-reconstruction\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Course Schedule III\", \"titleSlug\": \"course-schedule-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Parallel Courses\", \"titleSlug\": \"parallel-courses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All Possible Recipes from Given Supplies\", \"titleSlug\": \"find-all-possible-recipes-from-given-supplies\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Build a Matrix With Conditions\", \"titleSlug\": \"build-a-matrix-with-conditions\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sort Array by Moving Items to Empty Space\", \"titleSlug\": \"sort-array-by-moving-items-to-empty-space\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
          "<a href=\"https://www.youtube.com/watch?v=ozso3xxkVGU\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.",
          "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
        ],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Topological Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/course-schedule-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "211",
        "questionFrontendId": "211",
        "title": "Design Add and Search Words Data Structure",
        "content": "<p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>\n\n<p>Implement the <code>WordDictionary</code> class:</p>\n\n<ul>\n\t<li><code>WordDictionary()</code>&nbsp;Initializes the object.</li>\n\t<li><code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.</li>\n\t<li><code>bool search(word)</code>&nbsp;Returns <code>true</code> if there is any string in the data structure that matches <code>word</code>&nbsp;or <code>false</code> otherwise. <code>word</code> may contain dots <code>&#39;.&#39;</code> where dots can be matched with any letter.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]\n[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]\n<strong>Output</strong>\n[null,null,null,null,false,true,true,true]\n\n<strong>Explanation</strong>\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(&quot;bad&quot;);\nwordDictionary.addWord(&quot;dad&quot;);\nwordDictionary.addWord(&quot;mad&quot;);\nwordDictionary.search(&quot;pad&quot;); // return False\nwordDictionary.search(&quot;bad&quot;); // return True\nwordDictionary.search(&quot;.ad&quot;); // return True\nwordDictionary.search(&quot;b..&quot;); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 25</code></li>\n\t<li><code>word</code> in <code>addWord</code> consists of lowercase English letters.</li>\n\t<li><code>word</code> in <code>search</code> consist of <code>&#39;.&#39;</code> or lowercase English letters.</li>\n\t<li>There will be at most <code>2</code> dots in <code>word</code> for <code>search</code> queries.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>addWord</code> and <code>search</code>.</li>\n</ul>\n",
        "likes": 7817,
        "dislikes": 474,
        "stats": "{\"totalAccepted\": \"755.1K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 755055, \"totalSubmissionRaw\": 1610461, \"acRate\": \"46.9%\"}",
        "similarQuestions": "[{\"title\": \"Implement Trie (Prefix Tree)\", \"titleSlug\": \"implement-trie-prefix-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Prefix and Suffix Search\", \"titleSlug\": \"prefix-and-suffix-search\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Match Substring After Replacement\", \"titleSlug\": \"match-substring-after-replacement\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum of Prefix Scores of Strings\", \"titleSlug\": \"sum-of-prefix-scores-of-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Prefix and Suffix Pairs II\", \"titleSlug\": \"count-prefix-and-suffix-pairs-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Prefix and Suffix Pairs I\", \"titleSlug\": \"count-prefix-and-suffix-pairs-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You should be familiar with how a Trie works. If not, please work on this problem: <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Implement Trie (Prefix Tree)</a> first."
        ],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Design"
          },
          {
            "name": "Trie"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "212",
        "questionFrontendId": "212",
        "title": "Word Search II",
        "content": "<p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>\n\n<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" style=\"width: 322px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]\n<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> is a lowercase English letter.</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are unique.</li>\n</ul>\n",
        "likes": 9756,
        "dislikes": 487,
        "stats": "{\"totalAccepted\": \"772.3K\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 772339, \"totalSubmissionRaw\": 2080405, \"acRate\": \"37.1%\"}",
        "similarQuestions": "[{\"title\": \"Word Search\", \"titleSlug\": \"word-search\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Unique Paths III\", \"titleSlug\": \"unique-paths-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Encrypt and Decrypt Strings\", \"titleSlug\": \"encrypt-and-decrypt-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?",
          "If the current candidate does not exist in all words&#39; prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Implement Trie (Prefix Tree)</a> first."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Trie"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/word-search-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "213",
        "questionFrontendId": "213",
        "title": "House Robber II",
        "content": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 10384,
        "dislikes": 170,
        "stats": "{\"totalAccepted\": \"966.5K\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 966487, \"totalSubmissionRaw\": 2232443, \"acRate\": \"43.3%\"}",
        "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House\", \"titleSlug\": \"paint-house\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint Fence\", \"titleSlug\": \"paint-fence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber III\", \"titleSlug\": \"house-robber-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Non-negative Integers without Consecutive Ones\", \"titleSlug\": \"non-negative-integers-without-consecutive-ones\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Coin Path\", \"titleSlug\": \"coin-path\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Since House[1] and House[n] are adjacent, they cannot be robbed together. Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], depending on which choice offers more money. Now the problem has degenerated to the <a href =\"https://leetcode.com/problems/house-robber/description/\">House Robber</a>, which is already been solved."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/house-robber-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "214",
        "questionFrontendId": "214",
        "title": "Shortest Palindrome",
        "content": "<p>You are given a string <code>s</code>. You can convert <code>s</code> to a <span data-keyword=\"palindrome-string\">palindrome</span> by adding characters in front of it.</p>\n\n<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aacecaaa\"\n<strong>Output:</strong> \"aaacecaaa\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"abcd\"\n<strong>Output:</strong> \"dcbabcd\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
        "likes": 4352,
        "dislikes": 277,
        "stats": "{\"totalAccepted\": \"303.3K\", \"totalSubmission\": \"749.8K\", \"totalAcceptedRaw\": 303283, \"totalSubmissionRaw\": 749818, \"acRate\": \"40.4%\"}",
        "similarQuestions": "[{\"title\": \"Longest Palindromic Substring\", \"titleSlug\": \"longest-palindromic-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Index of the First Occurrence in a String\", \"titleSlug\": \"find-the-index-of-the-first-occurrence-in-a-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Palindrome Pairs\", \"titleSlug\": \"palindrome-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Deletions on a String\", \"titleSlug\": \"maximum-deletions-on-a-string\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Smallest Palindromic Rearrangement I\", \"titleSlug\": \"smallest-palindromic-rearrangement-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Rolling Hash"
          },
          {
            "name": "String Matching"
          },
          {
            "name": "Hash Function"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a string `s`. Our task is to build the smallest palindrome by adding characters to the beginning of `s`.\n\nTo solve this, we can reframe the problem as finding the longest palindromic substring that starts from the index `0`. Once we know the length of this substring, we can create the shortest palindrome by appending the reverse of the remaining part of the string to the original string to make `s` a complete palindrome.\n\nFor instance, consider the string `s = \"aacecaaa\"`. Here, the longest palindromic prefix is `\"aacecaa\"`(starts at index `0`). The remaining part of the string is just the last `\"a\"`. To create the smallest palindrome, we reverse this remaining part and add it to the front of the original string, resulting in `\"aaacecaaa\"`, which is a palindrome. \n\nAnother example is `s = \"abcd\"`, where the longest palindromic prefix is just the first character `\"a\"`. The remaining part, `\"bcd\"`, is not a palindrome. By reversing `\"bcd\"` and adding it to the start, we get `\"dcbabcd\"`, which is the smallest palindrome that can be formed from the original string. This way, we can find the shortest palindrome by adding only the necessary characters to the front of the string.\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nAs we know, a palindrome reads the same forwards and backwards. Therefore, the challenge is to identify the longest prefix of the original string that can be extended to a full palindrome by only adding characters at the start.\n\nFirst, we need to find out which part of the string is already a palindrome. So, we check the original string and see how much of it matches the end of its reversed version. This helps us figure out the longest palindromic prefix.\n\nTo do this, we look at different prefixes of the original string and compare them to suffixes of the reversed string. If a prefix matches a suffix of the reversed string, it\u2019s part of a palindrome.\n\nOnce we find the longest palindromic prefix, we need to reverse the rest of the string (the part not included in the prefix) and add this reversed part to the start of the original string. This gives us the shortest possible palindrome.\n\nFor example: Let\u2019s take the string `\"abcbabcab\"`. We reverse the string to get `\"bacbabcba\"`. By comparing prefixes of `\"abcbabcab\"` with suffixes of `\"bacbabcba\"`, we find that the longest prefix `\"abcba\"` matches with the suffix `\"abcba\"` in the reversed string. This is a palindrome.\n\nTo form the shortest palindrome, we then need to reverse the remaining part of the original string that doesn\u2019t overlap with this prefix. In our example, the remaining part is `\"bcab\"`. Reversing `\"bcab\"` gives us `\"bacb\"`. Adding this to the start of the original string results in `\"bacbabcbabcab\"`.\n\n#### Algorithm\n\n- Initialize `length` with the length of the string `s`.\n- Reverse the string `s` to get `reversedString`.\n\n- Iterate through the string from `0` to `length - 1`:\n  - For each index `i`, check if the substring `s.substring(0, length - i)` (i.e., the prefix of `s` up to `length - i`) is equal to the substring `reversedString.substring(i)` (i.e., the suffix of `reversedString` starting from `i`).\n  - If they are equal, it means the prefix of `s` is a palindrome:\n    - Return the concatenation of `reversedString.substring(0, i)` (i.e., the characters in `reversedString` before `i`) and the original string `s`.\n\n- If no valid prefix is found that satisfies the condition, return an empty string `\"\"`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/HTCP8cwb/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"HTCP8cwb\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string $s$.\n\n- Time complexity: $O(n^2)$\n\n    The reversal of the string `s` involves traversing the string once, which has a time complexity of $O(n)$.\n    \n    In the loop, for each iteration, we check if the substring of length $n - i$ of `s` matches the substring of length $n - i$ of the reversed string. Each check involves string operations that are linear in the length of the substring being compared. Thus, for each iteration $i$, the comparison is $O(n - i)$. Since $i$ ranges from 0 to $n - 1$, the total time complexity of the palindrome check part can be expressed as the sum of comparisons of decreasing lengths. This sum is roughly $O(n^2)$.\n    \n    Combining these operations, the overall time complexity is $O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    Creating the reversed string involves additional space proportional to the length of the input string, i.e., $O(n)$.\n    \n    The substring operations in the `for` loop do not require additional space proportional to the length of the string but do create new string objects temporarily, which is still $O(n)$ space for each substring.\n    \n    Therefore, the overall space complexity is $O(n)$.\n\n---\n\n### Approach 2: Two Pointer\n\n#### Intuition\n\nIn the brute force approach, we observe that we need to identify the longest palindromic prefix of a string. To do this, we can now use a method involving two pointers. This method is a bit more efficient compared to checking every possible substring, which would take longer.\n\nLet's consider an example string: `\"abcbabcaba\"`. We use two pointers, `left` and `right`. We start by setting `left` to `0`. Then, we move the `right` pointer from the end of the string to the beginning. Each time the characters at `left` and `right` match, we increment `left`.\n\nBy following this process, we narrow our search to the substring from the beginning of the string up to `left`. This substring will always include the longest palindromic prefix.\n\n- If the entire string were a perfect palindrome, the `left` pointer would move through the entire length of the string, reaching the end (`n` times).\n- If the string isn\u2019t a perfect palindrome, the `left` pointer will still move forward by the length of the palindromic part at the beginning.\n\nTherefore, while the substring $[0, \\text{left})$ may not always be the tightest fit, it will always contain the longest palindromic prefix.\n\nThe best-case scenario for this algorithm is when the entire string is a palindrome. In this case, the `left` pointer will reach the end of the string quickly. The worst-case scenario is when the string is something like `\"aababababababa\"`. Here, `left` initially becomes `12`, meaning we need to recheck the substring $[0, 12)$. As we continue, `left` might decrease to `10`, and so on. In this worst-case scenario, the substring is reduced by only a few elements at each step, making the total number of steps proportional to the length of the string, or $O(n)$.\n\n#### Algorithm\n\n- If the string `s` is empty, return `s` immediately.\n\n- Find the longest palindromic prefix:\n  - Initialize `left` to 0.\n  - Iterate `right` from the end of the string (`length - 1`) to the start (0):\n    - If the character at `right` matches the character at `left`:\n      - Increment `left`.\n\n- If `left` equals the length of the string, `s` is already a palindrome, so return `s`.\n\n- Extract the suffix that is not part of the palindromic prefix:\n  - Create `nonPalindromeSuffix` as the substring from `left` to the end of `s`.\n  - Reverse `nonPalindromeSuffix` to create `reverseSuffix`.\n\n- Form the shortest palindrome:\n  - Recursively call `shortestPalindrome` on the substring from the start to `left` (i.e., `s.substring(0, left)`).\n  - Concatenate `reverseSuffix`, the result of the recursive call, and `nonPalindromeSuffix`.\n\n- Return the concatenated result as the shortest palindrome.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/X6dVgEa4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"X6dVgEa4\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.\n\n- Time Complexity: $O(n^2)$\n\n    Each iteration of the `shortestPalindrome` function operates on a substring of size `n`. In the worst-case scenario, where the string is not a palindrome and we must continually reduce its size, the function might need to be called up to `n/2` times.\n\n    The time complexity $T(n)$ represents the total time taken by the algorithm. At each step, the algorithm processes a substring and then works with a smaller substring by removing two characters. This can be expressed as $T(n) = T(n-2) + O(n)$, where $O(n)$ is the time taken to process the substring of size `n`.\n\n    Summing up all the steps, we get:\n    $T(n) = O(n) + O(n-2) + O(n-4) + \\ldots + O(1)$\n  \n    This sum of terms approximates to $O(n^2)$ because it is an arithmetic series where the number of terms grows linearly with `n`.\n\n- Space Complexity: $O(n)$\n\n    The space complexity is linear, $O(n)$, due to the space needed to store the reversed suffix and other temporary variables.\n\n---\n\n### Approach 3: KMP (Knuth-Morris-Pratt) Algorithm\n\n#### Intuition\n\nThe KMP algorithm is used for pattern matching within strings. The KMP algorithm computes prefix functions to identify substrings that match specific patterns. In our case, we use this efficiency to compute the longest palindromic prefix. We construct a combined string of the original string, a special delimiter, and the reversed original string. By applying KMP, we can determine the longest prefix of the original string that matches a suffix of the reversed string.\n\nFirst, we construct a new string by concatenating the original string, a delimiter (such as `\"#\"`), and the reversed original string. This combined string looks like `\"original#reversed\"`. The delimiter `\"#\"` is crucial because it ensures that we are only comparing the original string with its reversed version, and not inadvertently matching parts of the reversed string with itself.\n\nTo proceed, we calculate the prefix function for this combined string. The prefix function or partial match table is an array where each element at index `i` indicates the length of the longest prefix of the substring ending at `i` which is also a suffix. This helps us identify the longest segment where the prefix of the original string matches a suffix in the reversed string. The purpose is to identify how much of the original string matches a suffix of the reversed string.\n\n</br>\n\nFor example: We construct a combined string using the original string `s`, a delimiter `\"#\"`, and the reversed version of `s`. This combined string helps us find the longest palindromic prefix by applying the KMP algorithm. For the string `\"aacecaaa\"`, the reversed string is `\"aaacecaa\"`. Thus, the combined string becomes `\"aacecaaa#aaacecaa\"`.\n\nThe prefix function helps us determine the length of the longest prefix of the original string that can be matched by a suffix of the reversed string. For the combined string `\"aacecaaa#aaacecaa\"`, the prefix function will reveal that the longest palindromic prefix of `\"aacecaaa\"` is `\"aacecaa\"`.\n\nTo create the shortest palindrome, we need to prepend characters to the original string. Specifically, we reverse the portion of the original string that extends beyond the longest palindromic prefix and prepend it. In this case, the part of the original string that extends beyond `\"aacecaa\"` is `\"a\"`. Reversing `\"a\"` gives `\"a\"`, so we prepend `\"a\"` to `\"aacecaaa\"` and the result is `\"aaacecaaa\"`.\n\n</br>\n\n</br>\n\nThe algorithm to generate the prefix table is described below:\n\n```java\nprefixTable[0] = 0;\nfor (int i = 1; i < n; i++) {\n    int length = prefixTable[i - 1];\n    while (length > 0 && s.charAt(i) != s.charAt(length)) {\n        length = prefixTable[length - 1];\n    }\n    if (s.charAt(i) == s.charAt(length)) {\n        length++;\n    }\n    prefixTable[i] = length;\n}\n```\n\n* Begin by setting `prefixTable[0] = 0` since there is no proper prefix for the first character.\n* Next, iterate over `i` from 1 to `n - 1`:\n    * Set `length = prefixTable[i - 1]`, which represents the longest prefix length for the substring up to the previous character.\n    * While `length > 0` and the character at position `i` doesn't match the character at position `length`, set `length = prefixTable[length - 1]`. This step is essential when we encounter a mismatch, and we attempt to match a shorter prefix, which is the value of `prefixTable[length - 1]`, until either we find a match or `length` becomes 0.\n    * If `s.charAt(i) == s.charAt(length)`, we increment `length` by 1 (extend the matching prefix).\n    * Finally, set `prefixTable[i] = length`.\n\nThe lookup table generation is as illustrated below:\n\n![KMP](../Figures/214/shortest_palindrome_KMP.png)\n\n\n#### Algorithm\n\n- `shortestPalindrome` function:\n  - Create `reversedString` by reversing the input string `s`.\n  - Concatenate `s`, a separator `#`, and `reversedString` to form `combinedString`.\n  - Call `buildPrefixTable(combinedString)` to compute the prefix table for `combinedString`.\n  - Extract the length of the longest palindromic prefix from the last value in the prefix table (`prefixTable[combinedString.length() - 1]`).\n  - Compute `suffix` by taking the substring of `s` starting from the length of the longest palindromic prefix.\n  - Reverse `suffix` and prepend it to `s` to form and return the shortest palindrome.\n\n- `buildPrefixTable` function:\n  - Initialize `prefixTable` with the same length as the input string `s` and set `length` to `0`.\n  - Iterate over `s` from index `1` to the end:\n    - While `length` is greater than `0` and the current character does not match the character at the current length, update `length` to the value at `prefixTable[length - 1]`.\n    - If the current character matches the character at `length`, increment `length`.\n    - Set `prefixTable[i]` to the current `length`.\n  - Return the `prefixTable`.\n\n- The result is the shortest palindrome string formed by appending the reversed suffix of `s` to `s`.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/N4VVxjKz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"N4VVxjKz\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.\n\n- Time complexity: $O(n)$\n\n    Creating the reversed string requires a pass through the original string, which takes $O(n)$ time.\n\n    Concatenating `s`, `#`, and `reversedString` takes $O(n)$ time, as concatenating strings of length $n$ is linear in the length of the strings.\n\n    Constructing the prefix table involves iterating over the combined string of length $2n + 1$. The `buildPrefixTable` method runs in $O(m)$ time, where $m$ is the length of the combined string. In this case, $m = 2n + 1$, so the time complexity is $O(n)$.\n\n    Extracting the suffix and reversing it are both $O(n)$ operations.\n\n    Combining these, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(n)$\n    \n    The `reversedString` and `combinedString` each use $O(n)$ space.\n    \n    The `prefixTable` array has a size of $2n + 1$, which is $O(n)$. Other variables used (such as `length` and indices) use $O(1)$ space.\n\n    Combining these, the overall space complexity is $O(n)$.\n\n---\n\n### Approach 4: Rolling Hash Based Algorithm\n\n#### Intuition\n\nThe rolling hash approach uses hash functions to efficiently compare different substrings of the original string with those of the reversed string. Hashing helps determine if a substring matches another by comparing hash values rather than individual characters.\n\nRolling hashes were designed to handle substring matching and comparison problems by allowing incremental updates to hash values as we slide through the string. This reduces the number of comparisons needed by comparing hash values instead of actual substrings.\n\nTo start, we compute hash values for all prefixes of the original string and all suffixes of the reversed string using a rolling hash function. The rolling hash function allows us to update the hash values incrementally, which speeds up the computation compared to recalculating hashes from scratch.\n\nNext, we compare the hash values of the prefixes from the original string with the hash values of the suffixes from the reversed string. When the hash values match, it indicates that the corresponding substrings are identical. This helps us find the longest palindromic prefix.\n\nFor example: Suppose our string is `\"aacecaaa\"`. We calculate hash values for the prefixes of `\"aacecaaa\"` and the suffixes of its reverse, `\"aaacecaa\"`. The hash comparisons reveal that the longest palindromic prefix is `\"aacecaaa\"`. We then reverse the remaining part of the string (`\"a\"`), yielding `\"a\"`. Prepending this reversed part to the original string gives `\"aaacecaaa\"`.\n\n<br/>\n\n##### Hash Calculation Details:\n\nTo give you a clearer idea of how the hashing is calculated, let's see this:\n\nWe initialize two hash values: one for the original string and one for its reversed version. Let\u2019s use base `29` and a large prime modulus $10^9 + 7$ for hashing. We also initialize a variable to keep track of powers of the base.\n\nWe iterate through each character of the original string and compute its hash. Suppose we start with the hash value `0` and process characters one by one:\n\n<br/>\n\n$$\\text{Character } 'a':$$\n\n$$\\text{Update hash:}$$\n\n$$\\text{hash} = (\\text{hash} \\times \\text{base} + \\text{character\\_value}) \\% \\text{mod}$$\n\n$$\\text{Suppose } \\text{character\\_value} \\text{ for } 'a' \\text{ is } 1.$$\n\n$$\\text{hash} = (0 \\times 29 + 1) \\%  1000000007 = 1$$\n\n<br/>\n\n$$\\text{Character } 'a':$$\n\n$$\\text{Update hash:}$$\n\n$$\\text{hash} = (1 \\times 29 + 1) \\% 1000000007 = 30$$\n\n<br/>\n\nContinue this for all characters. After processing `\"aacecaaa\"`, let\u2019s assume the final hash is `23456789` for this substring.\n\nWe do a similar hash calculation for the reversed string `\"aaacecaa\"`. We compute the hash values for each prefix of the reversed string. Let\u2019s assume the final hash of the reversed string is `34567890`.\n\nTo compare substrings, we use a rolling hash. As we move the window of comparison along the combined string, we update the hash values based on the new and old characters entering and exiting the window. If the hash of a prefix of the original string matches the hash of a suffix of the reversed string, that prefix is palindromic. Now the comparison shows that the longest prefix of `\"aacecaaa\"` that matches a suffix of `\"aaacecaa\"` is `\"aacecaa\"`. This tells us that `\"aacecaa\"` is a palindromic segment. Now we identify the remaining part of the original string that extends beyond the palindromic prefix. For `\"aacecaaa\"`, the remaining part is `\"a\"`.\n\nSo we reverse the remaining part (`\"a\"`) to get `\"a\"`, and prepend this reversed part to the original string.\n\nThus the shortest palindrome is `\"aaacecaaa\"`.\n\n#### Algorithm\n\n- Initialize hash parameters:\n  - Set `hashBase` to 29 and `modValue` to $10^9 + 7$.\n  - Initialize `forwardHash` and `reverseHash` to 0.\n  - Initialize `powerValue` to 1.\n  - Initialize `palindromeEndIndex` to -1.\n\n- Iterate over each character `currentChar` in the string `s`:\n  - Update `forwardHash` to include the current character:\n    - Compute `forwardHash` as `(forwardHash * hashBase + (currentChar - 'a' + 1)) % modValue`.\n  - Update `reverseHash` to include the current character:\n    - Compute `reverseHash` as `(reverseHash + (currentChar - 'a' + 1) * powerValue) % modValue`.\n  - Update `powerValue` for the next character:\n    - Compute `powerValue` as `(powerValue * hashBase) % modValue`.\n  - If `forwardHash` matches `reverseHash`, update `palindromeEndIndex` to the current index `i`.\n\n- After the loop, find the suffix that follows the longest palindromic prefix:\n  - Extract the suffix from the string `s` starting from `palindromeEndIndex + 1` to the end.\n  - Reverse the suffix to prepare for prepending.\n\n- Concatenate the reversed suffix to the original string `s` and return the result:\n  - Return `reversedSuffix + s`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ZJD8AXfF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ZJD8AXfF\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.\n\n- Time complexity: $O(n)$\n\n    The algorithm performs a single pass over the input string to compute rolling hashes and determine the longest palindromic prefix, resulting in $O(n)$ time complexity. This pass involves constant-time operations for each character, including hash updates and power calculations. After this, we perform an additional pass to reverse the suffix, which is also $O(n)$. The total time complexity remains $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is determined by the space used for the reversed suffix and the additional string manipulations. The space required for the forward and reverse hash values, power value, and palindrome end index is constant and does not scale with input size. However, storing the reversed suffix and the final result string both require $O(n)$ space. Thus, the space complexity is $O(n)$.\n\n---\n\n### Approach 5: Manacher's Algorithm\n\n#### Intuition\n\n> Note: This algorithm goes beyond what's typically expected in coding interviews. It's more for those who are curious and eager to explore advanced algorithms, simply out of personal interest or a desire to deepen their understanding of data structures and algorithms. If you're someone who loves learning new concepts beyond interview prep, this approach might be for you! Sometimes this is the only algorithm that can give you an $O(n)$ runtime.\n\n</br>\n\nDeveloped to address the problem of finding palindromic substrings efficiently, Manacher\u2019s algorithm preprocesses the string to handle both even and odd-length palindromes uniformly. By inserting special characters between each character of the original string, it computes the radius of the longest palindromic substring centered at each position.\n\nTo handle palindromes of both even and odd lengths uniformly, the algorithm transforms the original string by inserting special characters (e.g., `\"#\"`) between every character and at the boundaries. This way, every palindrome can be treated as if it\u2019s surrounded by characters, making it easier to apply the same expansion logic for all cases.\n\nFor example, the string `\"aacecaaa\"` is transformed into `\"^#a#a#c#e#c#a#a#a#$\"`. Here, `^` and `$` are boundary markers that help avoid out-of-bound errors. `#` helps to treat the string uniformly, making every palindrome appear with a single center.\n\nManacher\u2019s algorithm maintains an array `P` where `P[i]` denotes the radius of the longest palindromic substring centered at the position `i` in the transformed string.\n\n</br>\n\nWe divide Manacher's algorithm into three steps to achieve linear time complexity:\n\n1. Center and Right Boundary: We track the center `C` and right boundary `R` of the rightmost palindrome found so far. For each position `i`, we check if it falls within the current right boundary. If it does, we use previously computed information to estimate the length of the palindrome centered at `i`.\n\n2. Mirror Property: If a position `i` is within the right boundary of a known palindrome, we can infer the length of the palindrome centered at `i` from its mirrored position relative to the current center `C`. This way we reduce the need for direct expansion by leveraging previously computed palindromes to quickly estimate lengths.\n\n3. Expand Around Center: For positions where the estimated palindrome length based on the mirror property is not accurate, we perform direct expansion to find the exact length of the palindrome centered at `i`. We update the center and right boundary if the newly found palindrome extends beyond the current right boundary.\n\n</br>\n\nAfter computing the array `P`, we can determine the longest palindromic prefix of the original string. The longest palindromic substring in the transformed string that corresponds to a prefix of the original string gives us the longest palindromic prefix.\n\nTo form the shortest palindrome, identify the part of the original string that does not contribute to this longest palindromic prefix. Reverse this non-matching segment and prepend it to the original string.\n\nWith the string `\"aacecaaa\"`, after preprocessing to `\"#a#a#c#e#c#a#a#a#\"`, Manacher\u2019s algorithm identifies `\"aacecaaa\"` as the longest palindromic prefix. Reversing the remaining part (`\"a\"`) and prepending it results in `\"aaacecaaa\"`.\n\nWe highly recommend solving the [longest palindromic substring problem using Manacher\u2019s algorithm](https://leetcode.com/problems/longest-palindromic-substring/editorial/). It is extremely efficient and ideal for solving palindrome-related problems.\n\nThis algorithm is complex, so review various sources to gain a better understanding. It's normal if you don\u2019t grasp it right away, so give yourself time.\n\n#### Algorithm\n\n- `shortestPalindrome` function:\n  - If the input string `s` is null or empty, return `s` immediately.\n  - Preprocess the string `s` by calling `preprocessString(s)` to handle edge cases and simplify palindrome detection.\n    - `preprocessString` function:\n      - Initialize a string with a starting character `^`.\n      - Append a `#` followed by each character in `s` to string.\n      - Append a trailing `#` and a dollar sign to complete the modified string.\n      - Return the modified string which includes special boundary characters.\n  - Initialize an integer array `palindromeRadiusArray` to store the radius of the palindrome centered at each character in the modified string.\n  - Initialize `center` and `rightBoundary` to track the center and right boundary of the current longest palindrome found.\n  - Initialize `maxPalindromeLength` to track the length of the longest palindrome that touches the start of the string.\n\n  - Iterate through each character `i` in the modified string (excluding the boundary characters):\n    - Calculate the `mirrorIndex` as `2 * center - i` to utilize previously computed palindromes.\n    - If `rightBoundary` is greater than `i`, update `palindromeRadiusArray[i]` to the minimum of the remaining length to the `rightBoundary` or the radius of the palindrome at `mirrorIndex`.\n    - Expand around the center `i` while the characters match and update `palindromeRadiusArray[i]` accordingly.\n    - If the expanded palindrome extends beyond `rightBoundary`, update `center` and `rightBoundary` to the new values.\n    - If the palindrome touches the start of the string (`i - palindromeRadiusArray[i] == 1`), update `maxPalindromeLength` with the maximum length found.\n\n  - Extract the suffix of the original string starting from `maxPalindromeLength` and reverse it.\n  - Concatenate the reversed suffix with the original string and return the result.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/5kUQ24JZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"5kUQ24JZ\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of the input string.\n\n- Time complexity: $O(n)$\n\n    The `preprocessString` method adds boundaries and separators to the input string. This takes linear time, $O(n)$, where $n$ is the length of the input string.\n\n    The core algorithm iterates through the characters of the modified string once. The expansion step and the updates of the center and right boundary each take constant time in the average case for each character. Thus, this step has a time complexity of $O(m)$, where $m$ is the length of the modified string.\n    \n    Since the length of the modified string is $2n + 1 \\, (\\text{for separators}) + 2 \\, (\\text{for boundaries}) = 2n + 3$ , the time complexity of Manacher's algorithm is $O(n)$.\n\n    Constructing the result involves reversing the suffix of the original string and concatenating it with the original string, both of which take linear time, $O(n)$.\n\n    Combining these steps, the total time complexity is $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space used to store the modified string is proportional to its length, which is $2n + 3$. Therefore, the space complexity for storing this string is $O(n)$.\n\n    The `palindromeRadiusArray` is used to store the radius of palindromes for each character in the modified string, which is $O(m)$. Since $m$ is $2n + 3$, the space complexity for this array is $O(n)$.\n\n    The additional space used for temporary variables, and other operations is constant, $O(1)$.\n\n    Combining these factors, the total space complexity is $O(n)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/shortest-palindrome/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "215",
        "questionFrontendId": "215",
        "title": "Kth Largest Element in an Array",
        "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>largest element in the array</em>.</p>\n\n<p>Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>\n\n<p>Can you solve it without sorting?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2\n<strong>Output:</strong> 5\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4\n<strong>Output:</strong> 4\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 17796,
        "dislikes": 934,
        "stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 2917537, \"totalSubmissionRaw\": 4306551, \"acRate\": \"67.7%\"}",
        "similarQuestions": "[{\"title\": \"Wiggle Sort II\", \"titleSlug\": \"wiggle-sort-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Third Maximum Number\", \"titleSlug\": \"third-maximum-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Kth Largest Element in a Stream\", \"titleSlug\": \"kth-largest-element-in-a-stream\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"K Closest Points to Origin\", \"titleSlug\": \"k-closest-points-to-origin\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Kth Largest Integer in the Array\", \"titleSlug\": \"find-the-kth-largest-integer-in-the-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Subsequence of Length K With the Largest Sum\", \"titleSlug\": \"find-subsequence-of-length-k-with-the-largest-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"K Highest Ranked Items Within a Price Range\", \"titleSlug\": \"k-highest-ranked-items-within-a-price-range\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Quickselect"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "216",
        "questionFrontendId": "216",
        "title": "Combination Sum III",
        "content": "<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
        "likes": 6291,
        "dislikes": 115,
        "stats": "{\"totalAccepted\": \"642.9K\", \"totalSubmission\": \"898.4K\", \"totalAcceptedRaw\": 642906, \"totalSubmissionRaw\": 898449, \"acRate\": \"71.6%\"}",
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/combination-sum-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "217",
        "questionFrontendId": "217",
        "title": "Contains Duplicate",
        "content": "<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,2,3,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The element 1 occurs at the indices 0 and 3.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,2,3,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>All elements are distinct.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,1,1,3,3,4,3,2,4,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 12779,
        "dislikes": 1325,
        "stats": "{\"totalAccepted\": \"5M\", \"totalSubmission\": \"7.9M\", \"totalAcceptedRaw\": 4993381, \"totalSubmissionRaw\": 7930465, \"acRate\": \"63.0%\"}",
        "similarQuestions": "[{\"title\": \"Contains Duplicate II\", \"titleSlug\": \"contains-duplicate-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Contains Duplicate III\", \"titleSlug\": \"contains-duplicate-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Make Array Zero by Subtracting Equal Amounts\", \"titleSlug\": \"make-array-zero-by-subtracting-equal-amounts\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Valid Pair of Adjacent Digits in String\", \"titleSlug\": \"find-valid-pair-of-adjacent-digits-in-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/contains-duplicate/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "218",
        "questionFrontendId": "218",
        "title": "The Skyline Problem",
        "content": "<p>A city&#39;s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p>\n\n<p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>:</p>\n\n<ul>\n\t<li><code>left<sub>i</sub></code> is the x coordinate of the left edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>right<sub>i</sub></code> is the x coordinate of the right edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>height<sub>i</sub></code> is the height of the <code>i<sup>th</sup></code> building.</li>\n</ul>\n\n<p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p>\n\n<p>The <strong>skyline</strong> should be represented as a list of &quot;key points&quot; <strong>sorted by their x-coordinate</strong> in the form <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline&#39;s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline&#39;s contour.</p>\n\n<p><b>Note:</b> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\" style=\"width: 800px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n<strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n<strong>Explanation:</strong>\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]\n<strong>Output:</strong> [[0,3],[5,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>buildings</code> is sorted by <code>left<sub>i</sub></code> in&nbsp;non-decreasing order.</li>\n</ul>\n",
        "likes": 6040,
        "dislikes": 275,
        "stats": "{\"totalAccepted\": \"316.6K\", \"totalSubmission\": \"723.5K\", \"totalAcceptedRaw\": 316596, \"totalSubmissionRaw\": 723473, \"acRate\": \"43.8%\"}",
        "similarQuestions": "[{\"title\": \"Falling Squares\", \"titleSlug\": \"falling-squares\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Shifting Letters II\", \"titleSlug\": \"shifting-letters-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Binary Indexed Tree"
          },
          {
            "name": "Segment Tree"
          },
          {
            "name": "Line Sweep"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Ordered Set"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/the-skyline-problem/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "219",
        "questionFrontendId": "219",
        "title": "Contains Duplicate II",
        "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 6660,
        "dislikes": 3210,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1300132, \"totalSubmissionRaw\": 2680424, \"acRate\": \"48.5%\"}",
        "similarQuestions": "[{\"title\": \"Contains Duplicate\", \"titleSlug\": \"contains-duplicate\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Contains Duplicate III\", \"titleSlug\": \"contains-duplicate-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/contains-duplicate-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "220",
        "questionFrontendId": "220",
        "title": "Contains Duplicate III",
        "content": "<p>You are given an integer array <code>nums</code> and two integers <code>indexDiff</code> and <code>valueDiff</code>.</p>\n\n<p>Find a pair of indices <code>(i, j)</code> such that:</p>\n\n<ul>\n\t<li><code>i != j</code>,</li>\n\t<li><code>abs(i - j) &lt;= indexDiff</code>.</li>\n\t<li><code>abs(nums[i] - nums[j]) &lt;= valueDiff</code>, and</li>\n</ul>\n\n<p>Return <code>true</code><em> if such pair exists or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --&gt; 0 != 3\nabs(i - j) &lt;= indexDiff --&gt; abs(0 - 3) &lt;= 3\nabs(nums[i] - nums[j]) &lt;= valueDiff --&gt; abs(1 - 1) &lt;= 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n<strong>Output:</strong> false\n<strong>Explanation:</strong> After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= indexDiff &lt;= nums.length</code></li>\n\t<li><code>0 &lt;= valueDiff &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 1136,
        "dislikes": 117,
        "stats": "{\"totalAccepted\": \"278.2K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 278200, \"totalSubmissionRaw\": 1184292, \"acRate\": \"23.5%\"}",
        "similarQuestions": "[{\"title\": \"Contains Duplicate\", \"titleSlug\": \"contains-duplicate\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Contains Duplicate II\", \"titleSlug\": \"contains-duplicate-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Time complexity O(n logk)  - This will give an indication that sorting is involved for k elements.",
          "Use already existing state to evaluate next state  -  Like, a set of k sorted numbers are only needed to be tracked. When we are processing the next number in array, then we can utilize the existing sorted state and it is not necessary to sort next overlapping set of k numbers again."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Sliding Window"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Bucket Sort"
          },
          {
            "name": "Ordered Set"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/contains-duplicate-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "221",
        "questionFrontendId": "221",
        "title": "Maximal Square",
        "content": "<p>Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, <em>find the largest square containing only</em> <code>1</code>&#39;s <em>and return its area</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" style=\"width: 400px; height: 319px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" style=\"width: 165px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "likes": 10539,
        "dislikes": 244,
        "stats": "{\"totalAccepted\": \"798.1K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 798072, \"totalSubmissionRaw\": 1648061, \"acRate\": \"48.4%\"}",
        "similarQuestions": "[{\"title\": \"Maximal Rectangle\", \"titleSlug\": \"maximal-rectangle\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Largest Plus Sign\", \"titleSlug\": \"largest-plus-sign\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Artifacts That Can Be Extracted\", \"titleSlug\": \"count-artifacts-that-can-be-extracted\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Stamping the Grid\", \"titleSlug\": \"stamping-the-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximize Area of Square Hole in Grid\", \"titleSlug\": \"maximize-area-of-square-hole-in-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximal-square/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "222",
        "questionFrontendId": "222",
        "title": "Count Complete Tree Nodes",
        "content": "<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n",
        "likes": 9017,
        "dislikes": 563,
        "stats": "{\"totalAccepted\": \"931.3K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 931305, \"totalSubmissionRaw\": 1343372, \"acRate\": \"69.3%\"}",
        "similarQuestions": "[{\"title\": \"Closest Binary Search Tree Value\", \"titleSlug\": \"closest-binary-search-tree-value\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Binary Search"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-complete-tree-nodes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "223",
        "questionFrontendId": "223",
        "title": "Rectangle Area",
        "content": "<p>Given the coordinates of two <strong>rectilinear</strong> rectangles in a 2D plane, return <em>the total area covered by the two rectangles</em>.</p>\n\n<p>The first rectangle is defined by its <strong>bottom-left</strong> corner <code>(ax1, ay1)</code> and its <strong>top-right</strong> corner <code>(ax2, ay2)</code>.</p>\n\n<p>The second rectangle is defined by its <strong>bottom-left</strong> corner <code>(bx1, by1)</code> and its <strong>top-right</strong> corner <code>(bx2, by2)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"Rectangle Area\" src=\"https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png\" style=\"width: 700px; height: 365px;\" />\n<pre>\n<strong>Input:</strong> ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n<strong>Output:</strong> 45\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n<strong>Output:</strong> 16\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>4</sup> &lt;= ax1 &lt;= ax2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= ay1 &lt;= ay2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= bx1 &lt;= bx2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= by1 &lt;= by2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 2046,
        "dislikes": 1655,
        "stats": "{\"totalAccepted\": \"245.8K\", \"totalSubmission\": \"521.5K\", \"totalAcceptedRaw\": 245789, \"totalSubmissionRaw\": 521486, \"acRate\": \"47.1%\"}",
        "similarQuestions": "[{\"title\": \"Rectangle Overlap\", \"titleSlug\": \"rectangle-overlap\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Number of Ways to Place People II\", \"titleSlug\": \"find-the-number-of-ways-to-place-people-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Number of Ways to Place People I\", \"titleSlug\": \"find-the-number-of-ways-to-place-people-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Largest Area of Square Inside Two Rectangles\", \"titleSlug\": \"find-the-largest-area-of-square-inside-two-rectangles\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Geometry"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rectangle-area/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "224",
        "questionFrontendId": "224",
        "title": "Basic Calculator",
        "content": "<p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>\n\n<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1 + 1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> represents a valid expression.</li>\n\t<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>\n\t<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>\n\t<li>There will be no two consecutive operators in the input.</li>\n\t<li>Every number and running calculation will fit in a signed 32-bit integer.</li>\n</ul>\n",
        "likes": 6590,
        "dislikes": 535,
        "stats": "{\"totalAccepted\": \"578.4K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 578406, \"totalSubmissionRaw\": 1280476, \"acRate\": \"45.2%\"}",
        "similarQuestions": "[{\"title\": \"Evaluate Reverse Polish Notation\", \"titleSlug\": \"evaluate-reverse-polish-notation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator II\", \"titleSlug\": \"basic-calculator-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Expression Add Operators\", \"titleSlug\": \"expression-add-operators\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator III\", \"titleSlug\": \"basic-calculator-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"The Score of Students Solving Math Expression\", \"titleSlug\": \"the-score-of-students-solving-math-expression\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimize Result by Adding Parentheses to Expression\", \"titleSlug\": \"minimize-result-by-adding-parentheses-to-expression\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/basic-calculator/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "225",
        "questionFrontendId": "225",
        "title": "Implement Stack using Queues",
        "content": "<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyStack</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>\n\t<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>\n\t<li><code>int top()</code> Returns the element on the top of the stack.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><b>Notes:</b></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 2, 2, false]\n\n<strong>Explanation</strong>\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the stack using only one queue?</p>\n",
        "likes": 6416,
        "dislikes": 1248,
        "stats": "{\"totalAccepted\": \"871.7K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 871687, \"totalSubmissionRaw\": 1304208, \"acRate\": \"66.8%\"}",
        "similarQuestions": "[{\"title\": \"Implement Queue using Stacks\", \"titleSlug\": \"implement-queue-using-stacks\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Design"
          },
          {
            "name": "Queue"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/implement-stack-using-queues/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "226",
        "questionFrontendId": "226",
        "title": "Invert Binary Tree",
        "content": "<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"width: 500px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,6,9]\n<strong>Output:</strong> [4,7,2,9,6,3,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,3,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 14522,
        "dislikes": 241,
        "stats": "{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"3.2M\", \"totalAcceptedRaw\": 2539441, \"totalSubmissionRaw\": 3224218, \"acRate\": \"78.8%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Odd Levels of Binary Tree\", \"titleSlug\": \"reverse-odd-levels-of-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/invert-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "227",
        "questionFrontendId": "227",
        "title": "Basic Calculator II",
        "content": "<p>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.&nbsp;</p>\n\n<p>The integer division should truncate toward zero.</p>\n\n<p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>\n\n<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"3+2*2\"\n<strong>Output:</strong> 7\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \" 3/2 \"\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \" 3+5 / 2 \"\n<strong>Output:</strong> 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li>\n\t<li><code>s</code> represents <strong>a valid expression</strong>.</li>\n\t<li>All the integers in the expression are non-negative integers in the range <code>[0, 2<sup>31</sup> - 1]</code>.</li>\n\t<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li>\n</ul>\n",
        "likes": 6386,
        "dislikes": 912,
        "stats": "{\"totalAccepted\": \"806.7K\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 806734, \"totalSubmissionRaw\": 1774188, \"acRate\": \"45.5%\"}",
        "similarQuestions": "[{\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Expression Add Operators\", \"titleSlug\": \"expression-add-operators\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator III\", \"titleSlug\": \"basic-calculator-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Overview\nThere are multiple variations of this problem like [Basic Calculator](https://leetcode.com/problems/basic-calculator/) and [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/). This problem is relatively simpler to solve, as we don't have to take care of the parenthesis.\n\nThe aim is to evaluate the given mathematical expression by applying the basic mathematical rules. The expressions are evaluated from left to right and the order of evaluation depends on the [Operator Precedence](https://en.wikipedia.org/wiki/Order_of_operations). Let's understand how we could implement the problem using different approaches.\n\n---\n### Approach 1: Using Stack\n\n#### Intuition\n\nWe know that there could be 4 types of operations - addition `(+)`, subtraction `(-)`, multiplication `(*)` and division `(/)`.  Without parenthesis, we know that, multiplication  `(*)` and `(\\)` operations would always have higher precedence than addition `(+)` and subtraction `(-)` based on operator precedence rules.\n\n ![img](../Figures/227/calculator_overview.png)\n\nIf we look at the above examples, we can make the following observations -\n- If the current operation is addition `(+)` or subtraction `(-)`, then the expression is evaluated based on the precedence of the next operation.\n\nIn example 1, `4+3` is evaluated later because the next operation is multiplication `(3*5)` which has higher precedence.\nBut,  in example 2, `4+3` is evaluated first because the next operation is subtraction `(3-5)` which has equal precedence.\n\n- If the current operator is multiplication `(*)` or division `(/)`, then the expression is evaluated irrespective of the next operation. This is because in the given set of operations `(+,-,*,/)`, the  `*` and `/` operations have the highest precedence and therefore must be evaluated first.\n\nIn the above examples 3 and 4, `4*3` is always evaluated first irrespective of the next operation.\n\nUsing this intuition let's look at the algorithm to implement the problem.\n\n\n#### Algorithm\n\nScan the input string `s` from left to right and evaluate the expressions based on the following rules\n\n1) If the current character is a digit `0-9` ( operand ), add it to the number `currentNumber`.\n2) Otherwise, the current character must be an operation `(+,-,*, /)`. Evaluate the expression based on the type of operation.\n- Addition `(+)` or Subtraction `(-)`: We must evaluate the expression later based on the next operation. So, we must store the `currentNumber` to be used later. Let's push the currentNumber in the Stack.\n\n>[Stack data structure](https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/) follows Last In First Out (LIFO) principle. Hence, the last pushed number in the stack would be popped out first for evaluation.  In addition, when we pop from the stack and evaluate this expression in the future, we need a way to determine if the operation was Addition `(+)` or Subtraction `(-)`. To simplify our evaluation, we can push `-currentNumber` in a stack if the current operation is subtraction (`-`) and assume that the operation for all the values in the stack is addition `(+)`. This works because `(a - currentNumber)` is equivalent to `(a + (-currentNumber))`.\n\n - Multiplication `(*)` or Division `(/)`: Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack.\n\nOnce the string is scanned, pop from the stack and add to the `result`.\n\n\n!?!../Documents/227_LIS.json:1414,716!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/6A5bNZvg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6A5bNZvg\"></iframe>\n\n#### Complexity Analysis\n\n* Time Complexity: $$\\mathcal{O}(n)$$,  where $$n$$ is the length of the string $$s$$. We iterate over the string $$s$$ at most twice.\n\n* Space Complexity: $$\\mathcal{O}(n)$$, where $$n$$ is the length of the string $$s$$.\n\n---\n### Approach 2: Optimised Approach without the stack\n\n#### Intuition\n\nIn the previous approach, we used a stack to track the values of the evaluated expressions. In the end, we pop all the values from the stack and add to the result. Instead of that, we could add the values to the result beforehand and keep track of the last calculated number, thus eliminating the need for the stack. Let's understand the algorithm in detail.\n\n#### Algorithm\n\nThe approach works similar to _Approach 1_ with the following differences :\n\n- Instead of using a `stack`, we use a variable `lastNumber` to track the value of the last evaluated expression.\n- If the operation is Addition `(+)` or Subtraction `(-)`, add the `lastNumber` to the result instead of pushing it to the stack. The `currentNumber` would be updated to `lastNumber` for the next iteration.\n- If the operation is Multiplication `(*)` or Division `(/)`, we must evaluate the expression `lastNumber * currentNumber` and update the `lastNumber` with the result of the expression.  This would be added to the result after the entire string is scanned.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ao7b4uv8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ao7b4uv8\"></iframe>\n\n#### Complexity Analysis\n\n* Time Complexity: $$\\mathcal{O}(n)$$,  where $$n$$ is the length of the string $$s$$.\n\n* Space Complexity: $$\\mathcal{O}(1)$$, as we use constant extra space to store `lastNumber`, `result` and so on."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/basic-calculator-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "228",
        "questionFrontendId": "228",
        "title": "Summary Ranges",
        "content": "<p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>\n\n<p>A <strong>range</strong> <code>[a,b]</code> is the set of all integers from <code>a</code> to <code>b</code> (inclusive).</p>\n\n<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>\n\n<p>Each range <code>[a,b]</code> in the list should be output as:</p>\n\n<ul>\n\t<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>\n\t<li><code>&quot;a&quot;</code> if <code>a == b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,4,5,7]\n<strong>Output:</strong> [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,2] --&gt; &quot;0-&gt;2&quot;\n[4,5] --&gt; &quot;4-&gt;5&quot;\n[7,7] --&gt; &quot;7&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,3,4,6,8,9]\n<strong>Output:</strong> [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,0] --&gt; &quot;0&quot;\n[2,4] --&gt; &quot;2-&gt;4&quot;\n[6,6] --&gt; &quot;6&quot;\n[8,9] --&gt; &quot;8-&gt;9&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n",
        "likes": 4245,
        "dislikes": 2306,
        "stats": "{\"totalAccepted\": \"763.3K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 763263, \"totalSubmissionRaw\": 1446623, \"acRate\": \"52.8%\"}",
        "similarQuestions": "[{\"title\": \"Missing Ranges\", \"titleSlug\": \"missing-ranges\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Data Stream as Disjoint Intervals\", \"titleSlug\": \"data-stream-as-disjoint-intervals\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find Maximal Uncovered Ranges\", \"titleSlug\": \"find-maximal-uncovered-ranges\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/summary-ranges/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "229",
        "questionFrontendId": "229",
        "title": "Majority Element II",
        "content": "<p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>&lfloor; n/3 &rfloor;</code> times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> [3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?</p>\n",
        "likes": 10231,
        "dislikes": 461,
        "stats": "{\"totalAccepted\": \"925.8K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 925770, \"totalSubmissionRaw\": 1716567, \"acRate\": \"53.9%\"}",
        "similarQuestions": "[{\"title\": \"Majority Element\", \"titleSlug\": \"majority-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Check If a Number Is Majority Element in a Sorted Array\", \"titleSlug\": \"check-if-a-number-is-majority-element-in-a-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Most Frequent Even Element\", \"titleSlug\": \"most-frequent-even-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think about the possible number of elements that can appear more than \u230a n/3 \u230b times in the array.",
          "It can be at most two. Why?",
          "Consider using Boyer-Moore Voting Algorithm, which is efficient for finding elements that appear more than a certain threshold."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Counting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/majority-element-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "230",
        "questionFrontendId": "230",
        "title": "Kth Smallest Element in a BST",
        "content": "<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,2], k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>\n",
        "likes": 12000,
        "dislikes": 242,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 1812865, \"totalSubmissionRaw\": 2418743, \"acRate\": \"75.0%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Second Minimum Node In a Binary Tree\", \"titleSlug\": \"second-minimum-node-in-a-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Try to utilize the property of a BST.",
          "Try in-order traversal. (Credits to @chan13)",
          "What if you could modify the BST node's structure?",
          "The optimal runtime complexity is O(height of BST)."
        ],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "231",
        "questionFrontendId": "231",
        "title": "Power of Two",
        "content": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "likes": 7201,
        "dislikes": 463,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"3.4M\", \"totalAcceptedRaw\": 1639140, \"totalSubmissionRaw\": 3396644, \"acRate\": \"48.3%\"}",
        "similarQuestions": "[{\"title\": \"Number of 1 Bits\", \"titleSlug\": \"number-of-1-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Power of Three\", \"titleSlug\": \"power-of-three\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Power of Four\", \"titleSlug\": \"power-of-four\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/power-of-two/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "232",
        "questionFrontendId": "232",
        "title": "Implement Queue using Stacks",
        "content": "<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyQueue</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>\n\t<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>\n\t<li><code>int peek()</code> Returns the element at the front of the queue.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 1, 1, false]\n\n<strong>Explanation</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href=\"https://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>\n",
        "likes": 8042,
        "dislikes": 459,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1157853, \"totalSubmissionRaw\": 1704776, \"acRate\": \"67.9%\"}",
        "similarQuestions": "[{\"title\": \"Implement Stack using Queues\", \"titleSlug\": \"implement-stack-using-queues\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Design"
          },
          {
            "name": "Queue"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Summary\nThis article is for beginners. It introduces the following ideas:\nQueue, Stack.\n\n## Solution\n\nQueue is **FIFO** (first in - first out) data structure, in which the elements are inserted from one side - `rear` and removed from the other - `front`.\nThe most intuitive way to implement it is with linked lists, but this article will introduce another approach  using stacks.\nStack is **LIFO** (last in - first out) data structure, in which elements are added and removed from the same end, called `top`.\nTo satisfy **FIFO** property of a queue we need to keep two stacks. They serve to reverse arrival order of the  elements and one of them store the queue elements in their final order.\n\n---\n\n### Approach #1 (Two Stacks) Push - $O(n)$ per operation, Pop - $O(1)$ per operation.\n\n#### Push\n\nA queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all `s1` elements to auxiliary stack `s2`. Then the newly arrived element is pushed on top of `s2` and all its elements are popped and pushed to `s1`.\n\n![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png){:width=\"539px\"}\n\n\n*Figure 1. Push an element in queue*\n\n\n\n<iframe src=\"https://leetcode.com/playground/ZddHrP5d/shared\" frameBorder=\"0\" name=\"ZddHrP5d\" width=\"100%\" height=\"241\"></iframe>\n\n#### Complexity Analysis**\n\n* Time complexity : $O(n)$.\n\n Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives  $4 n + 2$  operations where $n$ is the queue size. The  `push` and `pop` operations have $O(1)$ time complexity.\n\n* Space complexity : $O(n)$.\nWe need additional memory to store the queue elements\n\n#### Pop\n\nThe algorithm pops an element from  the stack `s1`, because `s1` stores always on its top the first inserted element in the queue.\nThe front element of the queue is kept as `front`.\n\n![Pop an element from queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png){:width=\"539px\"}\n\n\n*Figure 2. Pop an element from queue*\n\n\n<iframe src=\"https://leetcode.com/playground/UZJY8ns5/shared\" frameBorder=\"0\" width=\"100%\" height=\"157\" name=\"UZJY8ns5\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $O(1)$.\n* Space complexity : $O(1)$.\n\n#### Empty\n\nStack `s1` contains all stack elements, so the algorithm checks `s1` size to return if the queue is empty.\n\n<iframe src=\"https://leetcode.com/playground/2urvcw97/shared\" frameBorder=\"0\" name=\"2urvcw97\" width=\"100%\" height=\"122\"></iframe>\n\n\n#### Complexity Analysis\n\n* Time complexity : $O(1)$.\n* Space complexity : $O(1)$.\n\n#### Peek\n\nThe `front` element is kept in constant memory and is modified when we push or pop an element.\n\n<iframe src=\"https://leetcode.com/playground/VGjvtStE/shared\" frameBorder=\"0\" name=\"VGjvtStE\" width=\"100%\" height=\"122\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $O(1)$. The `front` element has been calculated in advance and only returned in `peek` operation.\n* Space complexity : $O(1)$.\n\n---\n\n### Approach #2 (Two Stacks) Push - $O(1)$ per operation, Pop - Amortized $O(1)$ per operation.\n\n\n#### Push\n\nThe newly arrived element is always added on top of stack `s1` and the first element is kept as `front` queue element\n\n![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png){:width=\"539px\"}\n\n\n*Figure 3. Push an element in queue*\n\n\n\n<iframe src=\"https://leetcode.com/playground/qaVbztQ7/shared\" frameBorder=\"0\" name=\"qaVbztQ7\" width=\"100%\" height=\"224\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $O(1)$. \u0410ppending an element to a stack is an O(1) operation.\n\n* Space complexity : $O(n)$. We need additional memory to store the queue elements\n\n#### Pop\n\nWe have to remove element in front of the queue. This is the first inserted element in the stack `s1` and it is positioned at the bottom of the stack because of stack's `LIFO (last in - first out)` policy. To remove the bottom element  from  `s1`, we have to pop all elements from `s1` and to push them on to an additional stack `s2`, which helps us to store the elements of `s1` in reversed order. This way  the bottom element of `s1` will be positioned on top of `s2` and we can simply pop it from stack `s2`. Once `s2` is empty, the algorithm transfer data from `s1` to `s2` again.\n\n![Pop an element from stack](https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png){:width=\"539px\"}\n\n\n*Figure 4. Pop an element from stack*\n\n\n\n<iframe src=\"https://leetcode.com/playground/PF3J5wXs/shared\" frameBorder=\"0\" width=\"100%\" height=\"174\" name=\"PF3J5wXs\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: Amortized $O(1)$, Worst-case $O(n)$. In the worst case scenario when stack `s2` is empty, the algorithm pops $n$ elements from stack s1 and pushes $n$ elements to `s2`, where $n$ is the queue size. This gives $2n$ operations, which is $O(n)$. But when stack `s2` is not empty the algorithm has $O(1)$ time complexity. So what does it mean by Amortized $O(1)$? Please see the next section on Amortized Analysis for more information.\n\n* Space complexity : $O(1)$.\n\n#### Amortized Analysis\n\nAmortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.\n\nConsider this example where we start with an empty queue with the following sequence of operations applied:\n\n$$\npush_1, push_2, \\ldots, push_n, pop_1,pop_2 \\ldots, pop_n\n$$\n\nThe worst case time complexity of a single pop operation is $O(n)$. Since we have $n$ pop operations, using the worst-case per operation analysis gives us a total of $O(n^2)$ time.\n\nHowever, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.\n\nIn the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per `n` times (queue size), when `s2` is empty and there is a need for data transfer between `s1` and `s2`. Hence the total time complexity of the sequence is : `n` (for push operations) + `2*n` (for first pop operation) + `n - 1` ( for pop operations) which is $O(2*n)$.This gives $O(2n/2n)$ = $O(1)$ average time per operation.\n\n#### Empty\n\nBoth stacks `s1` and `s2` contain all stack elements, so the algorithm checks `s1` and `s2` size to return if the queue is empty.\n\n<iframe src=\"https://leetcode.com/playground/hswBjmcT/shared\" frameBorder=\"0\" name=\"hswBjmcT\" width=\"100%\" height=\"139\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $O(1)$.\n* Space complexity : $O(1)$.\n\n\n#### Peek\n\nThe `front` element is kept in constant memory and is modified when we push an element. When `s2` is not empty, front element is positioned on the top of `s2`\n\n<iframe src=\"https://leetcode.com/playground/xmLcBbmw/shared\" frameBorder=\"0\" name=\"xmLcBbmw\" width=\"100%\" height=\"173\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $O(1)$. The `front` element was either previously calculated or returned as a top element of stack `s2`. Therefore complexity is $O(1)$\n* Space complexity : $O(1)$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/implement-queue-using-stacks/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "233",
        "questionFrontendId": "233",
        "title": "Number of Digit One",
        "content": "<p>Given an integer <code>n</code>, count <em>the total number of digit </em><code>1</code><em> appearing in all non-negative integers less than or equal to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 1671,
        "dislikes": 1507,
        "stats": "{\"totalAccepted\": \"112.3K\", \"totalSubmission\": \"314.2K\", \"totalAcceptedRaw\": 112308, \"totalSubmissionRaw\": 314179, \"acRate\": \"35.7%\"}",
        "similarQuestions": "[{\"title\": \"Factorial Trailing Zeroes\", \"titleSlug\": \"factorial-trailing-zeroes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Digit Count in Range\", \"titleSlug\": \"digit-count-in-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Beware of overflow."
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n---\n### Approach #1 Brute force [Time Limit Exceeded]\n\n**Intuition**\n\nDo as directed in question.\n\n**Algorithm**\n\n* Iterate over $$i$$ from $$1$$ to $$n$$:\n  + Convert $$i$$ to string and count $$\\text{'1'}$$ in each integer string\n  + Add count of $$\\text{'1'}$$ in each string to the sum, say $$countr$$\n\n\n<iframe src=\"https://leetcode.com/playground/VwAzPgne/shared\" frameBorder=\"0\" name=\"VwAzPgne\" width=\"100%\" height=\"207\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(n*log_{10}(n))$$.\n  + We iterate from $$1$$ to $$n$$\n  + In each iteration, we convert integer to string and count '1' in string which takes linear time in number of digits in $$i$$, which is $$log_{10}(n)$$.\n\n* Space complexity: $$O(log_{10}(n))$$ Extra space for the countr and the converted string $$\\text{str}$$.\n\n---\n### Approach #2 Solve it mathematically [Accepted]\n\n**Intuition**\n\nIn Approach #1, we manually calculated the number of all the $$'1'$$s in the digits, but this is very slow. Hence, we need a way to find a pattern in the way $$'1'$$s (or for that matter any digit) appears in the numbers. We could then use the pattern to formulate the answer.\n\nConsider the $$1$$s in $$\\text{ones}$$ place , $$\\text{tens}$$ place, $$\\text{hundreds}$$ place and so on... An analysis\nhas been performed in the following figure.\n\n![Number of digit one](../Figures/233/number_of_digit_one.png){:width=\"800px\"}\n\n\nFrom the figure, we can see that from digit '1' at $$\\text{ones}$$ place repeat in group of 1 after interval of $$10$$. Similarly, '1' at $$\\text{tens}$$ place repeat in group of 10 after interval of $$100$$.\nThis can be formulated as $$(n/(i*10))*i$$.\n\nAlso, notice that if the digit at $$\\text{tens}$$ place is $$\\text{'1'}$$, then the number of terms with $$\\text{'1's}$$  is increased by $$x+1$$, if the number is say $$\\text{\"ab1x\"}$$. As if digits at $$\\text{tens}$$ place is greater than $$1$$, then all the $$10$$ occurances of numbers with $$'1'$$ at $$\\text{tens}$$ place have taken place, hence, we add $$10$$.\nThis is formluated as $${\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}$$.\n\nLets take an example, say $$n= 1234$$.\n\nNo of $$\\text{'1'}$$ in $$\\text{ones}$$ place = $$1234/10$$(corresponding to 1,11,21,...1221) + $$\\min(4,1)$$(corresponding to 1231) =$$124$$\n\nNo of $$\\text{'1'}$$ in $$\\text{tens}$$ place = $$(1234/100)*10$$(corresponding to 10,11,12,...,110,111,...1919) +$$\\min(21,10)$$(corresponding to 1210,1211,...1219)=$$130$$\n\nNo of $$\\text{'1'}$$ in $$\\text{hundreds}$$ place = $$(1234/1000)*100$$(corresponding to 100,101,12,...,199) +$$\\min(135,100)$$(corresponding to 1100,1101...1199)=$$200$$\n\nNo of $$\\text{'1'}$$ in $$\\text{thousands}$$ place = $$(1234/10000)*10000$$ +$$\\min(235,1000)$$(corresponding to 1000,1001,...1234)=$$235$$\n\nTherefore, Total = $$124+130+200+235 = 689$$.\n\nHerein, one formula has been devised, but many other formulae can be devised for faster implementations, but the essence and complexity remains the same. The users are encouraged to try to devise their own version of solution using the mathematical concepts.\n\n**Algorithm**\n\n* Iterate over $$i$$ from $$1$$ to $$n$$ incrementing by $$10$$ each time:\n\n    - Add  $$(n/(i*10))*i$$ to $$\\text{countr}$$ representing the repetition of groups of $$i$$ sizes after each $$(i*10)$$ interval.\n\n    - Add $${\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}$$ to $$\\text{countr}$$ representing the additional digits dependant on the digit in $$i$$th place as described in intuition.\n\n<iframe src=\"https://leetcode.com/playground/QVzpgtNB/shared\" frameBorder=\"0\" name=\"QVzpgtNB\" width=\"100%\" height=\"207\"></iframe>\n\n**Complexity analysis**\n\n* Time complexity: $$O(log_{10}(n))$$.\n\n  + No of iterations equal to the number of digits in n which is $$log_{10}(n)$$\n\n* Space complexity: $$O(1)$$ space required."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/number-of-digit-one/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "234",
        "questionFrontendId": "234",
        "title": "Palindrome Linked List",
        "content": "<p>Given the <code>head</code> of a singly linked list, return <code>true</code><em> if it is a </em><span data-keyword=\"palindrome-sequence\"><em>palindrome</em></span><em> or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,2,1]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?",
        "likes": 17238,
        "dislikes": 920,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 2347308, \"totalSubmissionRaw\": 4235867, \"acRate\": \"55.4%\"}",
        "similarQuestions": "[{\"title\": \"Palindrome Number\", \"titleSlug\": \"palindrome-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Valid Palindrome\", \"titleSlug\": \"valid-palindrome\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Reverse Linked List\", \"titleSlug\": \"reverse-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Twin Sum of a Linked List\", \"titleSlug\": \"maximum-twin-sum-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/palindrome-linked-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "235",
        "questionFrontendId": "235",
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "content": "<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,1], p = 2, q = 1\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the BST.</li>\n</ul>\n",
        "likes": 11626,
        "dislikes": 335,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1844013, \"totalSubmissionRaw\": 2721057, \"acRate\": \"67.8%\"}",
        "similarQuestions": "[{\"title\": \"Lowest Common Ancestor of a Binary Tree\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Common Region\", \"titleSlug\": \"smallest-common-region\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Lowest Common Ancestor of a Binary Tree II\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Lowest Common Ancestor of a Binary Tree III\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Lowest Common Ancestor of a Binary Tree IV\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "236",
        "questionFrontendId": "236",
        "title": "Lowest Common Ancestor of a Binary Tree",
        "content": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the tree.</li>\n</ul>\n",
        "likes": 17476,
        "dislikes": 456,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 2080835, \"totalSubmissionRaw\": 3148380, \"acRate\": \"66.1%\"}",
        "similarQuestions": "[{\"title\": \"Lowest Common Ancestor of a Binary Search Tree\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Common Region\", \"titleSlug\": \"smallest-common-region\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Players With Zero or One Losses\", \"titleSlug\": \"find-players-with-zero-or-one-losses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Lowest Common Ancestor of a Binary Tree II\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Lowest Common Ancestor of a Binary Tree III\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Lowest Common Ancestor of a Binary Tree IV\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Step-By-Step Directions From a Binary Tree Node to Another\", \"titleSlug\": \"step-by-step-directions-from-a-binary-tree-node-to-another\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Cycle Length Queries in a Tree\", \"titleSlug\": \"cycle-length-queries-in-a-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "237",
        "questionFrontendId": "237",
        "title": "Delete Node in a Linked List",
        "content": "<p>There is a singly-linked list <code>head</code> and we want to delete a node <code>node</code> in it.</p>\n\n<p>You are given the node to be deleted <code>node</code>. You will <strong>not be given access</strong> to the first node of <code>head</code>.</p>\n\n<p>All the values of the linked list are <strong>unique</strong>, and it is guaranteed that the given node <code>node</code> is not the last node in the linked list.</p>\n\n<p>Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:</p>\n\n<ul>\n\t<li>The value of the given node should not exist in the linked list.</li>\n\t<li>The number of nodes in the linked list should decrease by one.</li>\n\t<li>All the values before <code>node</code> should be in the same order.</li>\n\t<li>All the values after <code>node</code> should be in the same order.</li>\n</ul>\n\n<p><strong>Custom testing:</strong></p>\n\n<ul>\n\t<li>For the input, you should provide the entire linked list <code>head</code> and the node to be given <code>node</code>. <code>node</code> should not be the last node of the list and should be an actual node in the list.</li>\n\t<li>We will build the linked list and pass the node to your function.</li>\n\t<li>The output will be the entire list after calling your function.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"width: 400px; height: 286px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 5\n<strong>Output:</strong> [4,1,9]\n<strong>Explanation: </strong>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"width: 400px; height: 315px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 1\n<strong>Output:</strong> [4,5,9]\n<strong>Explanation: </strong>You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The value of each node in the list is <strong>unique</strong>.</li>\n\t<li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node.</li>\n</ul>\n",
        "likes": 5601,
        "dislikes": 1674,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1674582, \"totalSubmissionRaw\": 2043686, \"acRate\": \"81.9%\"}",
        "similarQuestions": "[{\"title\": \"Remove Linked List Elements\", \"titleSlug\": \"remove-linked-list-elements\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Nodes From Linked List\", \"titleSlug\": \"remove-nodes-from-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete Nodes From Linked List Present in Array\", \"titleSlug\": \"delete-nodes-from-linked-list-present-in-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nTo delete a node from a linked list, we typically redirect the previous node's `next` pointer to the subsequent node of the one being deleted. For example, to remove node 3 from a linked list, we would adjust node 2's `next` pointer to reference node 4 directly. This effectively excludes node 3 from the traversal path, rendering it inaccessible during iteration, and thus, it is considered deleted.\n\n![initial_linkedlist](../Documents/237/237-Page-1.svg)\n\n![changing_pointers](../Documents/237/237-Page-2.svg)\n\n<br />\n\nHowever, a challenge arises when we cannot access the previous node, as is the case in this specific problem. Since we can only traverse forward from the node to be deleted, the conventional deletion method is not feasible.\n\n**Key Observations:** \n- We've been presented with a scenario where we can't access the entire linked list structure, forcing us to devise a strategy that works within those limitations.\n- This problem goes beyond rote memorization of DSA techniques. **It emphasizes the importance of creative thinking under limitations.** It highlights the assessment of the candidate's problem-solving approach.\n\n---\n\n### Approach: Data Overwriting\n\n#### Intuition\n\nTo circumvent this limitation, we can employ an alternative strategy. By comparing the original linked list with the desired outcome post-deletion, we notice that the nodes following the target node appear to shift one position to the left. \n\n![initial_linkedlist](../Documents/237/237-Page-3.svg)\n\n\n![after_deletion](../Documents/237/237-Page-4.svg)\n\n<br />\n\n\nWe can replicate this effect by copying the data from each subsequent node into its predecessor, starting from the node to be deleted, and then unlinking the last node.\n\n![overwrite_linkedlist](../Documents/237/237-Page-5.svg)\n\n\n![after_overwrite](../Documents/237/237-Page-6.svg)\n\n<br />\n\nThis approach can be further optimized. Instead of shifting the data of all subsequent nodes, we only need to overwrite the data of the node to be deleted with that of its immediate successor. Subsequently, we update the `next` pointer of the node to be deleted to point to the successor's next node. This effectively removes the successor node, achieving the desired result with minimal operations.\n\n![overwrite_linkedlist](../Documents/237/237-Page-7.svg)\n\n\n![after_overwrite_1_node](../Documents/237/237-Page-8.svg)\n\nLet's take a simpler example to understand this approach.    \nImagine the linked list as a train with connected cars (nodes). We want to remove a specific car (target node), but the conductor (you) can only access the current car and not the engine (head).\nBy shifting all passengers from current car (\"overwriting\" the data of the current node) with the data from the next car, and then connecting the current car to the car after the next (skipping the unwanted car), we achieve the deletion effect.\n\n**Note:** This method will not work if we need to delete the last node of the linked list since there is no immediate successor. However, the problem description explicitly states that the node to be deleted is not the tail node in the list.\n\n<br />\n\n#### Algorithm\n\n1. Copy the data from the successor node into the current node to be deleted.\n2. Update the `next` pointer of the current node to reference the `next` pointer of the successor node.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/WZX53viv/shared\" frameBorder=\"0\" width=\"100%\" height=\"208\" name=\"WZX53viv\"></iframe>\n\n#### Complexity Analysis\n\n* Time Complexity: $O(1)$\n\n    - The method involves a constant number of operations: updating the data of the current node and altering its `next` pointer. Each of these operations requires a fixed amount of time, irrespective of the size of the linked list.\n    \n* Space Complexity: $O(1)$\n\n    - This deletion technique does not necessitate any extra memory allocation, as it operates directly on the existing nodes without creating additional data structures."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/delete-node-in-a-linked-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "238",
        "questionFrontendId": "238",
        "title": "Product of Array Except Self",
        "content": "<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>\n\n<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [24,12,8,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]\n<strong>Output:</strong> [0,0,9,0,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li>The input is generated such that <code>answer[i]</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>\n",
        "likes": 23958,
        "dislikes": 1540,
        "stats": "{\"totalAccepted\": \"3.5M\", \"totalSubmission\": \"5.2M\", \"totalAcceptedRaw\": 3519784, \"totalSubmissionRaw\": 5213310, \"acRate\": \"67.5%\"}",
        "similarQuestions": "[{\"title\": \"Trapping Rain Water\", \"titleSlug\": \"trapping-rain-water\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Difference in Sums After Removal of Elements\", \"titleSlug\": \"minimum-difference-in-sums-after-removal-of-elements\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Construct Product Matrix\", \"titleSlug\": \"construct-product-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
          "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Prefix Sum"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/product-of-array-except-self/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "239",
        "questionFrontendId": "239",
        "title": "Sliding Window Maximum",
        "content": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "likes": 19022,
        "dislikes": 738,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1276288, \"totalSubmissionRaw\": 2693998, \"acRate\": \"47.4%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Min Stack\", \"titleSlug\": \"min-stack\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Substring with At Most Two Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-two-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Jump Game VI\", \"titleSlug\": \"jump-game-vi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Robots Within Budget\", \"titleSlug\": \"maximum-number-of-robots-within-budget\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Tastiness of Candy Basket\", \"titleSlug\": \"maximum-tastiness-of-candy-basket\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximal Score After Applying K Operations\", \"titleSlug\": \"maximal-score-after-applying-k-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "How about using a data structure such as deque (double-ended queue)?",
          "The queue size need not be the same as the window\u2019s size.",
          "Remove redundant elements and the queue should store only elements that need to be considered."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Queue"
          },
          {
            "name": "Sliding Window"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Monotonic Queue"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sliding-window-maximum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "240",
        "questionFrontendId": "240",
        "title": "Search a 2D Matrix II",
        "content": "<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 12396,
        "dislikes": 217,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1110293, \"totalSubmissionRaw\": 2030157, \"acRate\": \"54.7%\"}",
        "similarQuestions": "[{\"title\": \"Search a 2D Matrix\", \"titleSlug\": \"search-a-2d-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/search-a-2d-matrix-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "241",
        "questionFrontendId": "241",
        "title": "Different Ways to Add Parentheses",
        "content": "<p>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed <code>10<sup>4</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2-1-1&quot;\n<strong>Output:</strong> [0,2]\n<strong>Explanation:</strong>\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2*3-4*5&quot;\n<strong>Output:</strong> [-34,-14,-10,-10,10]\n<strong>Explanation:</strong>\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20</code></li>\n\t<li><code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.</li>\n\t<li>All the integer values in the input expression are in the range <code>[0, 99]</code>.</li>\n\t<li>The integer values in the input expression do not have a leading <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> denoting the sign.</li>\n</ul>\n",
        "likes": 6159,
        "dislikes": 384,
        "stats": "{\"totalAccepted\": \"343.1K\", \"totalSubmission\": \"475.3K\", \"totalAcceptedRaw\": 343122, \"totalSubmissionRaw\": 475268, \"acRate\": \"72.2%\"}",
        "similarQuestions": "[{\"title\": \"Unique Binary Search Trees II\", \"titleSlug\": \"unique-binary-search-trees-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Expression Add Operators\", \"titleSlug\": \"expression-add-operators\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"The Score of Students Solving Math Expression\", \"titleSlug\": \"the-score-of-students-solving-math-expression\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimize Result by Adding Parentheses to Expression\", \"titleSlug\": \"minimize-result-by-adding-parentheses-to-expression\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Recursion"
          },
          {
            "name": "Memoization"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a string `expression` containing:\n1. Numbers from 0 - 99.\n2. Operators (+, -, *)  \n\nOur task is to determine all possible results obtainable by grouping the numbers and operators in various ways.\n    \n---\n\n### Approach 1: Recursion\n\n#### Intuition\n\nWhen we add parentheses to an expression, they group parts of the expression, telling us to evaluate those parts first. To decide where to place these parentheses, we look at each operator in the expression. Each operator offers a chance to split the expression into two smaller parts: everything before the operator and everything after it. These smaller parts are similar to our original problem, so we use recursion to solve them.\n\nWe start by defining our base cases, where we can return a result without further recursion:\n1. If the expression is empty, return an empty list.\n2. If the expression is a single digit, return a list with that number.\n3. If the expression has two characters and the first is a digit, the second must also be a digit. We convert the expression to a number and return it in a list.\n\nFor longer expressions, we find operators to split the expression. We iterate through each character, and when we find an operator, we recursively evaluate the parts before and after it. We store the results of these evaluations in separate lists. Then, we combine the results from the left and right parts using the operator and store the final values in a list.\n\nHere\u2019s a visual example of how a recursion subtree might look:\n\n![](../Figures/241/subtree.png)\n\nBy the end of the process, the `results` list will contain all possible results from grouping the numbers and operators in the expression.\n\n#### Algorithm\n\n- Initialize a list `results` to store the possible outcomes.\n- If the input string is empty, return the empty `results` list.\n- Check if `expression` is a single character:\n  - If so, convert it to an integer and add it to `results`.\n  - Return `results`.\n- Check if `expression` has only two characters and starts with a digit:\n  - If so, convert the entire string to an integer and add it to `results`.\n  - Return `results`.\n- Iterate through each character of `expression`:\n  - Set the current character as `currentChar`.\n  - If `currentChar` is a digit, continue to the next iteration.\n  - Recursively call `diffWaysToCompute` for the left part of `expression` (from indices `0` to `i-1`) and set it to a list `leftResults`.\n  - Recursively call `diffWaysToCompute` for the right part of `expression` (from indices `i+1` to the end) and set it to a list `rightResults`.\n  - Iterate through `leftValue` in `leftResults`:\n    - For each `leftValue`, iterate through each `rightValue` in the `rightResults`:\n      - Initialize a variable `computedResult` to store the result of the current operation.\n      - Perform the operation (addition, subtraction, or multiplication) based on the current character.\n      - Add the `computedResult` to the `results` list.\n- Return `results` as our answer.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/a5L9xDMj/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"a5L9xDMj\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the the length of the input string `expression`.\n\n- Time complexity: $O(n \\cdot 2^n)$\n\n    For each sub-expression, we iterate through the string to identify the operators, which takes $O(n)$ time. However, the key aspect is the recursive combination of results from the left and right sub-expressions. The number of results grows exponentially because each sub-expression produces multiple results, and combining these results takes $O(k \\times l)$, where $k$ and $l$ are the numbers of results from the left and right sub-problems, respectively.\n\n    There were some suggestions to model the number of results using Catalan numbers which we deemed as incorrect. Catalan numbers apply when counting distinct ways to fully parenthesize an expression or structure. In this problem, however, we're not just counting valid ways to split the expression but also calculating and combining all possible results. This introduces exponential growth in the number of possible results, not the polynomial growth typical of Catalan numbers. The number of combinations grows exponentially with the depth of recursive splitting, which means the overall complexity is driven by the exponential growth in results.\n\n    Thus, the time complexity of the algorithm is $O(n \\cdot 2^n)$, where the $O(2^n)$ factor reflects the exponential growth in the number of ways to combine results from sub-expressions.\n\n- Space complexity: $O(2^n)$\n\n    The algorithm stores the intermediate results at each step. Since the total number of results can be equal to the $O(2^n)$, the space complexity of the algorithm is $O(2^n)$.\n\n---\n\n### Approach 2: Memoization\n\n#### Intuition\n\nWhen dealing with complex expressions, we often find ourselves repeating the same calculations. Take the expression `2 + 2 - 2 - 2 - 2`. You could group it in different ways:\n\n1. `((2 + 2) - (2 - 2) - 2)`\n2. `((2 + 2) - 2 - (2 - 2))`\n\nAs you can see, the sub-expression (2 + 2) is evaluated more than once.\n\nTo avoid this, we can store the results of these sub-calculations. This way, if we hit the same sub-problem again, we can use the stored result instead of recalculating it, which speeds things up.\n\nAnother issue with the previous method was that it repeatedly created substrings of the expression. Since creating a substring takes $O(n)$ time, where $n$ is the length of the string, this can be quite slow. Instead, we\u2019ll pass the entire `expression` to each recursive call and use `start` and `end` indices to specify the part we're interested in. This avoids the costly substring operations.\n\nIn our updated approach, each state in the recursion is defined by the `start` and `end` indices. We use a 2D array for memoization, where each cell `memo[i][j]` holds the list of possible results for the sub-expression from index `i` to index `j`.\n\n> Note: There is an alternative way to apply memoization in this problem. Consider the expression \"2-2-2\". This can be grouped in two ways: `(2 - 2) - 2` and `2 - (2 - 2)`. As you can see, the expression \"2 - 2\" is being evaluated repeatedly, even though the instances do not share the same indices.\n>\n> To memoize this, we need to store the substring itself as the state of the sub-problem. This can be achieved by using a map with the substring as the key and the list of results as the value. Whenever we encounter the same substring, we can return the result from the map.\n>\n> While this approach leads us to identify and cache more sub-problems, it forces us to use substrings in our recursion. In an interview setting, you can highlight both approaches and discuss their advantages and disadvantages for extra credit.\n\n#### Algorithm\n \nMain method `diffWaysToCompute`:\n\n- Initialize a 2D array `memo` to store computed results for sub-expressions.\n- Call the `computeResults` method with the full expression range and return the result.\n\nHelper method `computeResults(expression, memo, start, end)`:\n\n- Check if the result for the range `[start, end]` is memoized. If so, return the memoized result.\n- Initialize a list `results` to store computed values for the current sub-expression.\n- Check if the current range is a single digit:\n  - - If so, convert `expression` to an integer and add it to `results`.\n  - Return `results`.\n- Check if the current range is a two-digit number:\n  -  If so, compute its value and add it to `results`.\n  -  Return `results`.\n- Iterate through each character in the current range of the expression:\n  - Skip the current iteration if the character is a digit.\n  - Recursively call `computeResults` for the left part of the expression up to the current character (from `start` to `i-1`). Store the result in `leftResults`.\n  - Recursively call `computeResults` for the right part of the expression after the current character (from `i+1` to `end`). Store the result in `rightResults`.\n  - Iterate through each `leftValue` in the `leftResults`:\n    - For each `leftValue`, iterate through each `rightValue` in `rightResults`:\n      - Perform the operation (addition, subtraction, or multiplication) based on the current character.\n      - Add the computed result to the `results` list.\n  - Store the result in `memo` for the range `[start, end]`.\n- Return the `results` list.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/4xf4Rnor/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4xf4Rnor\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the the length of the input string `expression`.\n\n* Time complexity: $O(n \\cdot 2^n)$\n\n    The algorithm uses memoization to store the results of sub-problems, ensuring that each sub-problem is evaluated exactly once. There are at most $O(n^2)$ possible sub-problems, as each sub-problem is defined by its start and end indices, both ranging from $0$ to $n-1$. \n\n    Despite the efficiency gains from memoization, the time complexity is still dominated by the recursive nature of the algorithm. The recursion tree expands exponentially, with a growth factor of $O(2^n)$.\n\n    Thus, the overall time complexity remains $O(n \\cdot 2^n)$.\n\n* Space complexity: $O(n^2 \\cdot 2^n)$\n\n    The space complexity is $O(n^2 \\cdot 2^n)$, where $O(n^2)$ comes from the memoization table storing results for all sub-problems, and $O(2^n)$ accounts for the space required to store the exponentially growing number of results for each sub-problem. The recursion stack depth is at most $O(n)$, which is dominated by the exponential complexity and can therefore be omitted from the overall space complexity analysis.\n\n---\n\n### Approach 3: Tabulation\n\n#### Intuition\n\nRecursive solutions can use up a lot of stack space, which might lead to stack overflow errors. To avoid this, we'll switch to an iterative approach and build our solution step by step.\n\nWe\u2019ll use a 2-D array, called `dp`, to keep track of intermediate results. This table will have dimensions `n x n`, where `n` is the length of our input `expression`. Each cell `dp[i][j]` will store all possible results for the sub-expression starting at index `i` and ending at index `j`. For instance, `dp[0][2]` will hold all possible results for the first three characters of the expression.\n\nFirst, we need to fill in our base cases. We loop through the `expression` to identify all single-digit and double-digit numbers.\n1. For single-digit numbers, add the digit's value to `dp[i][i]`.\n2. For double-digit numbers, add the number's value to `dp[i][i+1]`.\n\nNext, we handle longer sub-expressions. We start with lengths of 3 and go up to the length of the `expression`. For each length, we consider all possible starting points in the expression. This double loop structure ensures we consider all possible substrings of `expression`. For each sub-expression, we try different ways to split it. We go through each character and, when we find an operator, split the expression at that point. We then combine the results from the left and right parts using the operator.\n\nAfter we've filled our entire `dp` table, the cell `dp[0][n-1]` contains all possible results for the entire expression. We can return this list as our final answer.\n\n#### Algorithm\n\nMain method `diffWaysToCompute`:\n\n- Initialize a variable `n` to store the length of the input string `expression`.\n- Create a 2D array `dp` of lists to store the results of sub-problems.\n- Initialize the base cases using the `initializeBaseCases` method.\n- Iterate through all possible sub-expression lengths, starting from `3` up to `n`.\n  - For each length, iterate through all possible `start` positions of the sub-expression.\n  - Set `end` as `start + length - 1`.\n  - Calculate the results for the sub-expression `[start, end]` using the `processSubexpression` method.\n- Return `dp[0][n-1]`, which contains all possible results for the entire `expression`.\n\nHelper method `initializeBaseCases(expression, dp)`:\n\n- Initialize the `dp` array.\n- Handle base cases by iterating through the `expression`:\n  - For single digits, add the digit value to `dp[i][i]`.\n  - For two-digit numbers, add the number value to `dp[i][i+1]`.\n\nHelper method `processSubexpression(expression, dp, start, end)`:\n\n- Try all possible `split` positions from `start` to `end`:\n  - If the character is numeric, continue to the next iteration\n  - If not, retrieve the results of the left sub-expression from `dp[start][split-1]` and assign it to `leftResults`.\n  - Retrieve the results of the right sub-expression from `dp[split+1][end]` and assign it to `rightResults`.\n  - Call `computeResults` with `leftResults`, `rightResults`, and the operator at the `split` position.\n\nHelper method `computeResults(op, leftResults, rightResults, results)`:\n\n- For each combination of `leftResults` and `rightResults`:\n  - Perform the operation specified by `op`.\n  - Add the result to `results`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/3Gw7Y5ZR/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"3Gw7Y5ZR\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the the length of the input string `expression`.\n\n* Time complexity: $O(n \\cdot 2^n)$\n\n    Similar to the memoization approach, the algorithm evaluates each sub-problem exactly once. Thus, the time complexity remains the same as Approach 2: $O(n \\cdot 2^n)$.\n\n* Space complexity: $O(n^2 \\cdot 2^n)$\n\n    The space complexity is similar to the previous approach, with one key difference: the absence of the recursive stack space. \n\n    However, the `dp` table dominates the space complexity anyway, keeping the overall space complexity as $O(n^2 \\cdot 2^n)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/different-ways-to-add-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "242",
        "questionFrontendId": "242",
        "title": "Valid Anagram",
        "content": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an <span data-keyword=\"anagram\">anagram</span> of <code>s</code>, and <code>false</code> otherwise.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;rat&quot;, t = &quot;car&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>\n",
        "likes": 12908,
        "dislikes": 428,
        "stats": "{\"totalAccepted\": \"4.6M\", \"totalSubmission\": \"7M\", \"totalAcceptedRaw\": 4615156, \"totalSubmissionRaw\": 6956727, \"acRate\": \"66.3%\"}",
        "similarQuestions": "[{\"title\": \"Group Anagrams\", \"titleSlug\": \"group-anagrams\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation\", \"titleSlug\": \"palindrome-permutation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find All Anagrams in a String\", \"titleSlug\": \"find-all-anagrams-in-a-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Resultant Array After Removing Anagrams\", \"titleSlug\": \"find-resultant-array-after-removing-anagrams\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/valid-anagram/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "243",
        "questionFrontendId": "243",
        "title": "Shortest Word Distance",
        "content": null,
        "likes": 1285,
        "dislikes": 119,
        "stats": "{\"totalAccepted\": \"230.4K\", \"totalSubmission\": \"349.7K\", \"totalAcceptedRaw\": 230372, \"totalSubmissionRaw\": 349747, \"acRate\": \"65.9%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Word Distance II\", \"titleSlug\": \"shortest-word-distance-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Word Distance III\", \"titleSlug\": \"shortest-word-distance-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All K-Distant Indices in an Array\", \"titleSlug\": \"find-all-k-distant-indices-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/shortest-word-distance/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "244",
        "questionFrontendId": "244",
        "title": "Shortest Word Distance II",
        "content": null,
        "likes": 1071,
        "dislikes": 375,
        "stats": "{\"totalAccepted\": \"165.7K\", \"totalSubmission\": \"267.3K\", \"totalAcceptedRaw\": 165709, \"totalSubmissionRaw\": 267292, \"acRate\": \"62.0%\"}",
        "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Shortest Word Distance\", \"titleSlug\": \"shortest-word-distance\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Shortest Word Distance III\", \"titleSlug\": \"shortest-word-distance-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          },
          {
            "name": "Design"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/shortest-word-distance-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "245",
        "questionFrontendId": "245",
        "title": "Shortest Word Distance III",
        "content": null,
        "likes": 507,
        "dislikes": 100,
        "stats": "{\"totalAccepted\": \"87.6K\", \"totalSubmission\": \"148.5K\", \"totalAcceptedRaw\": 87568, \"totalSubmissionRaw\": 148514, \"acRate\": \"59.0%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Word Distance\", \"titleSlug\": \"shortest-word-distance\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Shortest Word Distance II\", \"titleSlug\": \"shortest-word-distance-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/shortest-word-distance-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "246",
        "questionFrontendId": "246",
        "title": "Strobogrammatic Number",
        "content": null,
        "likes": 612,
        "dislikes": 1032,
        "stats": "{\"totalAccepted\": \"192.3K\", \"totalSubmission\": \"404.1K\", \"totalAcceptedRaw\": 192344, \"totalSubmissionRaw\": 404091, \"acRate\": \"47.6%\"}",
        "similarQuestions": "[{\"title\": \"Strobogrammatic Number II\", \"titleSlug\": \"strobogrammatic-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Strobogrammatic Number III\", \"titleSlug\": \"strobogrammatic-number-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Confusing Number\", \"titleSlug\": \"confusing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/strobogrammatic-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "247",
        "questionFrontendId": "247",
        "title": "Strobogrammatic Number II",
        "content": null,
        "likes": 938,
        "dislikes": 261,
        "stats": "{\"totalAccepted\": \"152.6K\", \"totalSubmission\": \"287.7K\", \"totalAcceptedRaw\": 152620, \"totalSubmissionRaw\": 287702, \"acRate\": \"53.0%\"}",
        "similarQuestions": "[{\"title\": \"Strobogrammatic Number\", \"titleSlug\": \"strobogrammatic-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Strobogrammatic Number III\", \"titleSlug\": \"strobogrammatic-number-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum of k-Mirror Numbers\", \"titleSlug\": \"sum-of-k-mirror-numbers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Try to use recursion and notice that it should recurse with <i>n</i> - 2 instead of <i>n</i> - 1."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/strobogrammatic-number-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "248",
        "questionFrontendId": "248",
        "title": "Strobogrammatic Number III",
        "content": null,
        "likes": 304,
        "dislikes": 191,
        "stats": "{\"totalAccepted\": \"37.5K\", \"totalSubmission\": \"88.6K\", \"totalAcceptedRaw\": 37549, \"totalSubmissionRaw\": 88570, \"acRate\": \"42.4%\"}",
        "similarQuestions": "[{\"title\": \"Strobogrammatic Number\", \"titleSlug\": \"strobogrammatic-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Strobogrammatic Number II\", \"titleSlug\": \"strobogrammatic-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/strobogrammatic-number-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "249",
        "questionFrontendId": "249",
        "title": "Group Shifted Strings",
        "content": null,
        "likes": 1745,
        "dislikes": 427,
        "stats": "{\"totalAccepted\": \"287.9K\", \"totalSubmission\": \"428.8K\", \"totalAcceptedRaw\": 287927, \"totalSubmissionRaw\": 428779, \"acRate\": \"67.2%\"}",
        "similarQuestions": "[{\"title\": \"Group Anagrams\", \"titleSlug\": \"group-anagrams\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Maximum Number of String Pairs\", \"titleSlug\": \"find-maximum-number-of-string-pairs\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/group-shifted-strings/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "250",
        "questionFrontendId": "250",
        "title": "Count Univalue Subtrees",
        "content": null,
        "likes": 1226,
        "dislikes": 448,
        "stats": "{\"totalAccepted\": \"163K\", \"totalSubmission\": \"285.5K\", \"totalAcceptedRaw\": 162956, \"totalSubmissionRaw\": 285547, \"acRate\": \"57.1%\"}",
        "similarQuestions": "[{\"title\": \"Subtree of Another Tree\", \"titleSlug\": \"subtree-of-another-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Longest Univalue Path\", \"titleSlug\": \"longest-univalue-path\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-univalue-subtrees/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "251",
        "questionFrontendId": "251",
        "title": "Flatten 2D Vector",
        "content": null,
        "likes": 730,
        "dislikes": 412,
        "stats": "{\"totalAccepted\": \"137.1K\", \"totalSubmission\": \"273.9K\", \"totalAcceptedRaw\": 137071, \"totalSubmissionRaw\": 273857, \"acRate\": \"50.1%\"}",
        "similarQuestions": "[{\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Peeking Iterator\", \"titleSlug\": \"peeking-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten Nested List Iterator\", \"titleSlug\": \"flatten-nested-list-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "How many variables do you need to keep track?",
          "Two variables is all you need. Try with <code>x</code> and <code>y</code>.",
          "Beware of empty rows. It could be the first few rows.",
          "To write correct code, think about the <a href=\"https://en.wikipedia.org/wiki/Invariant_(computer_science)\" target=\"_blank\">invariant</a> to maintain. What is it?",
          "The invariant is <code>x</code> and <code>y</code> must always point to a valid point in the 2d vector. Should you maintain your invariant <i>ahead of time</i> or <i>right when you need it</i>?",
          "Not sure? Think about how you would implement <code>hasNext()</code>. Which is more complex?",
          "Common logic in two different places should be refactored into a common method."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Design"
          },
          {
            "name": "Iterator"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/flatten-2d-vector/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "252",
        "questionFrontendId": "252",
        "title": "Meeting Rooms",
        "content": null,
        "likes": 2078,
        "dislikes": 111,
        "stats": "{\"totalAccepted\": \"458.8K\", \"totalSubmission\": \"779.7K\", \"totalAcceptedRaw\": 458775, \"totalSubmissionRaw\": 779651, \"acRate\": \"58.8%\"}",
        "similarQuestions": "[{\"title\": \"Merge Intervals\", \"titleSlug\": \"merge-intervals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms II\", \"titleSlug\": \"meeting-rooms-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms III\", \"titleSlug\": \"meeting-rooms-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Points That Intersect With Cars\", \"titleSlug\": \"points-that-intersect-with-cars\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/meeting-rooms/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "253",
        "questionFrontendId": "253",
        "title": "Meeting Rooms II",
        "content": null,
        "likes": 7087,
        "dislikes": 170,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1029442, \"totalSubmissionRaw\": 1979212, \"acRate\": \"52.0%\"}",
        "similarQuestions": "[{\"title\": \"Merge Intervals\", \"titleSlug\": \"merge-intervals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms\", \"titleSlug\": \"meeting-rooms\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Arrows to Burst Balloons\", \"titleSlug\": \"minimum-number-of-arrows-to-burst-balloons\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Car Pooling\", \"titleSlug\": \"car-pooling\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Flowers in Full Bloom\", \"titleSlug\": \"number-of-flowers-in-full-bloom\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms III\", \"titleSlug\": \"meeting-rooms-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Total Cost to Hire K Workers\", \"titleSlug\": \"total-cost-to-hire-k-workers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Points That Intersect With Cars\", \"titleSlug\": \"points-that-intersect-with-cars\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think about how we would approach this problem in a very simplistic way. We will allocate rooms to meetings that occur earlier in the day v/s the ones that occur later on, right?",
          "If you've figured out that we have to <b>sort</b> the meetings by their start time, the next thing to think about is how do we do the allocation? <br>There are two scenarios possible here for any meeting. Either there is no meeting room available and a new one has to be allocated, or a meeting room has freed up and this meeting can take place there.",
          "An important thing to note is that we don't really care <b>which</b> room gets freed up while allocating a room for the current meeting. As long as a room is free, our job is done. <br><br>We already know the rooms we have allocated till now and we also know when are they due to get free because of the end times of the meetings going on in those rooms. We can simply check the room which is due to get vacated the earliest amongst all the allocated rooms.",
          "Following up on the previous hint, we can make use of a min-heap to store the end times of the meetings in various rooms. <br><br>So, every time we want to check if any room is free or not, simply check the topmost element of the min heap as that would be the room that would get free the earliest out of all the other rooms currently occupied.\r\n\r\n<br><br>If the room we extracted from the top of the min heap isn't free, then no other room is. So, we can save time here and simply allocate a new room."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Prefix Sum"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/meeting-rooms-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "254",
        "questionFrontendId": "254",
        "title": "Factor Combinations",
        "content": null,
        "likes": 1159,
        "dislikes": 75,
        "stats": "{\"totalAccepted\": \"135.8K\", \"totalSubmission\": \"270.7K\", \"totalAcceptedRaw\": 135813, \"totalSubmissionRaw\": 270706, \"acRate\": \"50.2%\"}",
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/factor-combinations/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "255",
        "questionFrontendId": "255",
        "title": "Verify Preorder Sequence in Binary Search Tree",
        "content": null,
        "likes": 1230,
        "dislikes": 90,
        "stats": "{\"totalAccepted\": \"86.8K\", \"totalSubmission\": \"171.1K\", \"totalAcceptedRaw\": 86825, \"totalSubmissionRaw\": 171113, \"acRate\": \"50.7%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Preorder Traversal\", \"titleSlug\": \"binary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Recursion"
          },
          {
            "name": "Monotonic Stack"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "256",
        "questionFrontendId": "256",
        "title": "Paint House",
        "content": null,
        "likes": 2340,
        "dislikes": 132,
        "stats": "{\"totalAccepted\": \"228.5K\", \"totalSubmission\": \"359.5K\", \"totalAcceptedRaw\": 228537, \"totalSubmissionRaw\": 359532, \"acRate\": \"63.6%\"}",
        "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Paint Fence\", \"titleSlug\": \"paint-fence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/paint-house/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "257",
        "questionFrontendId": "257",
        "title": "Binary Tree Paths",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 6849,
        "dislikes": 318,
        "stats": "{\"totalAccepted\": \"847.5K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 847456, \"totalSubmissionRaw\": 1283126, \"acRate\": \"66.0%\"}",
        "similarQuestions": "[{\"title\": \"Path Sum II\", \"titleSlug\": \"path-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest String Starting From Leaf\", \"titleSlug\": \"smallest-string-starting-from-leaf\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Step-By-Step Directions From a Binary Tree Node to Another\", \"titleSlug\": \"step-by-step-directions-from-a-binary-tree-node-to-another\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-paths/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "258",
        "questionFrontendId": "258",
        "title": "Add Digits",
        "content": "<p>Given an integer <code>num</code>, repeatedly add all its digits until the result has only one digit, and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 38\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The process is\n38 --&gt; 3 + 8 --&gt; 11\n11 --&gt; 1 + 1 --&gt; 2 \nSince 2 has only one digit, return it.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it without any loop/recursion in <code>O(1)</code> runtime?</p>\n",
        "likes": 5074,
        "dislikes": 1952,
        "stats": "{\"totalAccepted\": \"954.9K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 954872, \"totalSubmissionRaw\": 1410234, \"acRate\": \"67.7%\"}",
        "similarQuestions": "[{\"title\": \"Happy Number\", \"titleSlug\": \"happy-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Digits in the Minimum Number\", \"titleSlug\": \"sum-of-digits-in-the-minimum-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Digits of String After Convert\", \"titleSlug\": \"sum-of-digits-of-string-after-convert\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Sum of Four Digit Number After Splitting Digits\", \"titleSlug\": \"minimum-sum-of-four-digit-number-after-splitting-digits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Calculate Digit Sum of a String\", \"titleSlug\": \"calculate-digit-sum-of-a-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Difference Between Element Sum and Digit Sum of an Array\", \"titleSlug\": \"difference-between-element-sum-and-digit-sum-of-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Alternating Digit Sum\", \"titleSlug\": \"alternating-digit-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "A naive implementation of the above process is trivial. Could you come up with other methods?",
          "What are all the possible results?",
          "How do they occur, periodically or randomly?",
          "You may find this <a href=\"https://en.wikipedia.org/wiki/Digital_root\" target=\"_blank\">Wikipedia article</a> useful."
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Simulation"
          },
          {
            "name": "Number Theory"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/add-digits/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "259",
        "questionFrontendId": "259",
        "title": "3Sum Smaller",
        "content": null,
        "likes": 1588,
        "dislikes": 166,
        "stats": "{\"totalAccepted\": \"162.7K\", \"totalSubmission\": \"319.2K\", \"totalAcceptedRaw\": 162657, \"totalSubmissionRaw\": 319228, \"acRate\": \"51.0%\"}",
        "similarQuestions": "[{\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"3Sum Closest\", \"titleSlug\": \"3sum-closest\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Triangle Number\", \"titleSlug\": \"valid-triangle-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum Less Than K\", \"titleSlug\": \"two-sum-less-than-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximize Greatness of an Array\", \"titleSlug\": \"maximize-greatness-of-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Polygon With the Largest Perimeter\", \"titleSlug\": \"find-polygon-with-the-largest-perimeter\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/3sum-smaller/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "260",
        "questionFrontendId": "260",
        "title": "Single Number III",
        "content": "<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>\n\n<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,2,5]\n<strong>Output:</strong> [3,5]\n<strong>Explanation: </strong> [5, 3] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0]\n<strong>Output:</strong> [-1,0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [1,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>\n</ul>\n",
        "likes": 6532,
        "dislikes": 271,
        "stats": "{\"totalAccepted\": \"514.2K\", \"totalSubmission\": \"727.4K\", \"totalAcceptedRaw\": 514228, \"totalSubmissionRaw\": 727449, \"acRate\": \"70.7%\"}",
        "similarQuestions": "[{\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Single Number II\", \"titleSlug\": \"single-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find The Original Array of Prefix Xor\", \"titleSlug\": \"find-the-original-array-of-prefix-xor\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the XOR of Numbers Which Appear Twice\", \"titleSlug\": \"find-the-xor-of-numbers-which-appear-twice\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/single-number-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "261",
        "questionFrontendId": "261",
        "title": "Graph Valid Tree",
        "content": null,
        "likes": 3374,
        "dislikes": 108,
        "stats": "{\"totalAccepted\": \"470.2K\", \"totalSubmission\": \"956.1K\", \"totalAcceptedRaw\": 470178, \"totalSubmissionRaw\": 956145, \"acRate\": \"49.2%\"}",
        "similarQuestions": "[{\"title\": \"Course Schedule\", \"titleSlug\": \"course-schedule\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Connected Components in an Undirected Graph\", \"titleSlug\": \"number-of-connected-components-in-an-undirected-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Keys and Rooms\", \"titleSlug\": \"keys-and-rooms\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, what should your return? Is this case a valid tree?",
          "According to the <a href=\"https://en.wikipedia.org/wiki/Tree_(graph_theory)\" target=\"_blank\">definition of tree on Wikipedia</a>: \u201ca tree is an undirected graph in which any two vertices are connected by <i>exactly</i> one path. In other words, any connected graph without simple cycles is a tree.\u201d"
        ],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Union Find"
          },
          {
            "name": "Graph"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/graph-valid-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "262",
        "questionFrontendId": "262",
        "title": "Trips and Users",
        "content": "<p>Table: <code>Trips</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | varchar  |     \n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table.\nStatus is an ENUM (category) type of (&#39;completed&#39;, &#39;cancelled_by_driver&#39;, &#39;cancelled_by_client&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Users</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id is the primary key (column with unique values) for this table.\nThe table holds all users. Each user has a unique users_id, and role is an ENUM type of (&#39;client&#39;, &#39;driver&#39;, &#39;partner&#39;).\nbanned is an ENUM (category) type of (&#39;Yes&#39;, &#39;No&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>The <strong>cancellation rate</strong> is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.</p>\n\n<p>Write a solution to find the <strong>cancellation rate</strong> of requests with unbanned users (<strong>both client and driver must not be banned</strong>) each day between <code>&quot;2013-10-01&quot;</code> and <code>&quot;2013-10-03&quot;</code> with <strong>at least</strong> one trip. Round <code>Cancellation Rate</code> to <strong>two decimal</strong> points.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTrips table:\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\nUsers table:\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>Output:</strong> \n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>Explanation:</strong> \nOn 2013-10-01:\n  - There were 4 requests in total, 2 of which were canceled.\n  - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation.\n  - Hence there are 3 unbanned requests in total, 1 of which was canceled.\n  - The Cancellation Rate is (1 / 3) = 0.33\nOn 2013-10-02:\n  - There were 3 requests in total, 0 of which were canceled.\n  - The request with Id=6 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned requests in total, 0 of which were canceled.\n  - The Cancellation Rate is (0 / 2) = 0.00\nOn 2013-10-03:\n  - There were 3 requests in total, 1 of which was canceled.\n  - The request with Id=8 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned request in total, 1 of which were canceled.\n  - The Cancellation Rate is (1 / 2) = 0.50\n</pre>\n",
        "likes": 1307,
        "dislikes": 684,
        "stats": "{\"totalAccepted\": \"222.6K\", \"totalSubmission\": \"600.6K\", \"totalAcceptedRaw\": 222604, \"totalSubmissionRaw\": 600642, \"acRate\": \"37.1%\"}",
        "similarQuestions": "[{\"title\": \"Hopper Company Queries I\", \"titleSlug\": \"hopper-company-queries-i\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Hopper Company Queries II\", \"titleSlug\": \"hopper-company-queries-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Hopper Company Queries III\", \"titleSlug\": \"hopper-company-queries-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Database",
        "hints": [],
        "topicTags": [
          {
            "name": "Database"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n# Solution\n\n---\n\n### Overview\n\nCalculate the daily cancellation rate for taxi trip requests made by unbanned users between \"2013-10-01\" and \"2013-10-03\". The cancellation rate for a day is the number of canceled trips (either by client or driver) divided by the total number of trips requested by unbanned users.\n\n**Visualized Output**\n\n![fig](../Figures/262/262.png)\n\n**Tables and Fields**\n\n1. **Trips**: The table holds all taxi trips.\n   - Fields: `id`, `client_id`, `driver_id`, `status`, `request_at`\n   - We are interested in the `client_id`, `driver_id`, `status`, and `request_at` columns.\n2. **Users**: The table holds all users.\n   - Fields: id, client_id, driver_id, status, request_at\n   - The `users_id` and `banned` columns are essential to filter out banned users.\n\n**Relationships**\n1. `Trips.client_id` = `Users.users_id`\n2. `Trips.driver_id` = `Users.users_id`\n\n---\n\n## pandas\n\n### Approach 1: DataFrame Merging\n\n#### Intuition\n\nThe algorithm merges trip information with user details, filters out trips with banned users and those outside a specific date range, and then calculates the daily cancellation rate for the selected trips.\n\n#### Algorithm\n\n1. **Preliminary Check**:\n   - Check if either the `trips` or `users` DataFrame is empty.\n   - If either is empty, return a DataFrame with \"Day\" and \"Cancellation Rate\" columns.\n\n2. **Prepare Data for Client Merge**:\n   - Adjust the `users` DataFrame column names for clarity: \n     - Rename `users_id` to `client_id`.\n     - Rename `banned` to `client_banned`.\n\n<table>\n  <tr>\n    <th>client_id</th>\n    <th>client_banned</th>\n    <th>role</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>No</td>\n    <td>client</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>Yes</td>\n    <td>client</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td>No</td>\n    <td>client</td>\n  </tr>\n  <tr>\n    <td>4</td>\n    <td>No</td>\n    <td>client</td>\n  </tr>\n</table>\n<br>\n\n3. **Client Merge**:\n   - Merge `trips` with the modified `users` DataFrame using `client_id`.\n   - Use a left merge to ensure retention of all trip records.\n   - The outcome is the `trips_with_clients` DataFrame.\n\n<table>\n  <tr>\n    <th>id</th>\n    <th>client_id</th>\n    <th>driver_id</th>\n    <th>city_id</th>\n    <th>status</th>\n    <th>request_at</th>\n    <th>client_banned</th>\n    <th>role</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>1</td>\n    <td>10</td>\n    <td>1</td>\n    <td>completed</td>\n    <td>2013-10-01</td>\n    <td>No</td>\n    <td>client</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>2</td>\n    <td>11</td>\n    <td>1</td>\n    <td>cancelled_by_driver</td>\n    <td>2013-10-01</td>\n    <td>Yes</td>\n    <td>client</td>\n  </tr>\n</table>\n<br>\n\n4. **Prepare Data for Driver Merge**:\n   - Modify column names in the `users` DataFrame to differentiate drivers:\n     - Change `users_id` to `driver_id`.\n     - Adjust `banned` to `driver_banned`.\n\n<table>\n  <tr>\n    <th>driver_id</th>\n    <th>driver_banned</th>\n    <th>role</th>\n  </tr>\n  <tr>\n    <td>10</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n  <tr>\n    <td>11</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n  <tr>\n    <td>12</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n  <tr>\n    <td>13</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n</table>\n<br>\n\n5. **Driver Merge**:\n   - Combine `trips_with_clients` with the modified `users` DataFrame based on `driver_id`.\n   - Utilize a left merge once more. \n   - The final merged data is stored as `full_trips`.\n\n<table>\n  <tr>\n    <th>id</th>\n    <th>client_id</th>\n    <th>driver_id</th>\n    <th>city_id</th>\n    <th>status</th>\n    <th>request_at</th>\n    <th>client_banned</th>\n    <th>client_role</th>\n    <th>driver_banned</th>\n    <th>driver_role</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>1</td>\n    <td>10</td>\n    <td>1</td>\n    <td>completed</td>\n    <td>2013-10-01</td>\n    <td>No</td>\n    <td>client</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>2</td>\n    <td>11</td>\n    <td>1</td>\n    <td>cancelled_by_driver</td>\n    <td>2013-10-01</td>\n    <td>Yes</td>\n    <td>client</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n</table>\n<br>\n\n6. **Filtering**:\n   - Apply boolean indexing to `full_trips` to:\n     - Omit entries with banned clients or drivers.\n     - Retain rows where the `request_at` date falls between '2013-10-01' and '2013-10-03'.\n   - The filtered data is saved as `filtered_trips`.\n\n<table>\n  <tr>\n    <th>id</th>\n    <th>client_id</th>\n    <th>driver_id</th>\n    <th>city_id</th>\n    <th>status</th>\n    <th>request_at</th>\n    <th>client_banned</th>\n    <th>client_role</th>\n    <th>driver_banned</th>\n    <th>driver_role</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>1</td>\n    <td>10</td>\n    <td>1</td>\n    <td>completed</td>\n    <td>2013-10-01</td>\n    <td>No</td>\n    <td>client</td>\n    <td>No</td>\n    <td>driver</td>\n  </tr>\n</table>\n<br>\n\n7. **Calculate Cancellation Rate**:\n   - Group `filtered_trips` by the `request_at` column.\n   - Within each group, determine the cancellation rate, which is the proportion of trips not marked as 'completed'. \n   - Round the result to two decimal places.\n\n<table>\n  <tr>\n    <th>request_at</th>\n    <th>Cancellation Rate</th>\n  </tr>\n  <tr>\n    <td>2013-10-01</td>\n    <td>0.33</td>\n  </tr>\n  <tr>\n    <td>2013-10-02</td>\n    <td>0.00</td>\n  </tr>\n  <tr>\n    <td>2013-10-03</td>\n    <td>0.50</td>\n  </tr>\n</table>\n<br>\n\n8. **Result Presentation**:\n   - If the computed result is empty after determining the cancellation rate, output an empty DataFrame with \"Day\" and \"Cancellation Rate\" columns.\n   - Otherwise, reset the index of the result and rename the `request_at` column as \"Day\".\n\n<table>\n  <tr>\n    <th>Day</th>\n    <th>Cancellation Rate</th>\n  </tr>\n  <tr>\n    <td>2013-10-01</td>\n    <td>0.33</td>\n  </tr>\n  <tr>\n    <td>2013-10-02</td>\n    <td>0.00</td>\n  </tr>\n  <tr>\n    <td>2013-10-03</td>\n    <td>0.50</td>\n  </tr>\n</table>\n<br>\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n<iframe src=\"https://leetcode.com/playground/Hkj2oqPS/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Hkj2oqPS\"></iframe>\n\n### Approach 2: Utilizing Intermediate DataFrames\n\n#### Intuition\n\nThe key idea here is to pinpoint the undesirable rows (or indices) and then discard them.\n\nUse boolean indexing to spot rows in the `users` DataFrame representing banned users. Subsequently, with the `isin` method, eliminate rows in the `trips` DataFrame associated with these users. Essentially, this method is about tagging certain rows or indices as \"unwanted\" and then bypassing them in the main operation.\n\n#### Algorithm\n\n1. **Data Verification:** \n    - Check if either `trips` or `users` DataFrames are empty.\n    - If so, return a DataFrame with columns \"Day\" and \"Cancellation Rate\" without any data.\n\n2. **Isolating Banned Users:** \n    - Use boolean indexing on the `users` DataFrame to extract the IDs (`users_id`) of users who are banned.\n\n3. **Filtering Relevant Trip Data:** \n    - Discard rows from the `trips` DataFrame with `client_id` or `driver_id` matching the IDs of banned users.\n    - Retain rows in the `trips` DataFrame with `request_at` dates from '2013-10-01' to '2013-10-03'.\n\n4. **Aggregating Data:** \n    - Group data in the `selected_trips` DataFrame by the `request_at` column.\n    - For each group, compute the cancellation rate by finding the ratio of non-completed trips to the total trips, rounded to two decimal places.\n\n5. **Result Compilation:** \n    - If `aggregated_result` DataFrame isn't empty, reset its index and rename the `request_at` column to 'Date'.\n    - If it's empty, return a DataFrame with columns \"Date\" and \"Cancellation Rate\" without any data.\n\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```python\nimport pandas as pd\n\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\n    # Step 1: Data Verification\n    # Check if either `trips` or `users` DataFrames are empty.\n    # If so, return a DataFrame with columns \"Day\" and \"Cancellation Rate\" without any data.\n    if trips.empty or users.empty:\n        return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"])\n\n    # Step 2: Isolating Banned Users\n    # Using boolean indexing on the `users` DataFrame, extract the IDs (`users_id`) of users who are banned.\n    banned_users_ids = users[users[\"banned\"] == \"Yes\"][\"users_id\"]\n\n    # Step 3: Filtering Relevant Trip Data\n    # Remove rows from `trips` DataFrame that have `client_id` or `driver_id` matching the IDs of banned users.\n    # Retain rows in the `trips` DataFrame that have `request_at` dates within the range of '2013-10-01' to '2013-10-03'.\n    selected_trips = trips[\n        (~trips[\"client_id\"].isin(banned_users_ids))\n        & (~trips[\"driver_id\"].isin(banned_users_ids))\n        & (trips[\"request_at\"].between(\"2013-10-01\", \"2013-10-03\"))\n    ]\n\n    # Step 4: Aggregating Data\n    # Group the data in the `selected_trips` DataFrame based on the `request_at` column.\n    # For each group, calculate the cancellation rate by determining the ratio of non-completed trips to the total number of trips, rounding to two decimal places.\n    aggregated_result = selected_trips.groupby(\"request_at\").apply(\n        lambda group: pd.Series(\n            {\n                \"Cancellation Rate\": round(\n                    (group[\"status\"] != \"completed\").sum() / len(group), 2\n                )\n            }\n        )\n    )\n\n    # Step 5: Result Compilation\n    # If the `aggregated_result` DataFrame isn't empty, reset its index and rename the `request_at` column to 'Date'.\n    # If it's empty, return a DataFrame with columns \"Date\" and \"Cancellation Rate\" without any data.\n    if aggregated_result.empty:\n        return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"])\n    else:\n        return aggregated_result.reset_index().rename(columns={\"request_at\": \"Day\"})\n\n```\n\n### Approach 3: DataFrame Transformations (Common Table Expression Equivalent)\n\n#### Intuition\n\nThe idea is to filter out trips outside of the three-day window and those involving banned users. The cancellation status of trips is simplified into binary values for easy computation. Data is grouped by day to provide granular insights, and the results are structured for clarity, offering a straightforward representation of daily cancellation rates.\n\n#### Algorithm\n\n1. **Initial Check:**\n   - If either the `trips` or `users` DataFrames are empty, return an empty DataFrame with columns \"Day\" and \"Cancellation Rate\".\n\n2. **Date-based Filtering:**\n   - Filter the `trips` DataFrame to only include records between October 1st and October 3rd, 2013.\n\n3. **Merge with Non-Banned Clients:**\n   - Merge the filtered `trips` DataFrame with the `users` DataFrame, specifically targeting non-banned users (`banned` column value is 'No'). \n   - This merge operation is based on the `client_id` from `trips` and `users_id` from `users`.\n   - This ensures that trips with banned clients are excluded.\n\n4. **Merge with Non-Banned Drivers:**\n   - Merge the resultant DataFrame from step 3 with the `users` DataFrame again, focusing on non-banned users.\n   - This time, the merge operation is based on the `driver_id` from the trips and `users_id` from `users`.\n   - This ensures that trips with banned drivers are excluded.\n\n5. **Calculate Day-wise Cancellation Rate:**\n   - Group the DataFrame by the `request_at` column, which represents the day of the trip.\n   - For each group, compute the cancellation rate by finding the ratio of non-completed trips to the total trips, rounded to two decimal places.\n\n6. **Format and Return the Result:**\n   - Reset the index of the resultant DataFrame for proper sequencing.\n   - Rename the `request_at` column to 'Day'.\n   - If the resulting DataFrame is empty, return an empty DataFrame with columns \"Day\" and \"Cancellation Rate\". Otherwise, return the computed results.\n\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```python\nimport pandas as pd\n\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\n    # Step 1: Initial Check\n    if trips.empty or users.empty:\n        return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"])\n\n    # Step 2: Date-based Filtering\n    filtered_trips = trips[trips[\"request_at\"].between(\"2013-10-01\", \"2013-10-03\")]\n\n    # Step 3: Merge with Non-Banned Clients\n    trips_with_clients = filtered_trips.merge(\n        users.loc[users[\"banned\"] == \"No\", [\"users_id\"]],\n        left_on=\"client_id\",\n        right_on=\"users_id\",\n        how=\"inner\",\n    )\n\n    # Step 4: Merge with Non-Banned Drivers\n    trip_status = trips_with_clients.merge(\n        users.loc[users[\"banned\"] == \"No\", [\"users_id\"]],\n        left_on=\"driver_id\",\n        right_on=\"users_id\",\n        how=\"inner\",\n    )\n\n    # Step 5: Calculate Day-wise Cancellation Rate\n    result = trip_status.groupby(\"request_at\").apply(\n        lambda group: pd.Series(\n            {\"Cancellation Rate\": round(\n                 (group[\"status\"] != \"completed\").sum() / len(group), 2\n                 )\n             }\n        )\n    )\n\n    # Step 6: Format and Return the Result\n    if result.empty:\n        return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"])\n    else:\n        return result.reset_index().rename(columns={\"request_at\": \"Day\"})\n\n\n```\n\n---\n\n## Database\n### Approach 1: Join\n\n#### Intuition\n\nThe idea here is to bring all the related information together first, and then decide what we need.\n\nBy joining the `Trips` table with the `Users `table twice (once for clients and once for drivers), we combine all the data we might need into one unified table. After this \"assembly\", we filter out the data that doesn't meet our criteria (e.g., banned users or dates outside our range). \n\nThis method is very direct: get everything together, then sift through to keep what's relevant.\n\n#### Algorithm\n\n1. **Table Selection**:\n   - Begin with the `Trips` table.\n\n2. **Joins**:\n   - Perform a `LEFT JOIN` with the `Users` table (aliased as `Clients`). Join on the condition that `Trips.client_id` matches `Clients.users_id`. This combines each trip with information about its client.\n   - Perform another `LEFT JOIN` with the `Users` table (aliased as `Drivers`). Join on the condition that `Trips.driver_id` matches `Drivers.users_id`. This combines each trip with information about its driver.\n\n3. **Filter Data**:\n   - `WHERE` clause: \n     - Exclude trips where the client (`Clients.banned`) is banned (`='No'`).\n     - Exclude trips where the driver (`Drivers.banned`) is banned (`='No'`).\n     - Only consider trips requested between October 1, 2013, and October 3, 2013 (`request_at BETWEEN '2013-10-01' AND '2013-10-03'`).\n\n4. **Column Selection**:\n   - Select the date the trip was requested (`request_at`) and alias it as `Day`.\n   - Calculate the cancellation rate:\n     - The numerator is the sum of trips that are not completed (`SUM(status != 'completed')`). This counts trips with a status other than 'completed' as 1, and those with 'completed' status as 0.\n     - The denominator is the total count of trips (`COUNT(*)`).\n     - Divide the numerator by the denominator and round to two decimal places using `ROUND()`. Alias this calculated value as `'Cancellation Rate'`.\n\n5. **Grouping**:\n   - `GROUP BY Day`: This groups the result set by the date of the trip request, meaning the cancellation rate will be calculated for each day separately.\n\n6. **Final Result**:\n   - For each day between October 1, 2013, and October 3, 2013, where there are trips with non-banned clients and drivers, you will get:\n     - The day.\n     - The cancellation rate for that day, rounded to two decimal places.\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```sql\nSELECT \n  request_at AS Day, \n  ROUND(\n    SUM(status != 'completed') / COUNT(*), \n    2\n  ) AS 'Cancellation Rate' \nFROM \n  Trips \n  LEFT JOIN Users AS Clients ON Trips.client_id = Clients.users_id \n  LEFT JOIN Users AS Drivers ON Trips.driver_id = Drivers.users_id \nWHERE \n  Clients.banned = 'No' \n  AND Drivers.banned = 'No' \n  AND request_at BETWEEN '2013-10-01' \n  AND '2013-10-03' \nGROUP BY \n  Day\n\n```\n\n### Approach 2: Using Subqueries\n\n#### Intuition\n\nThe idea here is to first identify the data we don't want, and then exclude them from the following calculation.\n\nInstead of gathering everything and then filtering, this approach starts by explicitly listing what to exclude. The subqueries identify banned users. The main query then fetches trips, ensuring that any trips involving these banned users are avoided.\n\n#### Algorithm\n\n1. **Initial Data Retrieval**\n    - From the table named `Trips`, retrieve rows (or records).\n\n2. **Filter by Date**\n    - Only consider rows where the `request_at` date is between the inclusive range from '2013-10-01' to '2013-10-03'.\n\n3. **Remove Banned Drivers**\n    - From the table named `Users`, retrieve all `users_id` values where `banned` is set to 'Yes'. These represent banned users.\n    - From the `Trips` table, exclude all rows where the `driver_id` is among the list of banned users from the previous step.\n\n4. **Remove Banned Clients**\n    - Similarly, from the `Trips` table, exclude all rows where the `client_id` is among the list of banned users.\n\n5. **Grouping**\n    - Group the filtered rows from the `Trips` table by the `request_at` date. For simplicity, we're renaming `request_at` to `Day`.\n\n6. **Calculate Cancellation Rate for Each Group**\n    - For each group (or for each unique date):\n        - Calculate the sum of statuses that are not 'completed'. This is done by evaluating the condition `(status != 'completed')`, which will return `1` if the status is not 'completed' and `0` otherwise. Summing this up will give the total number of non-completed statuses.\n        - Calculate the total count of `status` for that group.\n        - Divide the sum of non-completed statuses by the total count of statuses.\n        - Round the resulting value to 2 decimal places.\n        - The final result represents the \"Cancellation Rate\" for that date.\n\n7. **Output**\n    - For each date in the range, return:\n        - The date (`Day`).\n        - The corresponding cancellation rate (`Cancellation Rate`).\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```sql\nSELECT \n  request_at AS Day, \n  ROUND(\n    SUM(status != 'completed') / COUNT(status), \n    2\n  ) AS 'Cancellation Rate' \nFROM \n  Trips \nWHERE \n  request_at BETWEEN '2013-10-01' \n  AND '2013-10-03' \n  AND driver_id NOT IN (\n    SELECT \n      users_id \n    FROM \n      Users \n    WHERE \n      banned = 'Yes'\n  ) \n  AND client_id NOT IN (\n    SELECT \n      users_id \n    FROM \n      Users \n    WHERE \n      banned = 'Yes'\n  ) \nGROUP BY \n  Day\n\n```\n\n### Approach 3: Using Common Table Expression (CTE)\n\n#### Intuition\n\nThe idea here is to prepare a clean workspace with only what we need, and then work on it.\n\nThe CTE serves as this \"workspace\" or intermediary step. It pre-processes the data, filters out banned users, and selects only the desired date range. Once this clean, streamlined dataset (CTE) is ready, the main query can quickly compute the cancellation rate without distractions. \n\n#### Algorithm\n\n1. **Initialize CTE (Common Table Expression) `TripStatus`**:\n    - A CTE is like a temporary result set that you can reference within a `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statement.\n\n2. **From the `Trips` table**:\n    - Select the `Request_at` column and rename it to `Day`.\n    - Evaluate if the trip status is not 'completed'. If true, it will return 1 (true), otherwise 0 (false). This is represented by the column `cancelled`.\n\n3. **Join the `Trips` table with `Users` table for Clients**:\n    - The join condition is where `Client_Id` from the `Trips` table matches `Users_Id` from the `Users` table.\n    - Furthermore, only consider those rows where the client is not banned. This means that the `Banned` column for the client should be 'No'.\n\n4. **Join the result with `Users` table again but now for Drivers**:\n    - Similarly, the join condition is where `Driver_Id` from the `Trips` table matches `Users_Id` from the `Users` table.\n    - Again, only consider those rows where the driver is not banned. This implies that the `Banned` column for the driver should be 'No'.\n\n5. **Filter the data**:\n    - Only consider those trips which have the `Request_at` value between '2013-10-01' and '2013-10-03'.\n\n6. **Now, for the main query, using the CTE `TripStatus`**:\n    - Group the data by `Day`.\n\n7. **Calculate the Cancellation Rate for each day**:\n    - For each day, sum the `cancelled` column. This will give the total number of cancelled trips for that day because a cancelled trip is represented by 1.\n    - For each day, count the `cancelled` column. This will give the total number of trips for that day, regardless of their status.\n    - Divide the sum by the count to get the cancellation rate for each day.\n    - Round this rate to 2 decimal places.\n\n8. **Final output**:\n    - Return the `Day` and the calculated 'Cancellation Rate' for each day.\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```sql\nWITH TripStatus AS (\n  SELECT \n    Request_at AS Day, \n    T.status != 'completed' AS cancelled \n  FROM \n    Trips T \n    JOIN Users C ON Client_Id = C.Users_Id \n    AND C.Banned = 'No' \n    JOIN Users D ON Driver_Id = D.Users_Id \n    AND D.Banned = 'No' \n  WHERE \n    Request_at BETWEEN '2013-10-01' \n    AND '2013-10-03'\n) \nSELECT \n  Day, \n  ROUND(\n    SUM(cancelled) / COUNT(cancelled), \n    2\n  ) AS 'Cancellation Rate' \nFROM \n  TripStatus \nGROUP BY \n  Day;\n\n```"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/trips-and-users/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "263",
        "questionFrontendId": "263",
        "title": "Ugly Number",
        "content": "<p>An <strong>ugly number</strong> is a <em>positive</em> integer which does not have a prime factor other than 2, 3, and 5.</p>\n\n<p>Given an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>is an <strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 6 = 2 &times; 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 1 has no prime factors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> 14 is not ugly since it includes the prime factor 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 3576,
        "dislikes": 1754,
        "stats": "{\"totalAccepted\": \"621.5K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 621510, \"totalSubmissionRaw\": 1471159, \"acRate\": \"42.2%\"}",
        "similarQuestions": "[{\"title\": \"Happy Number\", \"titleSlug\": \"happy-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Primes\", \"titleSlug\": \"count-primes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/ugly-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "264",
        "questionFrontendId": "264",
        "title": "Ugly Number II",
        "content": "<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>\n\n<p>Given an integer <code>n</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1690</code></li>\n</ul>\n",
        "likes": 6660,
        "dislikes": 422,
        "stats": "{\"totalAccepted\": \"483.9K\", \"totalSubmission\": \"983.7K\", \"totalAcceptedRaw\": 483872, \"totalSubmissionRaw\": 983690, \"acRate\": \"49.2%\"}",
        "similarQuestions": "[{\"title\": \"Merge k Sorted Lists\", \"titleSlug\": \"merge-k-sorted-lists\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Primes\", \"titleSlug\": \"count-primes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Ugly Number\", \"titleSlug\": \"ugly-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Perfect Squares\", \"titleSlug\": \"perfect-squares\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Super Ugly Number\", \"titleSlug\": \"super-ugly-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Ugly Number III\", \"titleSlug\": \"ugly-number-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "The naive approach is to call <code>isUgly</code> for every number until you reach the n<sup>th</sup> one. Most numbers are <i>not</i> ugly. Try to focus your effort on generating only the ugly ones.",
          "An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.",
          "The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L<sub>1</sub>, L<sub>2</sub>, and L<sub>3</sub>.",
          "Assume you have U<sub>k</sub>, the k<sup>th</sup> ugly number. Then U<sub>k+1</sub> must be Min(L<sub>1</sub> * 2, L<sub>2</sub> * 3, L<sub>3</sub> * 5)."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Heap (Priority Queue)"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nAn ugly number is a positive integer whose prime factors are limited to `2`, `3`, and `5`. This means that for a number to be classified as ugly, it can only be divided by these primes without leaving a remainder.\n\nIn Example 2, we observe that the number `1` is considered an ugly number, even though it lacks any prime factors of `2`, `3`, or `5`. This might seem confusing initially, but the explanation clarifies that \"`1` has no prime factors; therefore, all of its prime factors are limited to `2`, `3`, and `5`.\" This statement can be somewhat misleading if not properly understood. It implies that since `1` has no prime factors, it doesn't violate the rule that ugly numbers can only have prime factors of `2`, `3`, or `5`. In essence, `1` automatically meets the condition, as there are no prime factors to contradict the rule.\n\n> In short `1` is an ugly number because it can be expressed as $2^0 \\times 3^0 \\times 5^0$\n\n### Approach 1: Using Set \n\n#### Intuition\n\nWe begin with a brute force approach where the goal is to count ugly numbers one by one until we reach the nth ugly number. We can create a helper function that checks if a number is ugly by repeatedly dividing it by `2`, `3`, and `5` until it's no longer divisible by these primes. If the result is `1`, the number is ugly. We then iterate through integers applying this check, and count the ugly numbers we encounter. While this method works, it\u2019s inefficient as it checks every number sequentially, including those clearly not ugly (e.g., numbers divisible by other primes). This results in high time complexity, making it unsuitable for large values of `n`.\n\nTo improve upon the brute force method, we can leverage a key property of ugly numbers: if a number is ugly, multiplying it by `2`, `3`, or `5` also yields an ugly number. This insight allows us to generate ugly numbers systematically rather than checking each number individually.\n\nWe start with the first ugly number, which is `1`. From there, we generate the next candidates by multiplying `1` by `2`, `3`, and `5`. These candidates represent the next potential ugly numbers. To ensure we always process the smallest ugly numbers first (necessary to find the nth one), we use a set that keeps elements in sorted order and removes duplicates. We continue this process until we reach the nth ugly number.\n\nThis approach is more efficient as it avoids unnecessary checks and focuses solely on generating and managing ugly numbers. However, it requires maintaining a set, which can grow large and impact memory usage.\n\n#### Algorithm\n\n- Initialize a set named `uglyNumbersSet` to store potential ugly numbers.\n- Insert the first ugly number, `1`, into the `uglyNumbersSet`.\n- Initialize a variable `currentUgly` to store the current smallest ugly number.\n\n- Loop `n` times to find the `n`th ugly number:\n  - In each iteration:\n    - Set `currentUgly` to the smallest number in the `uglyNumbersSet` by accessing the first element.\n    - Remove this smallest number from the `uglyNumbersSet` using `erase`.\n    \n    - Insert the next potential ugly numbers by multiplying `currentUgly` by `2`, `3`, and `5`:\n      - Insert `currentUgly * 2` into the `uglyNumbersSet`.\n      - Insert `currentUgly * 3` into the `uglyNumbersSet`.\n      - Insert `currentUgly * 5` into the `uglyNumbersSet`.\n\n- After the loop completes, `currentUgly` will hold the nth ugly number.\n\n- Return `currentUgly` as the result, casting it to `int`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/EoE3dVbv/shared\" frameBorder=\"0\" width=\"100%\" height=\"446\" name=\"EoE3dVbv\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the given index value of the ugly number and $m$ be the size of set.\n\n- Time complexity: $O(n \\log m)$\n\n    Each insertion and removal operation in the set takes logarithmic time.\n\n    > In Python, the `min` function has a time complexity of $O(n)$ due to the need to scan through all elements of the set to find the minimum. Since this function is called once per iteration of the loop and there are $n$ iterations, the overall time complexity is $O(n \\times m)$.\n\n- Space complexity: $O(m)$\n\n    The space required depends on the number of unique ugly numbers stored in the set.  \n\n---\n\n### Approach 2: Min-Heap/Priority Queue\n\n#### Intuition\n\nTo further streamline the process, we use a priority queue (min-heap) to efficiently manage and retrieve the smallest ugly number. We start with `1` as our base ugly number and insert it into the min-heap. The priority queue keeps the smallest element at the top, so we can easily access and remove it to get the next ugly number.\n\nAfter popping the smallest ugly number, we generate new ugly numbers by multiplying them by `2`, `3`, and `5`. These new numbers are then pushed back into the queue. To avoid duplicates, we use a set to track numbers that have already been added, ensuring each ugly number is processed only once.\n\n#### Algorithm\n \n- Create a min-heap (`minHeap`) to store ugly numbers and a set (`seenNumbers`) to track numbers already processed.\n- Push the first ugly number (1) into the heap and insert it into the set.\n- For `n` iterations:\n   - Pop the smallest ugly number (`currentUgly`) from the heap.\n   - Generate the next ugly numbers by multiplying `currentUgly` with 2, 3, and 5.\n   - If a generated ugly number is not in the set, push it into the heap and add it to the set.\n- After `n` iterations, the last popped number from the heap is the nth ugly number.\n- Return the `n`th ugly number.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/5d395Zkn/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"5d395Zkn\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the given index value of the ugly number and $m$ be the size of set.\n\n\n* Time complexity: $O(n \\log m)$\n\n    The operations on the priority queue (`push` and `pop`) take logarithmic time, and there are `m` such operations. \n\n* Space complexity: $O(m)$\n\n    The space is used by the heap and the set, which store up to `m` elements as it depends on the number of unique ugly numbers stored in the set.\n\n---\n\n### Approach 3: Dynamic Programming (DP)\n\n#### Intuition\n\nThe dynamic programming (DP) approach to finding ugly numbers is based on an idea: every ugly number, except for `1`, is generated by multiplying a smaller ugly number by either `2`, `3`, or `5`. This insight allows us to systematically generate ugly numbers in order.\n\nWe start with `1`, the smallest ugly number. To find the next ugly number, we have three options: $1 \\times 2$, $1 \\times 3$, and $1 \\times 5$. The smallest of these, $1 \\times 2 = 2$, becomes our second ugly number. For the third ugly number, we again have three choices: the next multiple of `2` ($2 \\times 2 = 4$), and the unused multiples of `3` and `5` from before ($1 \\times 3 = 3$ and $1 \\times 5 = 5$). We select the smallest of these (which is $3$) and continue this process.\n\nThis approach naturally leads to using three pointers, one each for multiplying by `2`, `3`, and `5`. These pointers track which ugly number should be multiplied by `2`, `3`, and `5` next. Each time, we choose the smallest of these three possible next ugly numbers, add it to our list, and move the pointer that produced this number.\n\nThe efficiency and cleverness of this method lie in its simplicity. We build our list of ugly numbers using the same list we are creating. This self-referencing nature characterizes it as dynamic programming. By maintaining the list in order and using pointers, we avoid the need for sorting or removing duplicates, making the algorithm both fast ($O(n)$) and memory-efficient.\n\nNow, let's think about why this method works for all ugly numbers:\n\nWe always start by choosing the smallest number available and manage the process of multiplying by `2`, `3`, and `5` separately. This approach ensures that no ugly numbers are missed. Specifically, any ugly number must be derived from a previously found smaller ugly number, multiplied by `2`, `3`, or `5`. By maintaining pointers to track these multiplications, we ensure that every number in our list is properly considered for these multiplications.\n\nBy always selecting the smallest number first from the available multiplications, we prevent the introduction of larger numbers before smaller ones. This strategy eliminates the possibility of missing any ugly numbers, ensuring a consistent and complete generation of ugly numbers.\n\n\n<details>\n<summary><b>For A Formal Proof Click Here:</b></summary>\n\n**Proof:**\n\n1. Base Case:\n   - We start with `1`, which is an ugly number because it can be expressed as $2^0 \\times 3^0 \\times 5^0$. This is our starting point and is correctly included in the list.\n\n2. Inductive Hypothesis:\n   - Assume that after generating $k$ ugly numbers, denoted as $U_1, U_2, \\ldots, U_k$, our list contains all ugly numbers up to the $k$-th position in ascending order.\n\n3. Inductive Step:\n   - **Goal:** Show that the algorithm correctly generates the $(k+1)$-th ugly number.\n\n   - Given our current list $U_1, U_2, \\ldots, U_k$, we consider the next possible ugly numbers by multiplying each number in the list by 2, 3, and 5. These potential numbers are $U_i \\times 2$, $U_i \\times 3$, and $U_i \\times 5$, where $U_i$ is the smallest number in the list at that step.\n\n   - We always select the smallest number from these candidates and add it to our list. Let\u2019s denote this smallest number as $N$. By design, $N$ is the next smallest ugly number that hasn't been added to the list yet.\n\n   - Exhaustiveness:\n     - We ensure that every ugly number is generated by considering all possible multiplications of the smallest numbers. This way, we don't miss any possible ugly number.\n\n   - Non-Redundancy:\n     - By selecting the smallest number each time, we avoid adding duplicate numbers. This ensures that each number added to the list is unique and correctly ordered.\n\n   - Completeness:\n     - Every ugly number must be derived from previously generated ugly numbers through multiplication by 2, 3, or 5. Our method covers all such possible combinations, so it will eventually generate every ugly number.\n\n4. Termination:\n   - The algorithm stops once we have generated the desired number of ugly numbers. Since we are systematically adding the smallest possible ugly number at each step, our list will be complete and correctly ordered.\n\n**Conclusion:**\nBy using induction, we see that starting from the base case of `1`, and ensuring each subsequent number is the smallest possible ugly number, we guarantee that our algorithm will generate all ugly numbers in ascending order. This method is both correct and complete, as it ensures that no ugly numbers are missed or duplicated.\n\n</details>\n\n#### Algorithm\n \n1. Initialize a vector `uglyNumbers` of size `n` to store the ugly numbers, with the first ugly number set to `1`.\n2. Set up three pointers (`indexMultipleOf2`, `indexMultipleOf3`, `indexMultipleOf5`) to track the next multiples of 2, 3, and 5, respectively.\n3. Assign initial values to `nextMultipleOf2`, `nextMultipleOf3`, and `nextMultipleOf5` (i.e., `2`, `3`, and `5`).\n4. For `i` from `1` to `n-1`:\n   - Determine the next ugly number by taking the minimum of `nextMultipleOf2`, `nextMultipleOf3`, and `nextMultipleOf5`.\n   - Store this value in `uglyNumbers[i]`.\n   - Update the corresponding pointer and multiple:\n     - If the next ugly number equals `nextMultipleOf2`, increment `indexMultipleOf2` and update `nextMultipleOf2`.\n     - If the next ugly number equals `nextMultipleOf3`, increment `indexMultipleOf3` and update `nextMultipleOf3`.\n     - If the next ugly number equals `nextMultipleOf5`, increment `indexMultipleOf5` and update `nextMultipleOf5`.\n5. After completing the loop, return the last element in `uglyNumbers`, which is the `n`th ugly number.\n\nThe algorithm is visualized below:\n\n!?!../Documents/264/dp.json:975,595!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/KLoTWTep/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"KLoTWTep\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the given index value of the ugly number.\n\n* Time complexity: $O(n)$\n\n    This approach is linear because we generate each ugly number directly using the three pointers.\n\n* Space complexity: $O(n)$\n\n    We need space to store the first `n` ugly numbers.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/ugly-number-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "265",
        "questionFrontendId": "265",
        "title": "Paint House II",
        "content": null,
        "likes": 1333,
        "dislikes": 39,
        "stats": "{\"totalAccepted\": \"135.7K\", \"totalSubmission\": \"241.4K\", \"totalAcceptedRaw\": 135665, \"totalSubmissionRaw\": 241431, \"acRate\": \"56.2%\"}",
        "similarQuestions": "[{\"title\": \"Product of Array Except Self\", \"titleSlug\": \"product-of-array-except-self\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Paint House\", \"titleSlug\": \"paint-house\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint Fence\", \"titleSlug\": \"paint-fence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/paint-house-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "266",
        "questionFrontendId": "266",
        "title": "Palindrome Permutation",
        "content": null,
        "likes": 1095,
        "dislikes": 73,
        "stats": "{\"totalAccepted\": \"225.5K\", \"totalSubmission\": \"329.4K\", \"totalAcceptedRaw\": 225486, \"totalSubmissionRaw\": 329438, \"acRate\": \"68.4%\"}",
        "similarQuestions": "[{\"title\": \"Longest Palindromic Substring\", \"titleSlug\": \"longest-palindromic-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Anagram\", \"titleSlug\": \"valid-anagram\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation II\", \"titleSlug\": \"palindrome-permutation-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Palindrome\", \"titleSlug\": \"longest-palindrome\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Consider the palindromes of odd vs even length. What difference do you notice?",
          "Count the frequency of each character.",
          "If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times?"
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/palindrome-permutation/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "267",
        "questionFrontendId": "267",
        "title": "Palindrome Permutation II",
        "content": null,
        "likes": 891,
        "dislikes": 97,
        "stats": "{\"totalAccepted\": \"73.3K\", \"totalSubmission\": \"174.2K\", \"totalAcceptedRaw\": 73310, \"totalSubmissionRaw\": 174246, \"acRate\": \"42.1%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations II\", \"titleSlug\": \"permutations-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation\", \"titleSlug\": \"palindrome-permutation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If a palindromic permutation exists, we just need to generate the first half of the string.",
          "To generate all distinct permutations of a (half of) string, use a similar approach from: <a href=\"/problems/permutations-ii\">Permutations II</a> or <a href=\"/problems/next-permutation\">Next Permutation</a>."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/palindrome-permutation-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "268",
        "questionFrontendId": "268",
        "title": "Missing Number",
        "content": "<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [3,0,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><code>n = 3</code> since there are 3 numbers, so all numbers are in the range <code>[0,3]</code>. 2 is the missing number in the range since it does not appear in <code>nums</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [0,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><code>n = 2</code> since there are 2 numbers, so all numbers are in the range <code>[0,2]</code>. 2 is the missing number in the range since it does not appear in <code>nums</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [9,6,4,2,3,5,7,0,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">8</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><code>n = 9</code> since there are 9 numbers, so all numbers are in the range <code>[0,9]</code>. 8 is the missing number in the range since it does not appear in <code>nums</code>.</p>\n</div>\n\n<div class=\"simple-translate-system-theme\" id=\"simple-translate\">\n<div>\n<div class=\"simple-translate-button isShow\" style=\"background-image: url(&quot;moz-extension://8a9ffb6b-7e69-4e93-aae1-436a1448eff6/icons/512.png&quot;); height: 22px; width: 22px; top: 318px; left: 36px;\">&nbsp;</div>\n\n<div class=\"simple-translate-panel \" style=\"width: 300px; height: 200px; top: 0px; left: 0px; font-size: 13px;\">\n<div class=\"simple-translate-result-wrapper\" style=\"overflow: hidden;\">\n<div class=\"simple-translate-move\" draggable=\"true\">&nbsp;</div>\n\n<div class=\"simple-translate-result-contents\">\n<p class=\"simple-translate-result\" dir=\"auto\">&nbsp;</p>\n\n<p class=\"simple-translate-candidate\" dir=\"auto\">&nbsp;</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p>\n",
        "likes": 12994,
        "dislikes": 3401,
        "stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 2947509, \"totalSubmissionRaw\": 4233905, \"acRate\": \"69.6%\"}",
        "similarQuestions": "[{\"title\": \"First Missing Positive\", \"titleSlug\": \"first-missing-positive\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Couples Holding Hands\", \"titleSlug\": \"couples-holding-hands\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find Unique Binary String\", \"titleSlug\": \"find-unique-binary-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Largest Almost Missing Integer\", \"titleSlug\": \"find-the-largest-almost-missing-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/missing-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "269",
        "questionFrontendId": "269",
        "title": "Alien Dictionary",
        "content": null,
        "likes": 4557,
        "dislikes": 1022,
        "stats": "{\"totalAccepted\": \"435.5K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 435488, \"totalSubmissionRaw\": 1191913, \"acRate\": \"36.5%\"}",
        "similarQuestions": "[{\"title\": \"Course Schedule II\", \"titleSlug\": \"course-schedule-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Topological Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/alien-dictionary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "270",
        "questionFrontendId": "270",
        "title": "Closest Binary Search Tree Value",
        "content": null,
        "likes": 1863,
        "dislikes": 159,
        "stats": "{\"totalAccepted\": \"410K\", \"totalSubmission\": \"819.9K\", \"totalAcceptedRaw\": 409971, \"totalSubmissionRaw\": 819943, \"acRate\": \"50.0%\"}",
        "similarQuestions": "[{\"title\": \"Count Complete Tree Nodes\", \"titleSlug\": \"count-complete-tree-nodes\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Search in a Binary Search Tree\", \"titleSlug\": \"search-in-a-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Closest Nodes Queries in a Binary Search Tree\", \"titleSlug\": \"closest-nodes-queries-in-a-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Binary Search"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/closest-binary-search-tree-value/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "271",
        "questionFrontendId": "271",
        "title": "Encode and Decode Strings",
        "content": null,
        "likes": 1519,
        "dislikes": 439,
        "stats": "{\"totalAccepted\": \"249.8K\", \"totalSubmission\": \"507.5K\", \"totalAcceptedRaw\": 249806, \"totalSubmissionRaw\": 507477, \"acRate\": \"49.2%\"}",
        "similarQuestions": "[{\"title\": \"Count and Say\", \"titleSlug\": \"count-and-say\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Serialize and Deserialize Binary Tree\", \"titleSlug\": \"serialize-and-deserialize-binary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"String Compression\", \"titleSlug\": \"string-compression\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Binary Substrings\", \"titleSlug\": \"count-binary-substrings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Design"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/encode-and-decode-strings/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "272",
        "questionFrontendId": "272",
        "title": "Closest Binary Search Tree Value II",
        "content": null,
        "likes": 1318,
        "dislikes": 48,
        "stats": "{\"totalAccepted\": \"128.3K\", \"totalSubmission\": \"213.6K\", \"totalAcceptedRaw\": 128343, \"totalSubmissionRaw\": 213573, \"acRate\": \"60.1%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Closest Binary Search Tree Value\", \"titleSlug\": \"closest-binary-search-tree-value\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Closest Nodes Queries in a Binary Search Tree\", \"titleSlug\": \"closest-nodes-queries-in-a-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Consider implement these two helper functions:\r\n<ol type=\"i\"><li><code>getPredecessor(N)</code>, which returns the next smaller node to N.</li>\r\n<li><code>getSuccessor(N)</code>, which returns the next larger node to N.</li>\r\n</ol>",
          "Try to assume that each node has a parent pointer, it makes the problem much easier.",
          "Without parent pointer we just need to keep track of the path from the root to the current node using a stack.",
          "You would need two stacks to track the path in finding predecessor and successor node separately."
        ],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/closest-binary-search-tree-value-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "273",
        "questionFrontendId": "273",
        "title": "Integer to English Words",
        "content": "<p>Convert a non-negative integer <code>num</code> to its English words representation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 123\n<strong>Output:</strong> &quot;One Hundred Twenty Three&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 12345\n<strong>Output:</strong> &quot;Twelve Thousand Three Hundred Forty Five&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 1234567\n<strong>Output:</strong> &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 3715,
        "dislikes": 6780,
        "stats": "{\"totalAccepted\": \"537.6K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 537642, \"totalSubmissionRaw\": 1568549, \"acRate\": \"34.3%\"}",
        "similarQuestions": "[{\"title\": \"Integer to Roman\", \"titleSlug\": \"integer-to-roman\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.",
          "Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.",
          "There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)"
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to create a program that converts any non-negative integer into its English word representation. The program must handle the English numbering system accurately, including terms like thousands, millions, and billions, and must follow the rules for numbers below one hundred to ensure correct phrasing.  \n\n**Key Points:**\n- The input can range from `0` to `2,147,483,647` (i.e., the maximum value for a 32-bit signed integer).\n- The first letter of each word must be capitalized.\n- Words should be separated by a single space, with no trailing spaces.\n\nObserve the tree diagram below to understand how numbers are spelled out in English, along with their corresponding units and scales. This will help us see the repetitive patterns and their resemblance to a tree data structure, which lends itself to a recursive approach.\n\n![Number_Tree](../Figures/273/273_Integer_to_english.png)\n\n---\n\n### Approach 1: Recursive Approach\n\n#### Intuition\n\nIn the recursive approach, we break down the number into smaller parts based on place values such as ones, tens, hundreds, thousands, millions, and so on.\n\nWe start with the largest place value and proceed downward. For example, with the number `1234567`, we first handle the millions part (`1 Million`).\n\nWe use a helper function that recursively breaks down the number. If the number is less than `10`, we return the corresponding word from a predefined list (`belowTen`). For numbers less than `20`, we use another list (`belowTwenty`) due to their unique names.\n\nFor numbers below `100`, we combine the word for the tens place (from `belowHundred`) with the word for the ones place, using further recursive calls. For numbers below `1000`, we break the number into hundreds and the remainder, processing each part recursively.\n\nFor larger numbers like `1234567`, the function handles the millions part (`1 Million`), then the thousands (`234 Thousand`), and finally the hundreds and smaller units (`567`). Each chunk is processed using recursive calls, building the final English representation from smallest to largest units.\n\nThe recursive function works as follows:\n- **Base Case**: For numbers less than 10, the function directly maps to a word using `belowTen`. For numbers between 10 and 19, `belowTwenty` handles these unique cases. For numbers between 20 and 99, it combines words from `belowHundred` for tens and recursively processes the remainder for units.\n- **Recursive Case**: For numbers 100 and above, the function processes hundreds, thousands, millions, and billions by breaking the number into smaller parts. For example, for `1234567`, it processes the millions part (`1 Million`), then the thousands part (`234 Thousand`), and finally the remainder (`567`). Each part is processed recursively to ensure accurate conversion.\n\nAfter processing each chunk, we combine the results, handling the hierarchical structure from the smallest unit up to the largest (like billions), ensuring that each segment is correctly represented in English.\n\n#### Algorithm\n\n- Initialize arrays to store words for different ranges of numbers:\n  - `belowTen` for numbers 1-9.\n  - `belowTwenty` for numbers 10-19.\n  - `belowHundred` for multiples of ten from 20-90.\n\n- Define the main function `numberToWords` to handle the conversion:\n  - If the number is zero, return `\"Zero\"`.\n  - Otherwise, call the helper function `convertToWords` to start the conversion process.\n\n- Implement the helper function `convertToWords` to convert numbers to words recursively:\n  - Base Case 1: Numbers less than 10:\n    - Return the corresponding word from `belowTen`.\n  - Base Case 2: Numbers less than 20:\n    - Return the corresponding word from `belowTwenty`.\n  - Numbers from 20 to 99:\n    - Combine the word for the tens place from `belowHundred` with the recursive result for the units place.\n  - Numbers from 100 to 999:\n    - Combine the recursive result for the hundreds place with `\"Hundred\"`, and the recursive result for the remaining part.\n  - Numbers from 1000 to 999,999:\n    - Combine the recursive result for thousands with `\"Thousand\"`, and the recursive result for the remaining part.\n  - Numbers from 1,000,000 to 999,999,999:\n    - Combine the recursive result for millions with `\"Million\"`, and the recursive result for the remaining part.\n  - Numbers 1,000,000,000 and above:\n    - Combine the recursive result for billions with `\"Billion\"`, and the recursive result for the remaining part.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/gWF2VCjV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gWF2VCjV\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number.\n\n- Time complexity: $O(\\log_{10} N)$\n\n    The time complexity is $O(\\log_{10} N)$ because the number of recursive calls is proportional to the number of digits in the number, which grows logarithmically with the size of the number.\n\n- Space complexity: $O(\\log_{10} N)$\n\n    The space complexity is $O(\\log_{10} N)$, mainly because of the recursion stack. Each recursive call adds a frame to the stack until the base case is reached, leading to space usage proportional to the number of digits in the number.\n\n---\n\n### Approach 2: Iterative Approach\n\n#### Intuition\n\nIn the iterative approach, we convert a number into English words by processing it in chunks of three digits, corresponding to thousands, millions, billions, etc.\n\nWe initialize arrays for place value words (like thousand, million, billion) and for digit and tens names. A loop processes the number from the least significant chunk (ones, tens, hundreds) to the most significant chunk (thousands, millions, billions).\n\nFor instance, with the number `1234567`, we repeatedly use the modulus operation `% 1000` to extract chunks of three digits. We start by using `1234567 % 1000` to get `567`, then `1234 % 1000` to get `234`, and finally `1 % 1000` to get `1`. Each chunk is then converted to English words.\"\n\nTo convert each chunk:\n1. Handle the hundreds place if present (e.g., `567` becomes \"Five Hundred\").\n2. Process the tens and ones (e.g., `67` becomes \"Sixty-Seven\").\n3. Append the appropriate scale word (e.g., thousand, million) based on the chunk's position (e.g., `234` becomes \"Two Hundred Thirty-Four Thousand\").\n\nWe track the scale by using an index (`groupIndex`) that increments with each chunk processed. This index is used to fetch the correct scale word (thousand, million, billion) from the thousands array. For example:\n\n- `groupIndex = 0`: No scale word (ones place).\n- `groupIndex = 1`: \"Thousand\".\n- `groupIndex = 2`: \"Million\".\n- `groupIndex = 3`: \"Billion\".\n\nWe build the final result by concatenating the words for each chunk, starting from the least significant chunk and moving to the most significant. This ensures the correct placement of scale words and produces the final English representation of the entire number.\n\n#### Algorithm\n \n- Handle the special case where the number is zero by returning `\"Zero\"`.\n- Initialize arrays to store words for single digits, tens, and thousands:\n  - `ones` for numbers 1-19.\n  - `tens` for multiples of ten from 20-90.\n  - `thousands` for scales (`\"Thousand\"`, `\"Million\"`, `\"Billion\"`).\n- Process the number in chunks of 1000.\n  - Extract the last three digits of the number and handle hundreds, tens, and units:\n    - Handle hundreds place by adding the corresponding word from `ones` and `\"Hundred\"`.\n    - Handle tens and units place by combining the word from `tens` and `ones`.\n  - Append the scale (`\"Thousand\"`, `\"Million\"`, `\"Billion\"`) for the current group.\n  - Insert the group result at the beginning of the final result.\n- Move to the next chunk of 1000 by dividing the number by 1000.\n- Return the result after removing trailing spaces. \n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/Zu9faq2G/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Zu9faq2G\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number.\n\n* Time complexity: $O(\\log_{10} N)$\n\n    $O(\\log_{10} N)$, because the number is divided by 1000 in each iteration, making the number of iterations proportional to the number of chunks, which is logarithmic.\n\n* Space complexity: $O(1)$\n\n    $O(1)$, constant space. The space used is independent of the number's size, as it involves only a few string builders and arrays.\n\n---\n\n### Approach 3: Pair-Based Approach\n\n#### Intuition\n\nIn the pair-based approach, we use a predefined list of numeric values and their corresponding English words to convert a number. We process the number by matching it against these pairs from largest to smallest, dividing the number, and converting each part recursively.\n\nWe start by defining a list of pairs where each pair consists of a numeric value and its English word, such as `1000000000` for \"Billion\", `1000000` for \"Million\", and down to `1` for \"One\". This list facilitates conversion by identifying which value fits into the current number.\n\nFor a number like `1234567`, we iterate through the list from the largest value to the smallest. We check if the number is greater than or equal to each value. If it is:\n- **Divide the Number**: Determine how many times the value fits into the number (the quotient) and calculate the remainder. For `1234567`, we match `1 Million`, resulting in \"One Million\", and then process the remainder (`234567`).\n- **Recursive Conversion**: Convert the quotient to words and recursively process the remainder using the same list of pairs.\n\nWe concatenate the word for the current pair with the results from the recursive call for the remainder. This process builds the final English word representation from the largest units (like billion) to the smallest (like one), ensuring an accurate representation of every part of the number.\n\n#### Algorithm\n\n- Initialize a pair `numberToWordsMap` that maps numeric values to their corresponding English words:\n  - Includes large scales (`\"Billion\"`, `\"Million\"`, `\"Thousand\"`, `\"Hundred\"`) and individual numbers (1-19, and multiples of ten from 20 to 90).\n\n- Handle the special case where the number is zero by returning `\"Zero\"`.\n\n- Call the function `numberToWords` to convert the number to English words:\n  - Iterate over the `numberToWordsMap`:\n    - For each pair `(value, word)` in `numberToWordsMap`, check if the number `num` is greater than or equal to `value`.\n      - If `num` is greater than or equal to `value`:\n        - Compute the `prefix`:\n          - If `num` is 100 or greater, recursively convert the quotient (`num / value`) to words and append `\" \"` (a space). If `num` is less than 100, set `prefix` to an empty string.\n        - Get the `unit` as the current `word` from `numberToWordsMap`.\n        - Compute the `suffix`:\n          - If the remainder (`num % value`) is zero, set `suffix` to an empty string. Otherwise, recursively convert the remainder to words and prepend `\" \"` (a space).\n        - Return the combined result: `prefix + unit + suffix`.\n\n- If the number is not zero, the function will return the complete English representation by combining the `prefix`, `unit`, and `suffix`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/KJL7Kbac/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"KJL7Kbac\"></iframe>\n\n#### Complexity Analysis\n\nLet $K$ be the number of pairs in `numberToWordsMap` and $N$ be the number.\n\n- Time complexity: $O(K)$\n\n    The time complexity is $O(K)$ because the loop iterates through the pairs until it finds a match. This complexity is linear with respect to the number of pairs, which is constant in practice as the number of pairs is fixed.\n\n- Space complexity: $O(\\log_{10} N)$\n\n    $O(\\log_{10} N)$, mainly due to the recursion stack in the `convert` function. The space used is proportional to the number of recursive calls made.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/integer-to-english-words/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "274",
        "questionFrontendId": "274",
        "title": "H-Index",
        "content": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper, return <em>the researcher&#39;s h-index</em>.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [3,0,6,1,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [1,3,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 1628,
        "dislikes": 764,
        "stats": "{\"totalAccepted\": \"695.3K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 695295, \"totalSubmissionRaw\": 1736116, \"acRate\": \"40.0%\"}",
        "similarQuestions": "[{\"title\": \"H-Index II\", \"titleSlug\": \"h-index-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "An easy approach is to sort the array first.",
          "What are the possible values of h-index?",
          "A faster approach is to use extra space."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Counting Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/h-index/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "275",
        "questionFrontendId": "275",
        "title": "H-Index II",
        "content": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper and <code>citations</code> is sorted in <strong>non-descending order</strong>, return <em>the researcher&#39;s h-index</em>.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>\n\n<p>You must write an algorithm that runs in logarithmic time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [0,1,3,5,6]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [1,2,100]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> is sorted in <strong>ascending order</strong>.</li>\n</ul>\n",
        "likes": 434,
        "dislikes": 126,
        "stats": "{\"totalAccepted\": \"234.6K\", \"totalSubmission\": \"605.7K\", \"totalAcceptedRaw\": 234594, \"totalSubmissionRaw\": 605714, \"acRate\": \"38.7%\"}",
        "similarQuestions": "[{\"title\": \"H-Index\", \"titleSlug\": \"h-index\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Expected runtime complexity is in <i>O</i>(log <i>n</i>) and the input is sorted."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/h-index-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "276",
        "questionFrontendId": "276",
        "title": "Paint Fence",
        "content": null,
        "likes": 1609,
        "dislikes": 392,
        "stats": "{\"totalAccepted\": \"121.9K\", \"totalSubmission\": \"256.1K\", \"totalAcceptedRaw\": 121864, \"totalSubmissionRaw\": 256128, \"acRate\": \"47.6%\"}",
        "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House\", \"titleSlug\": \"paint-house\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/paint-fence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "277",
        "questionFrontendId": "277",
        "title": "Find the Celebrity",
        "content": null,
        "likes": 2940,
        "dislikes": 307,
        "stats": "{\"totalAccepted\": \"299.3K\", \"totalSubmission\": \"619.5K\", \"totalAcceptedRaw\": 299269, \"totalSubmissionRaw\": 619535, \"acRate\": \"48.3%\"}",
        "similarQuestions": "[{\"title\": \"Find the Town Judge\", \"titleSlug\": \"find-the-town-judge\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "The best hint for this problem can be provided by the following figure:\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_find_celebrity.png\" width=\"700\"/>",
          "Well, if you understood the gist of the above idea, you can extend it to find a candidate that can possibly be a celebrity. Why do we say a \"candidate\"? That is for you to think. This is clearly a greedy approach to find the answer. However, there is some information that would still remain to be verified without which we can't obtain an answer with certainty. To get that stake in the ground, we would need some more calls to the knows API."
        ],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Interactive"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/find-the-celebrity/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "278",
        "questionFrontendId": "278",
        "title": "First Bad Version",
        "content": "<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>\n\n<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>\n\n<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, bad = 4\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\ncall isBadVersion(3) -&gt; false\ncall isBadVersion(5)&nbsp;-&gt; true\ncall isBadVersion(4)&nbsp;-&gt; true\nThen 4 is the first bad version.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, bad = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 8662,
        "dislikes": 3369,
        "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"4.2M\", \"totalAcceptedRaw\": 1904458, \"totalSubmissionRaw\": 4167817, \"acRate\": \"45.7%\"}",
        "similarQuestions": "[{\"title\": \"Find First and Last Position of Element in Sorted Array\", \"titleSlug\": \"find-first-and-last-position-of-element-in-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Search Insert Position\", \"titleSlug\": \"search-insert-position\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Guess Number Higher or Lower\", \"titleSlug\": \"guess-number-higher-or-lower\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Binary Search"
          },
          {
            "name": "Interactive"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/first-bad-version/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "279",
        "questionFrontendId": "279",
        "title": "Perfect Squares",
        "content": "<p>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p>\n\n<p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 12\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 12 = 4 + 4 + 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 13 = 4 + 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 11485,
        "dislikes": 482,
        "stats": "{\"totalAccepted\": \"945K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 945036, \"totalSubmissionRaw\": 1702145, \"acRate\": \"55.5%\"}",
        "similarQuestions": "[{\"title\": \"Count Primes\", \"titleSlug\": \"count-primes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Ways to Express an Integer as Sum of Powers\", \"titleSlug\": \"ways-to-express-an-integer-as-sum-of-powers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Breadth-First Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/perfect-squares/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "280",
        "questionFrontendId": "280",
        "title": "Wiggle Sort",
        "content": null,
        "likes": 1229,
        "dislikes": 103,
        "stats": "{\"totalAccepted\": \"151.2K\", \"totalSubmission\": \"222K\", \"totalAcceptedRaw\": 151247, \"totalSubmissionRaw\": 221984, \"acRate\": \"68.1%\"}",
        "similarQuestions": "[{\"title\": \"Sort Colors\", \"titleSlug\": \"sort-colors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Wiggle Sort II\", \"titleSlug\": \"wiggle-sort-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Array With Elements Not Equal to Average of Neighbors\", \"titleSlug\": \"array-with-elements-not-equal-to-average-of-neighbors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/wiggle-sort/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "281",
        "questionFrontendId": "281",
        "title": "Zigzag Iterator",
        "content": null,
        "likes": 692,
        "dislikes": 41,
        "stats": "{\"totalAccepted\": \"102.9K\", \"totalSubmission\": \"157.3K\", \"totalAcceptedRaw\": 102915, \"totalSubmissionRaw\": 157346, \"acRate\": \"65.4%\"}",
        "similarQuestions": "[{\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Peeking Iterator\", \"titleSlug\": \"peeking-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten Nested List Iterator\", \"titleSlug\": \"flatten-nested-list-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Merge Strings Alternately\", \"titleSlug\": \"merge-strings-alternately\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Queue"
          },
          {
            "name": "Iterator"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/zigzag-iterator/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "282",
        "questionFrontendId": "282",
        "title": "Expression Add Operators",
        "content": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 3564,
        "dislikes": 676,
        "stats": "{\"totalAccepted\": \"269K\", \"totalSubmission\": \"651.1K\", \"totalAcceptedRaw\": 269017, \"totalSubmissionRaw\": 651101, \"acRate\": \"41.3%\"}",
        "similarQuestions": "[{\"title\": \"Evaluate Reverse Polish Notation\", \"titleSlug\": \"evaluate-reverse-polish-notation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator II\", \"titleSlug\": \"basic-calculator-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Target Sum\", \"titleSlug\": \"target-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Note that a number can contain multiple digits.",
          "Since the question asks us to find <b>all</b> of the valid expressions, we need a way to iterate over all of them. (<b>Hint:</b> Recursion!)",
          "We can keep track of the expression string and evaluate it at the very end. But that would take a lot of time. Can we keep track of the expression's value as well so as to avoid the evaluation at the very end of recursion?",
          "Think carefully about the multiply operator. It has a higher precedence than the addition and subtraction operators. \r\n\r\n<br> 1 + 2 = 3  <br>\r\n1 + 2 - 4 --> 3 - 4 --> -1 <br>\r\n1 + 2 - 4 * 12 --> -1 * 12 --> -12 (WRONG!) <br>\r\n1 + 2 - 4 * 12 --> -1 - (-4) + (-4 * 12) --> 3 + (-48) --> -45 (CORRECT!)",
          "We simply need to keep track of the last operand in our expression and reverse it's effect on the expression's value while considering the multiply operator."
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n---\n\n### Approach 1: Backtracking\n\n**Intuition**\n\nLet us first look at what the question asks us to do before getting at the approach to solve it. So, we are given a string of numbers and 3 different operators:\n\n* `+` Addition,\n* `-` Subtraction or\n* `*` Multiplication\n\nWe have to find all possible combinations of binary operators between the digits so that the overall value of the resulting expression becomes equal to a given target value. Let us look at a few possibilities of what it means exactly to *place the operators between digits* so that the question becomes clearer.\n\nLet's say we are given the following set of digits `\"123456789\"` and the target value given to us is `45`. Let us see some of the possible resulting expressions that we can get by placing the operators in different locations.\n\n<pre>\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45\n</pre>\n\nThese are just 4 of the many resulting expressions that are possible by using the given string of digits and the three operators.\n\nBy looking at the above examples we can't really figure out any specific pattern among the resulting expressions that tells us which of them will give us the resulting target.\n\nSince the question explicitly states that we are given binary operators, this means that each of the operator would require two operands.\n\n> We can consider each of our digits as an operand.\n\nThis means that between every pair of digits we can have any of the three operators i.e. $$+$$, $$-$$ or $$\\times$$.\n\nIf you've looked at the question's statement and the examples that are given in the question, you would realize that there is an example where the digits are `\"105\"` and the target value is `5`. For this particular example, there are two expressions given to us and they are `1*0+5` and `10-5`.\n\nThe second expression is something that you need to look out for before getting to solve this question because this complicates things a bit.\n\nIt would have been an easier question to solve if we just had to consider those expressions that simply had *digits as operands*.\n\nBut, in this question, we can have all sorts of digits getting together and forming a bigger number that becomes a part of the expression. Let us look at some example expressions for the digits `\"123456\"` and target `30`.\n\n<pre>\n1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30\n</pre>\n\nSo this means that although the number of operators are defined for us i.e. 3 different binary operators, but the number of operands are **not really well defined for us**.\n\nThis is a big portion of the original problem that we need to address in our solution.\n\nSince we are asked to find out all of the valid expressions whose value equals the given target and we don't really know what specific operator between two operands would eventually give us a valid expression,\n\n> We try out all of the options.\n\nThis means once we have defined what the operands are for our given expression, we would have three possible choices of operators between each consecutive pair of operands.\n\nFrom an implementation perspective, what would an operand imply with respect to our original string?\n\n> An operand would be an integer formed from a substring of our original string.\n\nLet's look at two different array partitions for the given string `\"123456789\"`\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_1.png\" height=\"300\"></center>\n\nSince we are required to return all of the valid expressions that evaluate to a given target value, we have to try all possible partitions of the given array thereby considering all of the possible operands that can be formed from the digits.\n\nThere is a very simple way of incorporating this into our algorithm. Right now, at every point in the algorithm, we have three different choices corresponding to the three different operators.\n\n>The way we incorporate these partitions is by considering a 4th operator as well which simply moves one step forward and extends the current operand by one digit. Essentially, going from 12 --> 123 is a NO OP operand in our implementation. (12 * 10) + 3.\n\nNow we have 4 different recursion paths in our algorithm and we have to try out all of them to see which ones lead to a potential solution.\n\nThis `try out everything` hints at a backtracking solution and that is exactly what we are going to look at here.\n\n**Algorithm**\n\nLet's quickly look at the steps involved in our backtracking algorithm before looking at the pseudo-code.\n\n1. As discussed above, we have multiple choices of what operators to use and what the operands can be and hence, we have to look at all the possibilities to find ***all*** valid expressions.\n2. Our recursive call will have an `index` which represents the current digit we're looking at in the original `nums` string and also the expression string built till now.\n3. At every step, we have exactly 4 different recursive calls. The `NO OP` call simply extends the `current_operand` by the current digit and moves ahead. Rest of the recursive calls correspond to `+`, `-`, and `*`.\n4. We keep on building our expression like this and eventually, the entire `nums` string would be processed. At that time we check if the expression we built till now is a valid expression or not and we record it if it is a valid one.\n\n<pre>\n1. procedure recurse(digits, index, expression):\n2.     if we have reached the end of the string:\n3.         if the expression evaluates to the target:\n4.             Valid Expression found!\n5.     else:\n6.         try out operator 'NO OP' and recurse\n7.         try out operator * and recurse\n8.         try out operator + and recurse\n9.         try out operator - and recurse\n</pre>\n\nThe algorithm now looks pretty straightforward. However, the implementation is something that needs more thought and there are some things that we need to address before actually looking at the implementation.\n\nWhen we are done building an expression out of all of the digits in our original string i.e. the base case, then we check if the expression is a valid expression or not. Right ?\n\n> How do we actually check if an expression is a valid one or not if all we have is a string representing the expression and not the integer value for the same?\n\nWell, one way to go about this is to write a custom `eval` function that takes in a string and returns the value of that expression. If you do that (Python people can use the inbuilt function `eval` for this), you will get a TLE i.e. time limit exceeded error.\n\n<br/>\n\n**Can't we keep track of the expression's value on the fly?**\n\nWell yes. That's the idea we will go with. Instead of just keeping track of what the expression string is, we will also keep track of it's value along the way so that when the recursion hits the base case, we can check in $$O(1)$$ time if the expression's value equals the target value or not.\n\nThe implementation would have been straightforward had it just been `+` and `-` operators involved. This is because both these operators have an equal precedence. That means that we can continue to evaluate the expression on the fly without any problems. Have a look at the following example.\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_2.png\" width=\"550\"></center>\n\nSo far so good. Now let us add the `*` operator as well and see how building the expression on the fly like this breaks.\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_3.png\" width=\"550\"></center>\n\nWhat we mean by building the expression on the fly is that we keep track of the expression's value till now and we simply consider that value as one of the two operands for our operators. As we can see from the two examples above, this would have worked had it just been `+` and `-` operators.\n\nBut, this approach is bound to fail because the `*` operator takes precedence over `+` and `-`. The `*` operator would require the ***actual*** previous operand in our expression rather than the current value of the expression. i.e. In the above example, the `*` operator needed `2` rather than `12` to get us the correct value of `18`.\n\n<br/>\n\n**How to handle this?**\n\nThe idea on how to handle this problem springs from the discussion above. We simply need to keep track of the last operand in our expression and how it modified the expression's value overall so that when we consider the `*` operator, we can **reverse** the effects of the previous operand and consider it for multiplication. Let's take a look at the example that was breaking before.\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_4.png\" width=\"550\"></center>\n\nNow we can look at the actual implementation of this algorithm.\n\n<iframe src=\"https://leetcode.com/playground/X7CmRa6U/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"X7CmRa6U\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:\n    * At every step along the way, we consider exactly 4 different choices or 4 different recursive paths. The base case is when the value of `index` reaches $$N$$ i.e. the length of the `nums` array. Hence, our complexity would be $$O(4^N)$$.\n    * For the base case we use a `StringBuilder::toString` operation in Java and `.join()` operation in Python and that takes $$O(N)$$ time. Here $$N$$ represents the length of our expression. In the worst case, each digit would be an operand and we would have $$N$$ digits and $$N - 1$$ operators. So $$O(N)$$. This is for one expression. In the worst case, we can have $$O(4^N)$$ valid expressions.\n    * Overall time complexity = $$O(N \\times 4^N)$$.\n\n* Space Complexity:\n    * For both Python and Java implementations we have a list data structure that we update on the fly and only for valid expressions do we create a new string and add to our `answers` array. So, the space occupied by the intermediate list would be $$O(N)$$ since in the worst case the expression would be built out of all the digits as operands.\n    * Additionally, the space used up by the recursion stack would also be $$O(N)$$ since the size of recursion stack is determined by the value of `index` and it goes from $$0$$ all the way to $$N$$.\n    * We don't consider the space occupied by the `answers` array since that is a part of the question's requirement and we can't reduce that in any way\n\n**EDIT:**\nThe previous implementation of the algorithm, although correct, lead me to write an incorrect complexity analysis section. I've re-written the algorithm from scratch and corrected the complexity analysis as well. Sorry for the inconvenience to all the readers. The core idea of the algorithm is still the same. That hasn't changed.\n\nSpecial thanks to [@ufarooqi](https://leetcode.com/ufarooqi/), [@vortexwolf](https://leetcode.com/vortexwolf) for providing correct complexity analysis in the discussion forum leading to corrections in the article. Pardon me if I've missed out on any other names :)\n\n<br />"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/expression-add-operators/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "283",
        "questionFrontendId": "283",
        "title": "Move Zeroes",
        "content": "<p>Given an integer array <code>nums</code>, move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>\n\n<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,3,12]\n<strong>Output:</strong> [1,3,12,0,0]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you minimize the total number of operations done?",
        "likes": 17748,
        "dislikes": 518,
        "stats": "{\"totalAccepted\": \"3.9M\", \"totalSubmission\": \"6.2M\", \"totalAcceptedRaw\": 3914490, \"totalSubmissionRaw\": 6248566, \"acRate\": \"62.6%\"}",
        "similarQuestions": "[{\"title\": \"Remove Element\", \"titleSlug\": \"remove-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Apply Operations to an Array\", \"titleSlug\": \"apply-operations-to-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "<b>In-place</b> means we should not be allocating any space for extra array. But we are allowed to modify the existing array. However, as a first step, try coming up with a solution that makes use of additional space. For this problem as well, first apply the idea discussed using an additional array and the in-place solution will pop up eventually.",
          "A <b>two-pointer</b> approach could be helpful here. The idea would be to have one pointer for iterating the array and another pointer that just works on the non-zero elements of the array."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n\n## Video Solution\n\n---\n <div class='video-preview'></div>\n\n## Solution\n---\n\nThis question comes under a broad category of \"Array Transformation\". This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn't require any boilerplate code and most of your code will look like the Pseudocode itself.\n\nThe 2 requirements of the question are:\n\n1. Move all the 0's to the end of array.\n\n2. All the non-zero elements must retain their original order.\n\nIt's good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.\n\n### Approach #1 (Space Sub-Optimal) [Accepted]\n\nTraverse the `nums` list first to count the number of zeroes. Then traverse the `nums` list again to store all non-zero elements in `ans`.\n\n#### Algorithm:\n\n- Determine the size of the `nums` array and store it in `n`.\n\n- Count the number of zeroes in `nums`:\n  - Initialize `numZeroes` to 0.\n  - Iterate through each element in `nums`:\n    - Increment `numZeroes` for each zero encountered.\n\n- Create a new vector `ans` to store non-zero elements in their original order:\n  - Iterate through each element in `nums`:\n    - Add non-zero elements to `ans`.\n\n- Append all zeroes to the end of the `ans` vector:\n  - Append `numZeroes` zeroes to `ans`.\n\n- Update the original `nums` array with the elements from `ans`:\n  - Copy each element from `ans` back to `nums`.\n\n\n<iframe src=\"https://leetcode.com/playground/ZftizFjx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ZftizFjx\"></iframe>\n\n**Complexity Analysis**\n\nSpace Complexity : $$O(n)$$. Since we are creating the \"ans\" array to store results.\n\nTime Complexity: $$O(n)$$. We traverse the nums list first to count the number of zeroes using $O(n)$ time. Then, we traverse the nums list again to store all non-zero elements in ans which also costs $O(n)$ time. Hence, the overall time complexity is $O(2n)$, which is simplified to $O(n)$. However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations.\n\nIf asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution.\n\n---\n### Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]\n\nThis approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, \" Bring all the non 0 elements to the front of array keeping their relative order same\".\n\nThis is a 2 pointer approach. The fast pointer(`nums[i]`) does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer `lastNonZeroFoundAt` variable. As we keep finding new non-0 elements, we just overwrite them at the `lastNonZeroFoundAt + 1` 'th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it's corresponding index,or if it were 0 it will be handled later in time).\n\nAfter the `nums[i]` reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, \"Move all 0's to the end\". We now simply need to fill all the indexes after the `lastNonZeroFoundAt` index with 0.\n\n#### Algorithm:\n\n- Initialize `lastNonZeroFoundAt` to 0:\n  - This variable tracks the position where the next non-zero element should be placed.\n\n- Iterate through each element in `nums`:\n  - If the current element `nums[i]` is not zero:\n    - Place `nums[i]` at index `lastNonZeroFoundAt`.\n    - Increment `lastNonZeroFoundAt` to move to the next position for future non-zero elements.\n\n- After processing all elements:\n  - Fill the remaining positions in the array (from `lastNonZeroFoundAt` to the end) with zeros.\n\n- This ensures that all non-zero elements are moved to the beginning of the array and all zeros are placed at the end.\n\n\n<iframe src=\"https://leetcode.com/playground/Vbpqu24K/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"Vbpqu24K\"></iframe>\n\n**Complexity Analysis**\n\nSpace Complexity : $$O(1)$$. Only constant space is used.\n\nTime Complexity: $$O(n)$$. We traverse the nums list first to move all non-zero elements to the beginning of array which costs $O(n)$ time. At the worst case when the original array only consists of 0s, we will use $O(n)$ time to fill all remaining elements with 0s. Hence, the overall time complexity is $O(2n)$, which is simplified to $O(n)$. However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is $$n$$ (Total number of elements).\n\n---\n### Approach #3 (Optimal) [Accepted]\n\nThe total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0's $$n-1$$ times, which is not necessary. We could have instead written just once. How?\n.....\nBy only fixing the non-0 element,i.e., 1.\n\nThe optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its' correct position can at best be it's current position or a position earlier. If it's the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than 'cur' index. We fill the current position by 0 right away,so that unlike the previous solution, we don't need to come back here in next iteration.\n\nIn other words, the code will maintain the following invariant:\n\n>1. All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.\n>\n>2. All elements between the current and slow pointer are zeroes.\n\nTherefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it's zero element, we just advance current pointer.\n\nWith this invariant in-place, it's easy to see that the algorithm will work.\n\n#### Algorithm:\n\n- Initialize `lastNonZeroFoundAt` to 0 to track the position of the last non-zero element.\n- Iterate through each element in `nums` using `cur` as the index:\n  - If `nums[cur]` is not zero:\n    - Swap `nums[lastNonZeroFoundAt]` with `nums[cur]` to move the non-zero element to the correct position.\n    - Increment `lastNonZeroFoundAt` to update the position for the next non-zero element.\n\n- Continue iterating until all elements are processed, ensuring all non-zero elements are moved to the front of the array and zeros are pushed to the end.\n\n\n<iframe src=\"https://leetcode.com/playground/4YFvmDiq/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"4YFvmDiq\"></iframe>\n\n**Complexity Analysis**\n\nSpace Complexity : $$O(1)$$. Only constant space is used.\n\nTime Complexity: $$O(n)$$. However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.\n\nAnalysis written by: @spandan.pathak"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/move-zeroes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "284",
        "questionFrontendId": "284",
        "title": "Peeking Iterator",
        "content": "<p>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.</p>\n\n<p>Implement the <code>PeekingIterator</code> class:</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.</li>\n\t<li><code>int next()</code> Returns the next element in the array and moves the pointer to the next element.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.</li>\n\t<li><code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.</li>\n</ul>\n\n<p><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>Explanation</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // return 1, the pointer moves to the next element [1,<u><strong>2</strong></u>,3].\npeekingIterator.peek();    // return 2, the pointer does not move [1,<u><strong>2</strong></u>,3].\npeekingIterator.next();    // return 2, the pointer moves to the next element [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]\npeekingIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All the calls to <code>next</code> and <code>peek</code> are valid.</li>\n\t<li>At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?",
        "likes": 1876,
        "dislikes": 1043,
        "stats": "{\"totalAccepted\": \"235.1K\", \"totalSubmission\": \"388.6K\", \"totalAcceptedRaw\": 235134, \"totalSubmissionRaw\": 388650, \"acRate\": \"60.5%\"}",
        "similarQuestions": "[{\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think of \"looking ahead\". You want to cache the next element.",
          "Is one variable sufficient? Why or why not?",
          "Test your design with call order of <code>peek()</code> before <code>next()</code> vs <code>next()</code> before <code>peek()</code>.",
          "For a clean implementation, check out <a href=\"https://github.com/google/guava/blob/703ef758b8621cfbab16814f01ddcc5324bdea33/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java#L1125\" target=\"_blank\">Google's guava library source code</a>."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Iterator"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/peeking-iterator/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "285",
        "questionFrontendId": "285",
        "title": "Inorder Successor in BST",
        "content": null,
        "likes": 2599,
        "dislikes": 93,
        "stats": "{\"totalAccepted\": \"352.8K\", \"totalSubmission\": \"698K\", \"totalAcceptedRaw\": 352825, \"totalSubmissionRaw\": 697962, \"acRate\": \"50.6%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST II\", \"titleSlug\": \"inorder-successor-in-bst-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/inorder-successor-in-bst/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "286",
        "questionFrontendId": "286",
        "title": "Walls and Gates",
        "content": null,
        "likes": 3229,
        "dislikes": 70,
        "stats": "{\"totalAccepted\": \"373.4K\", \"totalSubmission\": \"595.4K\", \"totalAcceptedRaw\": 373370, \"totalSubmissionRaw\": 595380, \"acRate\": \"62.7%\"}",
        "similarQuestions": "[{\"title\": \"Surrounded Regions\", \"titleSlug\": \"surrounded-regions\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Islands\", \"titleSlug\": \"number-of-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Distance from All Buildings\", \"titleSlug\": \"shortest-distance-from-all-buildings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Battleships in a Board\", \"titleSlug\": \"battleships-in-a-board\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Robot Room Cleaner\", \"titleSlug\": \"robot-room-cleaner\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Rotting Oranges\", \"titleSlug\": \"rotting-oranges\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count the Number of Houses at a Certain Distance I\", \"titleSlug\": \"count-the-number-of-houses-at-a-certain-distance-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count the Number of Houses at a Certain Distance II\", \"titleSlug\": \"count-the-number-of-houses-at-a-certain-distance-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/walls-and-gates/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "287",
        "questionFrontendId": "287",
        "title": "Find the Duplicate Number",
        "content": "<p>Given an array of integers <code>nums</code> containing&nbsp;<code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>\n\n<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this&nbsp;repeated&nbsp;number</em>.</p>\n\n<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code>&nbsp;and using only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,2]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3,3,3,3]\n<strong>Output:</strong> 3</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b></p>\n\n<ul>\n\t<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>\n\t<li>Can you solve the problem in linear runtime complexity?</li>\n</ul>\n",
        "likes": 24151,
        "dislikes": 5148,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.4M\", \"totalAcceptedRaw\": 2095849, \"totalSubmissionRaw\": 3352383, \"acRate\": \"62.5%\"}",
        "similarQuestions": "[{\"title\": \"First Missing Positive\", \"titleSlug\": \"first-missing-positive\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Linked List Cycle II\", \"titleSlug\": \"linked-list-cycle-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Missing Number\", \"titleSlug\": \"missing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Set Mismatch\", \"titleSlug\": \"set-mismatch\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/find-the-duplicate-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "288",
        "questionFrontendId": "288",
        "title": "Unique Word Abbreviation",
        "content": null,
        "likes": 211,
        "dislikes": 1843,
        "stats": "{\"totalAccepted\": \"77K\", \"totalSubmission\": \"285.9K\", \"totalAcceptedRaw\": 77035, \"totalSubmissionRaw\": 285923, \"acRate\": \"26.9%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum III - Data structure design\", \"titleSlug\": \"two-sum-iii-data-structure-design\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Generalized Abbreviation\", \"titleSlug\": \"generalized-abbreviation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Design"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-word-abbreviation/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "289",
        "questionFrontendId": "289",
        "title": "Game of Life",
        "content": "<p>According to <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\">Wikipedia&#39;s article</a>: &quot;The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;</p>\n\n<p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <b>live</b> (represented by a <code>1</code>) or <b>dead</b> (represented by a <code>0</code>). Each cell interacts with its <a href=\"https://en.wikipedia.org/wiki/Moore_neighborhood\" target=\"_blank\">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>\n\n<ol>\n\t<li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li>\n\t<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n\t<li>Any live cell with more than three live neighbors dies, as if by over-population.</li>\n\t<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n\n<p><span>The next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the <code>m x n</code> grid <code>board</code>. In this process, births and deaths occur <strong>simultaneously</strong>.</span></p>\n\n<p><span>Given the current state of the <code>board</code>, <strong>update</strong> the <code>board</code> to reflect its next state.</span></p>\n\n<p><strong>Note</strong> that you do not need to return anything.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" style=\"width: 562px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" style=\"width: 402px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[1,1],[1,0]]\n<strong>Output:</strong> [[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.</li>\n\t<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?</li>\n</ul>\n",
        "likes": 6570,
        "dislikes": 597,
        "stats": "{\"totalAccepted\": \"557K\", \"totalSubmission\": \"783.2K\", \"totalAcceptedRaw\": 557015, \"totalSubmissionRaw\": 783222, \"acRate\": \"71.1%\"}",
        "similarQuestions": "[{\"title\": \"Set Matrix Zeroes\", \"titleSlug\": \"set-matrix-zeroes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/game-of-life/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "290",
        "questionFrontendId": "290",
        "title": "Word Pattern",
        "content": "<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code>&nbsp;follows the same pattern.</p>\n\n<p>Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>s</code>. Specifically:</p>\n\n<ul>\n\t<li>Each letter in <code>pattern</code> maps to <strong>exactly</strong> one unique word in <code>s</code>.</li>\n\t<li>Each unique word in <code>s</code> maps to <strong>exactly</strong> one letter in <code>pattern</code>.</li>\n\t<li>No two letters map to the same word, and no two words map to the same letter.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The bijection can be established as:</p>\n\n<ul>\n\t<li><code>&#39;a&#39;</code> maps to <code>&quot;dog&quot;</code>.</li>\n\t<li><code>&#39;b&#39;</code> maps to <code>&quot;cat&quot;</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code> contains only lower-case English letters.</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> contains only lowercase English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> <strong>does not contain</strong> any leading or trailing spaces.</li>\n\t<li>All the words in <code>s</code> are separated by a <strong>single space</strong>.</li>\n</ul>\n",
        "likes": 7590,
        "dislikes": 1091,
        "stats": "{\"totalAccepted\": \"915.3K\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 915288, \"totalSubmissionRaw\": 2132932, \"acRate\": \"42.9%\"}",
        "similarQuestions": "[{\"title\": \"Isomorphic Strings\", \"titleSlug\": \"isomorphic-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Word Pattern II\", \"titleSlug\": \"word-pattern-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find and Replace Pattern\", \"titleSlug\": \"find-and-replace-pattern\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-pattern/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "291",
        "questionFrontendId": "291",
        "title": "Word Pattern II",
        "content": null,
        "likes": 934,
        "dislikes": 75,
        "stats": "{\"totalAccepted\": \"80.9K\", \"totalSubmission\": \"166.5K\", \"totalAcceptedRaw\": 80888, \"totalSubmissionRaw\": 166527, \"acRate\": \"48.6%\"}",
        "similarQuestions": "[{\"title\": \"Word Pattern\", \"titleSlug\": \"word-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nOur objective is to return `true` if `s` matches the `pattern`.\n\nWe can think of the pattern as a code, where each character in the `pattern` is a symbol that corresponds to a substring of `s`.\n\n> **Input:** pattern = \"abab\", s = \"redblueredblue\"\n\n| Symbol | Value |\n|:------:|:-----:|\n|  `'a'` | \"red\" |\n|  `'b'` | \"blue\"|\n\nIf we can build `s` using the code, then `s` matches the `pattern`.\n\nUnderstanding test cases that fail can help us better understand the problem.\n\n> **Input:** pattern = \"ab\", s = \"aa\"\n> **Output:** false\n\n| Symbol | Value 1 | Value 2 |\n|:------:|:-------:|:-------:|\n|  `'a'` |   \"a\"   |   \"aa\"  |\n|  `'b'` |   \"a\"   |   \"\"    |\n\nNeither of the value columns in the above table are valid mappings because each symbol must be mapped to a **unique non-empty** substring of `s`.\n\nOne challenge of this problem is that we are unsure of the number of characters in `s` that correspond to each symbol in the `pattern`. We may need to explore many possibilities before finding a valid mapping or determining that none exists.\n\n---\n\n### Approach 1: Hash Table and Backtracking\n\n#### Intuition\n\nThe code table in the overview looks like a hash table. We can utilize a hash map to store `(symbol, word)` mappings, where a character from `pattern` is the key and a substring of `s` is the value.\n\nEach symbol must be mapped to a unique `word`, so we will also use a hash set to track the `word` values we have stored already.\n\nThe brute force method of solving the problem is to generate all of the possible mappings and then test each one to see if it is valid. This approach would be inefficient, leading to an exponential time complexity.\n\nHow can we reduce the search space?\n\nLet's say we have created the following mapping for the below example:\n\n> **Input:** pattern = \"abab\", s = \"redblueredblue\"\n\n|  Key  | Value |\n|:-----:|:-----:|\n| `'a'` | \"re\"  |\n| `'b'` | \"db\"  |\n\nWhen we reach the next character, `\"l\"`, in `s`, the current symbol is `'a'`. Since `'a'` maps to `\"re\"` according to our mapping, we expect to see `\"re\"` in `s` at that position. However, we find `\"l\"` instead. This mismatch indicates that our current mapping isn't valid for the entire string `s`, and thus, we do not need to check the rest of the string. \n\nNow, we could abandon the current mapping and start over, or we could backtrack to the last point where the mapping was valid to explore other possibilities.\n\n> If you are not familiar with backtracking, we recommend you read our **[Backtracking Explore Card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/)**.\n\nWe will create a recursive function, `isMatch`, that uses backtracking to determine whether `s` matches the `pattern`. The function uses a pointer, `pIndex` to traverse the `pattern` and a pointer `sIndex` to track the current index of `s`.\n\nThe base case is when we have processed the whole pattern. If we have also processed the entirety of `s`, the `pattern` matches `s`, so we return `true`. Otherwise, there are extra characters of `s`, so we return `false`.\n\nFor the recursive case, we start by saving the current character in the pattern as `symbol`.\n\nIf we have encountered the `symbol` before, we check whether the corresponding `word` matches with the next characters in `s`. If so, we move on to the next character in the `pattern` with a recursive call to `isMatch`.\n\nIf the `symbol` is the first occurrence in `pattern`, we need to generate the possible mappings from `symbol` to different substrings of `s`.\n\n> **Input:** pattern = \"abac\", s = \"aabbaac\"\n\nState: `pIndex = 1` and `sIndex = 2`\n\nThe current `symbol` is `b`, which is its first occurrence. The possible mappings are:\n\n```\ns[2] = \"b\"\ns[2:3] = \"bb\"\ns[2:4] = \"bba\"\ns[2:5] = \"bbaa\"\ns[2:6] = \"bbacc\"\n```\n\nThe possible `word` mappings for the `symbol` are the set of substrings that start at `sIndex` and end anywhere between `sIndex` and the last index of `s`. Let such a substring be termed `newWord`. If we find that we have encountered `newWord` before, we continue with the next iteration because each `symbol` to `word` mapping must be unique. Otherwise, we add `newWord` to the hash map and hash set. Then, we call `isMatch` with the next character in the `pattern`. Finally, we backtrack by removing `newWord` from the hash map and hash set to explore other possible mappings.\n\n#### Algorithm\n\n1. Create a hash map `symbolMap` that maps the key, a character from `pattern`, to the value, a substring of `s`.\n2. Create a hash set `wordSet` that stores the unique substrings of `s` that have been mapped to a `symbol`.\n3. Define a recursive function `isMatch` that takes an index in `s`, `sIndex`, and an index in `pattern`, `pIndex` as parameters. The function determines whether `s` matches a given `pattern`. Pass `s` and `pattern` as parameters to the function if needed because of scoping.\n    - Base case: `pIndex` equals the length of `pattern`. Return `true` if `sIndex` equals the length of `s`; `s` matches the pattern. Otherwise, return `false`.\n    - Set `symbol` to `pattern[pIndex]`, the next character in the pattern.\n    - If `symbol` is associated with a substring of `s`, save the substring as `word`, and check if the next characters in `s` match `word`.\n        - If the characters don't match, return `false`.\n        - If they do match, call `isMatch` for the next character in `pattern`.\n    - Otherwise, `symbol` is a new `pattern` character. Try mapping `symbol` to new substrings of `s`, starting with the substring consisting of `s[sIndex]` and extending until the substring reaches the end of `s`.\n        - Save the current substring as `newWord`.\n        - If `newWord` already exists in `wordSet`, continue.\n        - Otherwise, add `newWord` to `wordSet` and to `symbolMap` with the `symbol`.\n        - Call `isMatch` for the next character in `pattern`. If the result is `true`, return `true`.\n        - Remove `newWord` from the `wordSet` and the `symbolMap`.\n4. Call `isMatch` with `sIndex` and `pIndex` as `0` and return the result. \n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/3cwrhJfB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"3cwrhJfB\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `s` and $p$ be the length of `pattern`.\n\n* Time complexity: $O(p \\cdot n^3)$\n\n    The `isMatch` function is called for each character in `pattern` for each `word` that can be formed from substrings of `s`.\n\n    Looking up a `symbol` in the hash map or `word` in the hash set takes $O(1)$ in the average case.\n\n    We generate $n$ substrings of length $1$, $n - 1$ substrings of length $2$, $n - 2$ substrings of length $3$, and so on. We can represent the number of substrings mathematically as $n + (n - 1) + (n - 2) + \\dots + (n - (n - 1))$. This sum can be calculated by the formula $\\frac{n(n + 1)}{2}$, which is a quadratic complexity, $O(n^2)$.\n\n    The function will be called $p \\cdot \\frac{n(n + 1)}{2}$ times. Splicing each substring takes $O(n)$ time, so the overall time complexity is $O(p \\cdot n^3)$.\n\n\n* Space complexity: $O(p + n)$\n\n    `symbolMap` can store a `(symbol, word)` mapping for each unique `symbol` in `pattern`. The set of symbols is the English alphabet, which contains $26$ letters. The length of the substrings of `s` combined is $n$, so it can use up to $O(26 + n)$ space, which can be simplified to $O(n)$.\n\n    `wordSet` stores a `word` for each unique `symbol` in the `symbolMap`. It will use the same amount of space as `symbolMap`, $O(n)$.\n\n    > Note: The number of letters in the alphabet is considered constant, but for this problem, it is not trivial because $p$ and $n$ are constrained to $20$. For inputs where $p < 26$, when every character of `pattern` is unique, we can represent the space required by the hash map and hash set as $O(p + n)$.\n\n    We recursively check each character in `pattern`, so the depth of the recursive call stack can grow up to $p$, requiring $O(p)$ space.\n\n    Therefore, the overall space complexity is $O(p + 2n)$, which we can simplify to $O(p + n)$\n\n---\n\n### Approach 2: Optimized Backtracking\n\n#### Intuition\n\nAn alternative to using a map is an array, which provides constant time complexity for both insertion and retrieval operations. This is faster than the worst-case time complexity of hashmap operations. However, this advantage comes with a trade-off: arrays are only suitable when the range of values is relatively small and can be mapped directly to array indices. Since the set of symbols are the letters in the English alphabet, we can utilize an array.\n\nAssuming that `s` matches the `pattern`, then there are the same number of substrings in `s` as there are characters in `pattern`. We can leverage this observation to further narrow the search space.\n\nThe above approach assumes that for any character `symbol` of the `pattern`, the possible set of corresponding substrings includes all substrings that start with `sIndex` and stop at any point until the end of `s`. We can reason that if the `symbol` is not the last character in the `pattern`, then the corresponding substring must end before the last index of `s` because the remaining characters in the `pattern` also need to be mapped to substrings of `s`.\n\nThe basic idea of this optimization is to peek ahead and check if the `pattern` has additional characters. If so, we count how many characters at the end of `s` the remaining characters in `pattern` must use, and we only explore the new possible substrings for the `symbol` that leave room in `s` for the remaining characters in `pattern`.\n\nThe following example demonstrates this idea.\n\n> **Input:** pattern = \"abac\", s = \"aabbaac\"\n\nState: `pIndex = 1` and `sIndex = 2`\n\n`symbols`:\n| Index  |   0  | 1 | 2 | ... | 25|\n|:------:|:----:|:-:|:-:|:---:|:-:|\n| Letter |  'a' |'b'|'c'| ... |'z'|\n|  Word  | \"aa\" |\"\" |\"\" | ... |\"\" |\n\nThe second character of the `pattern`, `'b'`, is a new `symbol`. How many indices at the end of `s` will be used by the remaining characters in the `pattern`?\n\n- `'a'` is the next symbol in the `pattern`. It maps to `\"aa\"`, so it will take `2` spots.\n- `'c'` is the last symbol in the `pattern`. We don't know what `word` it maps to, but it will require at least `1` spot.\n\nThere are `5` more indices left in `s` total and the remaining characters in `pattern` will fill at least `1 + 2 = 3` spots. `5 - 3 = 2` is the maximum length of the new word.\n\nSo, the `word` substrings we test for symbol `'b'` are:\n\n```\ns[2] = \"b\"\ns[2:3] = \"bb\"\n```\n\nWe can visualize `s` as `\"aa_aax\"`, where `\"aa\"` represents the known mapping of `'a'`, `x` represents a spot for the unknown mapping of `'c'`, and the empty space represents the `word` that corresponds to symbol `'b'`.\n\nWhen we encounter a new `symbol`, before generating the new words, we count how many indices of `s` must be filled by the remaining characters in the `pattern`, which we store in `filledSpots`.\n\nWe compute `filledSpots` by iterating through the symbols from the next to the last index of `pattern` and adding the length of the corresponding `word` for each of the characters remaining in `pattern`. If the symbol is new, we add `1`, because the `word` will consist of at least one index of `s`.\n\nThen, we can identify the last possible ending index in `s` of a new word that could correspond to a given `symbol` as `s.length() - filledSpots`, which we use to narrow the search space when we generate new words.\n\n#### Algorithm\n\n1. Create an array `symbols` of size `26` that maps a character from `pattern` to a substring of `s`. Each index corresponds to a letter of the alphabet.\n2. Create a hash set `wordSet` that stores the unique substrings of `s` that have been mapped to a symbol.\n3. Define a recursive function `isMatch` that takes an index in `s`, `sIndex`, and an index in `pattern`, `pIndex` as parameters. The function determines whether `s` matches a given `pattern`.\n    - Base case: `pIndex` equals the length of `pattern`. Return `true` if `sIndex` equals the length of `s`; `s` matches the pattern. Otherwise, return `false`.\n    - Set `symbol` to `pattern[pIndex]`, the next character in `pattern`.\n    - If `symbol` is associated with a substring of `s`, save the substring as `word`, and check if the next characters in `s` match `word`.\n        - If the characters don't match, return `false`.\n        - If they do match, call `isMatch` for the next character in `pattern`.\n    - Otherwise, `symbol` is a new `pattern` character. Find the last possible end index in `s` of a new word that could correspond to `sybmol`.\n      - Set a variable `filledSpots` to `0`.\n      - Iterate from `pIndex + 1` to the last character of `pattern`. If the symbol `p` is associated with a `word`, add the length of the `word` to `filledSpots`. Otherwise, add `1` to `filledSpots`.\n    - Try mapping `symbol` to new substrings of `s`, starting with the substring consisting of `s[sIndex]` and extending until the substring reaches the last possible end index of the new word, which is `s.length() - filledSpots`.\n        - Save the current substring as `newWord`.\n        - If `newWord` already exists in `wordSet`, continue.\n        - Otherwise, add `newWord` to `wordSet` and `symbols` with `symbol`.\n        - Call `isMatch` for the next character in `pattern`. If the result is `true`, return `true`.\n        - Remove `newWord` from the `wordSet` and the `symbols` array.\n4. Call `isMatch` with the starting indices in `s` and the `pattern` as `0` and return the result.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/m6EfZMET/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"m6EfZMET\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `s` and $p$ be the length of `pattern`.\n\n* Time complexity: $O(p \\cdot n \\cdot (n - p)^2)$\n\n    The `isMatch` function is called for each character in `pattern` for each `word` that can be formed from substrings of `s`.\n    \n    We only generate substrings that leave space for the rest of the characters in `pattern`. We generate $(n - p + 1) + 1$ substrings of length $1$, $(n - p + 1)$ substrings of length $2$, $(n - p + 1) - 1$ substrings of length $3$, and so on. We can calculate the number of substrings we generate as $\\frac{(n - p + 1)((n - p + 1) + 1)}{2} + (n - p + 1)$, which has a quadratic complexity of $O((n - p)^2)$.\n\n    The `isMatch` function will be called $p \\cdot (n - p)^2$ times. Splicing each substring takes $O(n)$, so the overall time complexity is $O(p \\cdot n \\cdot (n - p)^2)$.\n\n\n* Space complexity: $O(p + n)$\n\n    The `symbols` array can store a substring for each letter in the English alphabet. It stores up to $26$ substrings with a combined length of $n$, so it requires $O(26 + n)$ space, which can be simplified to $O(n)$.\n\n    The `wordSet` can store a `word` for each unique symbol in `pattern`. The combined length of the substrings is $n$, so it can use up to $O(26 + n)$ space, which is simplified to $O(n)$.\n\n    > Note: The number of letters in the alphabet is considered constant, but for this problem, it is not trivial because $p$ and $n$ are constrained to $20$. For inputs where $p < 26$, when every character of `pattern` is unique, we can represent the space required by the hash set as $O(p + n)$.\n\n    We recursively check each character in the `pattern` so the depth of the recursive call stack can grow up to $p$, requiring $O(p)$ space.\n\n    Therefore, the overall space complexity is $O(p + 2n)$, which we can simplify to $O(p + n)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-pattern-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "292",
        "questionFrontendId": "292",
        "title": "Nim Game",
        "content": "<p>You are playing the following Nim Game with your friend:</p>\n\n<ul>\n\t<li>Initially, there is a heap of stones on the table.</li>\n\t<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>\n\t<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>\n\t<li>The one who removes the last stone is the winner.</li>\n</ul>\n\n<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code><em> if you can win the game assuming both you and your friend play optimally, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> false\n<strong>Explanation:</strong> These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 1822,
        "dislikes": 2718,
        "stats": "{\"totalAccepted\": \"441.5K\", \"totalSubmission\": \"762.1K\", \"totalAcceptedRaw\": 441487, \"totalSubmissionRaw\": 762117, \"acRate\": \"57.9%\"}",
        "similarQuestions": "[{\"title\": \"Flip Game II\", \"titleSlug\": \"flip-game-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?"
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Brainteaser"
          },
          {
            "name": "Game Theory"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/nim-game/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "293",
        "questionFrontendId": "293",
        "title": "Flip Game",
        "content": null,
        "likes": 230,
        "dislikes": 472,
        "stats": "{\"totalAccepted\": \"76.6K\", \"totalSubmission\": \"118.1K\", \"totalAcceptedRaw\": 76612, \"totalSubmissionRaw\": 118116, \"acRate\": \"64.9%\"}",
        "similarQuestions": "[{\"title\": \"Flip Game II\", \"titleSlug\": \"flip-game-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n\n### Approach: Linear Iteration\n\n#### Intuition  \n\n> **Note:** This problem evaluates your understanding and handiness in working with string data structures and performing operations like sub-string and concatenation.\n\nGiven the `currentState` string consisting of `'+'` and `'-'`, we must return all possible next states after making one move.    \nIn one move we can only change one `'++'` to `'--'`. All other combinations `'--'`, `'+-'`, or `'-+'` can't be changed.\n\nThe naive approach would be to find all `'++'` in the `currentState` string and change them to `'--'` one at a time.     \nFor this, we can iterate over the whole `currentState` string from the `0`th index to the end and check every two adjacent characters. If both characters are `'+'`, they can be replaced with `'-'` and stored in the `nextPossibleStates` array.\n\n\n![image](../Figures/293/Slide1.jpg)\n\n\n\n#### Algorithm\n\n1. Create an empty array `nextPossibleStates` to store all possible next states after making one move.\n\n2. Start a loop from `index = 0` up to `currentState.size() - 1`. For each `index`:\n    - If the character at `index` and `index + 1` are both `'+'`: \n        - Create a new string `nextState` by replacing the two adjacent `'+'` characters with `'--'`.    \n        - Use string concatenation to construct `nextState` from the substring before the first `'+'`, `\"--\"`, and the substring after the second `'+'` till the end.\n        - Store the generated `nextState` in the `nextPossibleStates` array.\n\n3. After the loop, return the `nextPossibleStates` array containing all the possible next states.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/LQpK3Mpz/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"LQpK3Mpz\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $n$ be the length of the `currentState` string.\n\n* Time complexity:  $O(n^2)$\n    - We iterate over all $n - 1$ indices of the `currentState` string, and for each index, we may create the next state string, which takes $O(n)$ time. Thus, for all indices, this approach will take $O(n^2)$ time.\n* Space complexity: $O(1)$\n    - We declare a few variables, which use constant space. We also declare the output array `nextPossibleStates`, but because this is only used for storing the output, it does not count towards the space complexity. Therefore, the space complexity is $O(1)$.\n\n> **Note:** We generally don't consider input and output space usages during space complexity analysis."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/flip-game/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "294",
        "questionFrontendId": "294",
        "title": "Flip Game II",
        "content": null,
        "likes": 624,
        "dislikes": 66,
        "stats": "{\"totalAccepted\": \"73.5K\", \"totalSubmission\": \"140.9K\", \"totalAcceptedRaw\": 73533, \"totalSubmissionRaw\": 140853, \"acRate\": \"52.2%\"}",
        "similarQuestions": "[{\"title\": \"Nim Game\", \"titleSlug\": \"nim-game\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Flip Game\", \"titleSlug\": \"flip-game\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Guess Number Higher or Lower II\", \"titleSlug\": \"guess-number-higher-or-lower-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Can I Win\", \"titleSlug\": \"can-i-win\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Memoization"
          },
          {
            "name": "Game Theory"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/flip-game-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "295",
        "questionFrontendId": "295",
        "title": "Find Median from Data Stream",
        "content": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li>\n\t<li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>Implement the MedianFinder class:</p>\n\n<ul>\n\t<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>\n\t<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>\n\t<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]\n[[], [1], [2], [], [3], []]\n<strong>Output</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>Explanation</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup> &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n\t<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n</ul>\n",
        "likes": 12452,
        "dislikes": 263,
        "stats": "{\"totalAccepted\": \"975.4K\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 975378, \"totalSubmissionRaw\": 1835892, \"acRate\": \"53.1%\"}",
        "similarQuestions": "[{\"title\": \"Sliding Window Median\", \"titleSlug\": \"sliding-window-median\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Finding MK Average\", \"titleSlug\": \"finding-mk-average\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sequentially Ordinal Rank Tracker\", \"titleSlug\": \"sequentially-ordinal-rank-tracker\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Make Median of Array Equal to K\", \"titleSlug\": \"minimum-operations-to-make-median-of-array-equal-to-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Make Subarray Elements Equal\", \"titleSlug\": \"minimum-operations-to-make-subarray-elements-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Make Elements Within K Subarrays Equal\", \"titleSlug\": \"minimum-operations-to-make-elements-within-k-subarrays-equal\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "Design"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Data Stream"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/find-median-from-data-stream/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "296",
        "questionFrontendId": "296",
        "title": "Best Meeting Point",
        "content": null,
        "likes": 1199,
        "dislikes": 107,
        "stats": "{\"totalAccepted\": \"91.6K\", \"totalSubmission\": \"149.6K\", \"totalAcceptedRaw\": 91573, \"totalSubmissionRaw\": 149584, \"acRate\": \"61.2%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Distance from All Buildings\", \"titleSlug\": \"shortest-distance-from-all-buildings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Moves to Equal Array Elements II\", \"titleSlug\": \"minimum-moves-to-equal-array-elements-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Try to solve it in one dimension first. How can this solution apply to the two dimension case?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/best-meeting-point/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "297",
        "questionFrontendId": "297",
        "title": "Serialize and Deserialize Binary Tree",
        "content": "<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n<p><strong>Clarification:</strong> The input/output format is the same as <a href=\"https://support.leetcode.com/hc/en-us/articles/32442719377939-How-to-create-test-cases-on-LeetCode#h_01J5EGREAW3NAEJ14XC07GRW1A\" target=\"_blank\">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,null,4,5]\n<strong>Output:</strong> [1,2,3,null,null,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "likes": 10559,
        "dislikes": 405,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1009022, \"totalSubmissionRaw\": 1723092, \"acRate\": \"58.6%\"}",
        "similarQuestions": "[{\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Serialize and Deserialize BST\", \"titleSlug\": \"serialize-and-deserialize-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Duplicate Subtrees\", \"titleSlug\": \"find-duplicate-subtrees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Serialize and Deserialize N-ary Tree\", \"titleSlug\": \"serialize-and-deserialize-n-ary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Design"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "298",
        "questionFrontendId": "298",
        "title": "Binary Tree Longest Consecutive Sequence",
        "content": null,
        "likes": 1156,
        "dislikes": 238,
        "stats": "{\"totalAccepted\": \"155.1K\", \"totalSubmission\": \"287.1K\", \"totalAcceptedRaw\": 155125, \"totalSubmissionRaw\": 287071, \"acRate\": \"54.0%\"}",
        "similarQuestions": "[{\"title\": \"Longest Consecutive Sequence\", \"titleSlug\": \"longest-consecutive-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Longest Consecutive Sequence II\", \"titleSlug\": \"binary-tree-longest-consecutive-sequence-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check if an Array Is Consecutive\", \"titleSlug\": \"check-if-an-array-is-consecutive\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "299",
        "questionFrontendId": "299",
        "title": "Bulls and Cows",
        "content": "<p>You are playing the <strong><a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a></strong> game with your friend.</p>\n\n<p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p>\n\n<ul>\n\t<li>The number of &quot;bulls&quot;, which are digits in the guess that are in the correct position.</li>\n\t<li>The number of &quot;cows&quot;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li>\n</ul>\n\n<p>Given the secret number <code>secret</code> and your friend&#39;s guess <code>guess</code>, return <em>the hint for your friend&#39;s guess</em>.</p>\n\n<p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;\n<strong>Output:</strong> &quot;1A3B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1807&quot;\n  |\n&quot;<u>7</u>8<u>10</u>&quot;</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;\n<strong>Output:</strong> &quot;1A1B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1123&quot;        &quot;1123&quot;\n  |      or     |\n&quot;01<u>1</u>1&quot;        &quot;011<u>1</u>&quot;\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> and <code>guess</code> consist of digits only.</li>\n</ul>\n",
        "likes": 2529,
        "dislikes": 1796,
        "stats": "{\"totalAccepted\": \"405.4K\", \"totalSubmission\": \"792K\", \"totalAcceptedRaw\": 405424, \"totalSubmissionRaw\": 792013, \"acRate\": \"51.2%\"}",
        "similarQuestions": "[{\"title\": \"Make Number of Distinct Characters Equal\", \"titleSlug\": \"make-number-of-distinct-characters-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Counting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/bulls-and-cows/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "300",
        "questionFrontendId": "300",
        "title": "Longest Increasing Subsequence",
        "content": "<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword=\"subsequence-array\"><em><strong>subsequence</strong></em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0,3,2,3]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7,7,7,7]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b>&nbsp;Can you come up with an algorithm that runs in&nbsp;<code>O(n log(n))</code> time complexity?</p>\n",
        "likes": 21673,
        "dislikes": 475,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 2103474, \"totalSubmissionRaw\": 3664543, \"acRate\": \"57.4%\"}",
        "similarQuestions": "[{\"title\": \"Increasing Triplet Subsequence\", \"titleSlug\": \"increasing-triplet-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Russian Doll Envelopes\", \"titleSlug\": \"russian-doll-envelopes\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Length of Pair Chain\", \"titleSlug\": \"maximum-length-of-pair-chain\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Longest Increasing Subsequence\", \"titleSlug\": \"number-of-longest-increasing-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum ASCII Delete Sum for Two Strings\", \"titleSlug\": \"minimum-ascii-delete-sum-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Removals to Make Mountain Array\", \"titleSlug\": \"minimum-number-of-removals-to-make-mountain-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Longest Valid Obstacle Course at Each Position\", \"titleSlug\": \"find-the-longest-valid-obstacle-course-at-each-position\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Make the Array K-Increasing\", \"titleSlug\": \"minimum-operations-to-make-the-array-k-increasing\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Ideal Subsequence\", \"titleSlug\": \"longest-ideal-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Books You Can Take\", \"titleSlug\": \"maximum-number-of-books-you-can-take\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Increasing Subsequence II\", \"titleSlug\": \"longest-increasing-subsequence-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Maximum Length of a Good Subsequence II\", \"titleSlug\": \"find-the-maximum-length-of-a-good-subsequence-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Maximum Length of a Good Subsequence I\", \"titleSlug\": \"find-the-maximum-length-of-a-good-subsequence-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Maximum Length of Valid Subsequence I\", \"titleSlug\": \"find-the-maximum-length-of-valid-subsequence-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Maximum Length of Valid Subsequence II\", \"titleSlug\": \"find-the-maximum-length-of-valid-subsequence-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Subsequence With Decreasing Adjacent Difference\", \"titleSlug\": \"longest-subsequence-with-decreasing-adjacent-difference\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/longest-increasing-subsequence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "301",
        "questionFrontendId": "301",
        "title": "Remove Invalid Parentheses",
        "content": "<p>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.</p>\n\n<p>Return <em>a list of <strong>unique strings</strong> that are valid with the minimum number of removals</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()())()&quot;\n<strong>Output:</strong> [&quot;(())()&quot;,&quot;()()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(a)())()&quot;\n<strong>Output:</strong> [&quot;(a())()&quot;,&quot;(a)()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)(&quot;\n<strong>Output:</strong> [&quot;&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 25</code></li>\n\t<li><code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>\n\t<li>There will be at most <code>20</code> parentheses in <code>s</code>.</li>\n</ul>\n",
        "likes": 5960,
        "dislikes": 296,
        "stats": "{\"totalAccepted\": \"468.4K\", \"totalSubmission\": \"955.6K\", \"totalAcceptedRaw\": 468397, \"totalSubmissionRaw\": 955650, \"acRate\": \"49.0%\"}",
        "similarQuestions": "[{\"title\": \"Valid Parentheses\", \"titleSlug\": \"valid-parentheses\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Swaps to Make the String Balanced\", \"titleSlug\": \"minimum-number-of-swaps-to-make-the-string-balanced\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Since we do not know which brackets can be removed, we try all the options! We can use recursion.",
          "In the recursion, for each bracket, we can either use it or remove it.",
          "Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.",
          "We can count the number of invalid brackets to be deleted and only generate the valid strings in the recusrion."
        ],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Breadth-First Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n---\n### Approach 1: Backtracking\n\n**Intuition**\n\nFor this question, we are given an expression consisting of parentheses and there can be some misplaced or extra brackets in the expression that cause it to be invalid. An expression consisting of parentheses is considered valid only when every closing bracket has a corresponding opening bracket and vice versa.\n\nThis means if we start looking at each of the bracket from left to right, as soon as we encounter a closing bracket, there should be an unmatched opening bracket available to match it. Otherwise the expression would become invalid. The expression can also become invalid if the number of opening parentheses i.e. `(` are more than the number of closing parentheses i.e. `)`.\n\nLet us look at an invalid expression and all the possible valid expressions that can be formed from it by removing some of the brackets. There is no restriction on which parentheses we can remove. We simply have to make the expression valid.\n\n> The only condition is that we should be removing the minimum number of brackets to make an invalid expression, valid. If this condition was not present, we could potentially remove most of the brackets and come down to say 2 brackets in the end which form `()` and that would be a valid expression.\n\n<center>\n<img src=\"../Figures/301/Diag_1.png\" width=\"800\"></center>\n\nAn important thing to observe in the above diagram is that there are multiple ways of reaching the same solution i.e. say the optimal number of parentheses to be removed to make the original expression valid is K. We can remove multiple different sets of K brackets that will eventually give us the same final expression. But, each valid expression should be recorded only once. We have to take care of this in our solution. Note that there are other possible ways of reaching one of the two valid expressions shown above. We have simply shown 3 ways each for the two valid expressions.\n\nComing back to our problem, the question that now arises is, how to decide which of the parentheses to remove?\n\n> Since we don't know which of the brackets can possibly be removed, we try out all the options!\n\nFor every bracket we have two choices:\n\n* Either it can be considered a part of the final expression OR\n* It can be ignored i.e. we can delete it from our final expression.\n\nSuch kind of problems where we have multiple options and we have no strategy or metric of deciding greedily which option to take, we try out all of the options and see which ones lead to an answer. These type of problems are perfect candidates for the programming paradigm, `Recursion`.\n\n**Algorithm**\n\n1. Initialize an array that will store all of our valid expressions finally.\n2. Start with the leftmost bracket in the given sequence and proceed right in the recursion.\n3. The state of recursion is defined by the index which we are currently processing in the original expression. Let this index be represented by the character `i`. Also, we have two different variables `left_count` and `right_count` that represent the number of left and right parentheses we have added to our expression till now. These are the parentheses that were considered.\n4. If the current character i.e. `S[i]` (considering S is the expression string) is neither a closing or an opening parenthesis, then we simply add this character to our final solution string for the current recursion.\n5. However, if the current character is either of the two brackets i.e. `S[i] == '(' or S[i] == ')'`, then we have two options. We can either discard this character by marking it an invalid character or we can consider this bracket to be a part of the final expression.\n6. When all of the parentheses in the original expression have been processed, we simply check if the expression represented by `expr` i.e. the expression formed till now is valid one or not. The way we check if the final expression is valid or not is by looking at the values in `left_count` and `right_count`. For an expression to be valid `left_count == right_count`. If it is indeed valid, then it could be one of our possible solutions.\n    * Even though we have a valid expression, we also need to keep track of the number of removals we did to get this expression. This is done by another variable passed in recursion called `rem_count`.\n    * Once recursion finishes we check if the current value of `rem_count` is < the least number of steps we took to form a valid expression till now i.e. the global minima. If this is not the case, we don't record the new expression, else we record it.\n\nOne small optimization that we can do from an implementation perspective is introducing some sort of pruning in our algorithm. Right now we simply go till the very end i.e. process all of the parentheses and when we are done processing all of them, we check if the expression we have can be considered or not.\n\nWe have to wait till the very end to decide if the expression formed in recursion is a valid expression or not. Is there a way for us to cutoff from some of the recursion paths early on because they wouldn't lead to a solution? The answer to this is Yes! The optimization is based on the following idea.\n\nFor a left bracket encountered during recursion, if we decide to consider it, then it may or may not lead to an invalid final expression. It may lead to an invalid expression eventually if there are no matching closing bracket available afterwards. But, we don't know for sure if this will happen or not.\n\n> However, for a closing bracket, if we decide to keep it as a part of our final expression (remember for every bracket we have two options, either to keep it or to remove it and recurse further) and there is no corresponding opening bracket to match it in the expression till now, then it will definitely lead to an invalid expression no matter what we do afterwards.\n\ne.g.\n\n<pre>\n( (  ) ) )\n</pre>\n\nIn this case the third closing bracket will make the expression invalid. No matter what comes afterwards, this will give us an invalid expression and if such a thing happens, we shouldn't recurse further and simply prune the recursion tree.\n\nThat is why, in addition to having the index in the original string/expression which we are currently processing and the expression string formed till now, we also keep track of the number of left and right parentheses. Whenever we keep a left parenthesis in the expression, we increment its counter. For a right parenthesis, we check if `right_count < left_count`. If this is the case then only we consider that right parenthesis and recurse further. Otherwise we don't as we know it will make the expression invalid. This simple optimization saves a lot of runtime.\n\nNow, let us look at the implementation for this algorithm.\n\n<iframe src=\"https://leetcode.com/playground/ZNSLoChx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ZNSLoChx\"></iframe>\n\n**Complexity analysis**\n\n* Time Complexity : $$O(2^N)$$ since in the worst case we will have only left parentheses in the expression and for every bracket we will have two options i.e. whether to remove it or consider it. Considering that the expression has $$N$$ parentheses, the time complexity will be $$O(2^N)$$.\n* Space Complexity : $$O(N)$$ because we are resorting to a recursive solution and for a recursive solution there is always stack space used as internal function states are saved onto a stack during recursion. The maximum depth of recursion decides the stack space used. Since we process one character at a time and the base case for the recursion is when we have processed all of the characters of the expression string, the size of the stack would be $$O(N)$$. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.\n<br />\n<br />\n\n---\n\n### Approach 2: Limited Backtracking!\n\nAlthough the previous solution does get accepted on the platform, it is a very inefficient solution because we try removing each and every possible parentheses from the expression and in the end we check two things:\n\n1. if the expression is valid or not\n2. if the total number of removed parentheses removed in the current recursion is less than the global minimum till now or not.\n\nWe cannot determine which of the parentheses are misplaced because, as the problem statement puts across, we can remove multiple combinations of parentheses and end up with a valid expression. This means there can be multiple valid expressions from a single invalid expression and we have to find all of them.\n\n> The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed.\n\nWhat if we could determine this count?\n\nWhat if in addition to determining this count of characters to be removed, we could also determine the number of left parentheses and number of right parentheses to be removed from the original expression to get **any** valid expression?\n\nThis would cut down the computations immensely and the runtime would plummet as a result. The reason for this is, if we knew how many left and right parentheses are to be removed from the original expression to get a valid expression, we would cut down on so many unwanted recursive calls.\n\nImagine the original expression to be 1000 characters with only 3 misplaced `(` parentheses and 2 misplaced `)` parentheses. In our previous solution we would end up trying to remove each one of left and right parentheses and try to reach a valid expression in the end whereas we should only be trying out removing 3 `(` brackets and 2 `)` brackets.\n\n> This is the exact number of `(` and `)` that have to be removed to get a valid expression. No more, no less.\n\nLet us look at how we can find out the number of misplaced left and right parentheses in a given expression first and then we will slightly modify our original algorithm to incorporate these counts as well.\n\n1. We process the expression one bracket at a time starting from the left.\n2. Suppose we encounter an opening bracket i.e. `(`, it may or may not lead to an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of left parentheses till now. `left += 1`\n3. If we encounter a closing bracket, this has two meanings:\n    * Either there was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when `left == 0` i.e. when there are no unmatched left brackets available. In such a case we increment another counter say `right += 1` to represent misplaced right parentheses.\n    * Or, we had some unmatched opening bracket available to match this closing bracket. This is the case when `left > 0`. In this case we simply decrement the left counter we had i.e. `left -= 1`\n4. Continue processing the string until all parentheses have been processed.\n5. In the end the values of `left` and `right` would tell us the number of unmatched `(` and `)` parentheses respectively.\n\nNow that we have these two values available that tell us the total number of left i.e. `(` and right i.e. `)` parentheses that have to be removed to make the invalid expression valid, we will modify our original algorithm discussed in the previous session to avoid unwanted recursions.\n\n**Algorithm**\n\nThe overall algorithm remains exactly the same as before. The changes that we will incorporate are listed below:\n\n* The state of the recursion is now defined by five different variables:\n    1. `index` which represents the current character that we have to process in the original string.\n    2. `left_count` which represents the number of left parentheses that have been added to the expression we are building.\n    3. `right_count` which represents the number of right parentheses that have been added to the expression we are building.\n    4. `left_rem` is the number of left parentheses that remain to be removed.\n    5. `right_rem` represents the number of right parentheses that remain to be removed. Overall, for the final expression to be valid, `left_rem == 0` and `right_rem == 0`.\n* When we decide to not consider a parenthesis i.e. delete a parenthesis, be it a left or a right parentheses, we have to consider their corresponding remaining counts as well. This means that we can only discard a left parentheses if `left_rem > 0` and similarly for the right one we will check for `right_rem > 0`.\n* There are no changes to checks for **considering** a parenthesis. Only the conditions change for **discarding** a parenthesis.\n* Condition for an expression being valid in the base case would now become `left_rem == 0 and right_rem == 0`. Note that we don't have to check if `left_count == right_count` anymore because in the case of a valid expression, we would have removed all the misplaced or invalid parenthesis by the time the recursion ends. So, the only check we need if `left_rem == 0 and right_rem == 0`.\n\n> The most important thing here is that we have completely gotten rid of checking if the number of parentheses removed is lesser than the current minimum or not. The reason for this is we always remove the same number of parentheses as defined by `left_rem + right_rem` at the start of recursion.\n\nNow let us look at the implementation for this modified version of algorithm.\n\n<iframe src=\"https://leetcode.com/playground/bjCaADnt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bjCaADnt\"></iframe>\n\n**Complexity analysis**\n\n* Time Complexity : The optimization that we have performed is simply a better form of pruning. Pruning here is something that will vary from one test case to another. In the worst case, we can have something like `(((((((((` and the `left_rem = len(S)` and in such a case we can discard all of the characters because all are misplaced. So, in the worst case we **still** have 2 options per parenthesis and that gives us a complexity of $$O(2^N)$$.\n* Space Complexity : The space complexity remains the same i.e. $$O(N)$$ as previous solution. We have to go to a maximum recursion depth of $$N$$ before hitting the base case. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.\n\n<br />\n<br />"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-invalid-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "302",
        "questionFrontendId": "302",
        "title": "Smallest Rectangle Enclosing Black Pixels",
        "content": null,
        "likes": 536,
        "dislikes": 102,
        "stats": "{\"totalAccepted\": \"52.1K\", \"totalSubmission\": \"87.6K\", \"totalAcceptedRaw\": 52123, \"totalSubmissionRaw\": 87609, \"acRate\": \"59.5%\"}",
        "similarQuestions": "[{\"title\": \"Find the Minimum Area to Cover All Ones II\", \"titleSlug\": \"find-the-minimum-area-to-cover-all-ones-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Minimum Area to Cover All Ones I\", \"titleSlug\": \"find-the-minimum-area-to-cover-all-ones-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "303",
        "questionFrontendId": "303",
        "title": "Range Sum Query - Immutable",
        "content": "<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>\n\n<ol>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>\n</ol>\n\n<p>Implement the <code>NumArray</code> class:</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n<strong>Output</strong>\n[null, 1, -1, -3]\n\n<strong>Explanation</strong>\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRange</code>.</li>\n</ul>\n",
        "likes": 3456,
        "dislikes": 1955,
        "stats": "{\"totalAccepted\": \"684.8K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 684805, \"totalSubmissionRaw\": 1010826, \"acRate\": \"67.7%\"}",
        "similarQuestions": "[{\"title\": \"Range Sum Query 2D - Immutable\", \"titleSlug\": \"range-sum-query-2d-immutable\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query - Mutable\", \"titleSlug\": \"range-sum-query-mutable\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Size Subarray Sum Equals k\", \"titleSlug\": \"maximum-size-subarray-sum-equals-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sum of Variable Length Subarrays\", \"titleSlug\": \"sum-of-variable-length-subarrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Prefix Sum"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/range-sum-query-immutable/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "304",
        "questionFrontendId": "304",
        "title": "Range Sum Query 2D - Immutable",
        "content": "<p>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:</p>\n\n<ul>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>\n</ul>\n\n<p>Implement the <code>NumMatrix</code> class:</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>\n</ul>\n\n<p>You must design an algorithm where <code>sumRegion</code> works on <code>O(1)</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg\" style=\"width: 415px; height: 415px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;NumMatrix&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;]\n[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\n<strong>Output</strong>\n[null, 8, 11, 12]\n\n<strong>Explanation</strong>\nNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRegion</code>.</li>\n</ul>\n",
        "likes": 5122,
        "dislikes": 353,
        "stats": "{\"totalAccepted\": \"413.1K\", \"totalSubmission\": \"734.5K\", \"totalAcceptedRaw\": 413088, \"totalSubmissionRaw\": 734541, \"acRate\": \"56.2%\"}",
        "similarQuestions": "[{\"title\": \"Range Sum Query - Immutable\", \"titleSlug\": \"range-sum-query-immutable\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query 2D - Mutable\", \"titleSlug\": \"range-sum-query-2d-mutable\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Grid of Region Average\", \"titleSlug\": \"find-the-grid-of-region-average\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Prefix Sum"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/range-sum-query-2d-immutable/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "305",
        "questionFrontendId": "305",
        "title": "Number of Islands II",
        "content": null,
        "likes": 1924,
        "dislikes": 75,
        "stats": "{\"totalAccepted\": \"160.7K\", \"totalSubmission\": \"401.6K\", \"totalAcceptedRaw\": 160734, \"totalSubmissionRaw\": 401628, \"acRate\": \"40.0%\"}",
        "similarQuestions": "[{\"title\": \"Number of Islands\", \"titleSlug\": \"number-of-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Process Restricted Friend Requests\", \"titleSlug\": \"process-restricted-friend-requests\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Union Find"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/number-of-islands-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "306",
        "questionFrontendId": "306",
        "title": "Additive Number",
        "content": "<p>An <strong>additive number</strong> is a string whose digits can form an <strong>additive sequence</strong>.</p>\n\n<p>A valid <strong>additive sequence</strong> should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>\n\n<p>Given a string containing only digits, return <code>true</code> if it is an <strong>additive number</strong> or <code>false</code> otherwise.</p>\n\n<p><strong>Note:</strong> Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> &quot;112358&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> &quot;199100199&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThe additive sequence is: 1, 99, 100, 199.&nbsp;\n1 + 99 = 100, 99 + 100 = 199\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 35</code></li>\n\t<li><code>num</code> consists only of digits.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> How would you handle overflow for very large input integers?</p>\n",
        "likes": 1212,
        "dislikes": 813,
        "stats": "{\"totalAccepted\": \"102.6K\", \"totalSubmission\": \"316.9K\", \"totalAcceptedRaw\": 102592, \"totalSubmissionRaw\": 316850, \"acRate\": \"32.4%\"}",
        "similarQuestions": "[{\"title\": \"Split Array into Fibonacci Sequence\", \"titleSlug\": \"split-array-into-fibonacci-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/additive-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "307",
        "questionFrontendId": "307",
        "title": "Range Sum Query - Mutable",
        "content": "<p>Given an integer array <code>nums</code>, handle multiple queries of the following types:</p>\n\n<ol>\n\t<li><strong>Update</strong> the value of an element in <code>nums</code>.</li>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>\n</ol>\n\n<p>Implement the <code>NumArray</code> class:</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>void update(int index, int val)</code> <strong>Updates</strong> the value of <code>nums[index]</code> to be <code>val</code>.</li>\n\t<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;update&quot;, &quot;sumRange&quot;]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n<strong>Output</strong>\n[null, 9, null, 8]\n\n<strong>Explanation</strong>\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = [1, 2, 5]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index &lt; nums.length</code></li>\n\t<li><code>-100 &lt;= val &lt;= 100</code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>update</code> and <code>sumRange</code>.</li>\n</ul>\n",
        "likes": 4897,
        "dislikes": 259,
        "stats": "{\"totalAccepted\": \"299.8K\", \"totalSubmission\": \"719.9K\", \"totalAcceptedRaw\": 299809, \"totalSubmissionRaw\": 719920, \"acRate\": \"41.6%\"}",
        "similarQuestions": "[{\"title\": \"Range Sum Query - Immutable\", \"titleSlug\": \"range-sum-query-immutable\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query 2D - Mutable\", \"titleSlug\": \"range-sum-query-2d-mutable\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shifting Letters II\", \"titleSlug\": \"shifting-letters-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Binary Indexed Tree"
          },
          {
            "name": "Segment Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/range-sum-query-mutable/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "308",
        "questionFrontendId": "308",
        "title": "Range Sum Query 2D - Mutable",
        "content": null,
        "likes": 811,
        "dislikes": 94,
        "stats": "{\"totalAccepted\": \"80.4K\", \"totalSubmission\": \"179.6K\", \"totalAcceptedRaw\": 80416, \"totalSubmissionRaw\": 179638, \"acRate\": \"44.8%\"}",
        "similarQuestions": "[{\"title\": \"Range Sum Query 2D - Immutable\", \"titleSlug\": \"range-sum-query-2d-immutable\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query - Mutable\", \"titleSlug\": \"range-sum-query-mutable\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Increment Submatrices by One\", \"titleSlug\": \"increment-submatrices-by-one\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sum of Matrix After Queries\", \"titleSlug\": \"sum-of-matrix-after-queries\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Binary Indexed Tree"
          },
          {
            "name": "Segment Tree"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": null,
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/range-sum-query-2d-mutable/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "309",
        "questionFrontendId": "309",
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n\t<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>\n</ul>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,0,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 9662,
        "dislikes": 338,
        "stats": "{\"totalAccepted\": \"622.7K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 622675, \"totalSubmissionRaw\": 1037750, \"acRate\": \"60.0%\"}",
        "similarQuestions": "[{\"title\": \"Best Time to Buy and Sell Stock\", \"titleSlug\": \"best-time-to-buy-and-sell-stock\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Best Time to Buy and Sell Stock II\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "310",
        "questionFrontendId": "310",
        "title": "Minimum Height Trees",
        "content": "<p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly</i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.</p>\n\n<p>Given a tree of <code>n</code> nodes&nbsp;labelled from <code>0</code> to <code>n - 1</code>, and an array of&nbsp;<code>n - 1</code>&nbsp;<code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i</sub></code> and&nbsp;<code>b<sub>i</sub></code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)&nbsp; are called <strong>minimum height trees</strong> (MHTs).</p>\n\n<p>Return <em>a list of all <strong>MHTs&#39;</strong> root labels</em>.&nbsp;You can return the answer in <strong>any order</strong>.</p>\n\n<p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e1.jpg\" style=\"width: 800px; height: 213px;\" />\n<pre>\n<strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e2.jpg\" style=\"width: 800px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n<strong>Output:</strong> [3,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li>\n\t<li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li>\n</ul>\n",
        "likes": 8555,
        "dislikes": 403,
        "stats": "{\"totalAccepted\": \"422.3K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 422295, \"totalSubmissionRaw\": 1007535, \"acRate\": \"41.9%\"}",
        "similarQuestions": "[{\"title\": \"Course Schedule\", \"titleSlug\": \"course-schedule\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Course Schedule II\", \"titleSlug\": \"course-schedule-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Collect Coins in a Tree\", \"titleSlug\": \"collect-coins-in-a-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Pairs of Connectable Servers in a Weighted Tree Network\", \"titleSlug\": \"count-pairs-of-connectable-servers-in-a-weighted-tree-network\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Minimum Diameter After Merging Two Trees\", \"titleSlug\": \"find-minimum-diameter-after-merging-two-trees\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "How many MHTs can a graph have at most?"
        ],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Topological Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-height-trees/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "311",
        "questionFrontendId": "311",
        "title": "Sparse Matrix Multiplication",
        "content": null,
        "likes": 1091,
        "dislikes": 365,
        "stats": "{\"totalAccepted\": \"205.3K\", \"totalSubmission\": \"299.1K\", \"totalAcceptedRaw\": 205331, \"totalSubmissionRaw\": 299102, \"acRate\": \"68.6%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sparse-matrix-multiplication/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "312",
        "questionFrontendId": "312",
        "title": "Burst Balloons",
        "content": "<p>You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.</p>\n\n<p>If you burst the <code>i<sup>th</sup></code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds of the array, then treat it as if there is a balloon with a <code>1</code> painted on it.</p>\n\n<p>Return <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,5,8]\n<strong>Output:</strong> 167\n<strong>Explanation:</strong>\nnums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "likes": 9326,
        "dislikes": 264,
        "stats": "{\"totalAccepted\": \"348.2K\", \"totalSubmission\": \"572.1K\", \"totalAcceptedRaw\": 348213, \"totalSubmissionRaw\": 572147, \"acRate\": \"60.9%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Cost to Merge Stones\", \"titleSlug\": \"minimum-cost-to-merge-stones\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/burst-balloons/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "313",
        "questionFrontendId": "313",
        "title": "Super Ugly Number",
        "content": "<p>A <strong>super ugly number</strong> is a positive integer whose prime factors are in the array <code>primes</code>.</p>\n\n<p>Given an integer <code>n</code> and an array of integers <code>primes</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>super ugly number</strong></em>.</p>\n\n<p>The <code>n<sup>th</sup></code> <strong>super ugly number</strong> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 12, primes = [2,7,13,19]\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, primes = [2,3,5]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= primes.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= primes[i] &lt;= 1000</code></li>\n\t<li><code>primes[i]</code> is <strong>guaranteed</strong> to be a prime number.</li>\n\t<li>All the values of <code>primes</code> are <strong>unique</strong> and sorted in <strong>ascending order</strong>.</li>\n</ul>\n",
        "likes": 2222,
        "dislikes": 400,
        "stats": "{\"totalAccepted\": \"141.6K\", \"totalSubmission\": \"311.8K\", \"totalAcceptedRaw\": 141582, \"totalSubmissionRaw\": 311821, \"acRate\": \"45.4%\"}",
        "similarQuestions": "[{\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/super-ugly-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "314",
        "questionFrontendId": "314",
        "title": "Binary Tree Vertical Order Traversal",
        "content": null,
        "likes": 3378,
        "dislikes": 347,
        "stats": "{\"totalAccepted\": \"528.6K\", \"totalSubmission\": \"930.1K\", \"totalAcceptedRaw\": 528629, \"totalSubmissionRaw\": 930068, \"acRate\": \"56.8%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Do BFS from the root. Let the root be at column 0. In the BFS, keep in the queue the node and its column.",
          "When you traverse a node, store its value in the column index. For example, the root's value should be stored at index 0.",
          "If the node has a left node, it column should be col - 1. Similarly, if the node has a right node, its column should be col + 1.",
          "At the end, check the minimum and maximum col and output their values."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-vertical-order-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "315",
        "questionFrontendId": "315",
        "title": "Count of Smaller Numbers After Self",
        "content": "<p>Given an integer array <code>nums</code>, return<em> an integer array </em><code>counts</code><em> where </em><code>counts[i]</code><em> is the number of smaller elements to the right of </em><code>nums[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,6,1]\n<strong>Output:</strong> [2,1,1,0]\n<strong>Explanation:</strong>\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-1]\n<strong>Output:</strong> [0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 8987,
        "dislikes": 247,
        "stats": "{\"totalAccepted\": \"348.8K\", \"totalSubmission\": \"816.2K\", \"totalAcceptedRaw\": 348841, \"totalSubmissionRaw\": 816241, \"acRate\": \"42.7%\"}",
        "similarQuestions": "[{\"title\": \"Count of Range Sum\", \"titleSlug\": \"count-of-range-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Queue Reconstruction by Height\", \"titleSlug\": \"queue-reconstruction-by-height\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reverse Pairs\", \"titleSlug\": \"reverse-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"How Many Numbers Are Smaller Than the Current Number\", \"titleSlug\": \"how-many-numbers-are-smaller-than-the-current-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Good Triplets in an Array\", \"titleSlug\": \"count-good-triplets-in-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count the Number of K-Big Indices\", \"titleSlug\": \"count-the-number-of-k-big-indices\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Binary Indexed Tree"
          },
          {
            "name": "Segment Tree"
          },
          {
            "name": "Merge Sort"
          },
          {
            "name": "Ordered Set"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "316",
        "questionFrontendId": "316",
        "title": "Remove Duplicate Letters",
        "content": "<p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <span data-keyword=\"lexicographically-smaller-string\"><strong>the smallest in lexicographical order</strong></span> among all possible results.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bcabc&quot;\n<strong>Output:</strong> &quot;abc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbacdcbc&quot;\n<strong>Output:</strong> &quot;acdb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1081: <a href=\"https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/\" target=\"_blank\">https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/</a></p>\n",
        "likes": 8890,
        "dislikes": 660,
        "stats": "{\"totalAccepted\": \"375.1K\", \"totalSubmission\": \"735.5K\", \"totalAcceptedRaw\": 375108, \"totalSubmissionRaw\": 735466, \"acRate\": \"51.0%\"}",
        "similarQuestions": "[{\"title\": \"Smallest K-Length Subsequence With Occurrences of a Letter\", \"titleSlug\": \"smallest-k-length-subsequence-with-occurrences-of-a-letter\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Greedily try to add one missing character. How to check if adding some character will not cause problems ? Use bit-masks to check whether you will be able to complete the sub-sequence if you add the character at some index i."
        ],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-duplicate-letters/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "317",
        "questionFrontendId": "317",
        "title": "Shortest Distance from All Buildings",
        "content": null,
        "likes": 1933,
        "dislikes": 337,
        "stats": "{\"totalAccepted\": \"200.4K\", \"totalSubmission\": \"453.7K\", \"totalAcceptedRaw\": 200384, \"totalSubmissionRaw\": 453719, \"acRate\": \"44.2%\"}",
        "similarQuestions": "[{\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Meeting Point\", \"titleSlug\": \"best-meeting-point\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"As Far from Land as Possible\", \"titleSlug\": \"as-far-from-land-as-possible\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/shortest-distance-from-all-buildings/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "318",
        "questionFrontendId": "318",
        "title": "Maximum Product of Word Lengths",
        "content": "<p>Given a string array <code>words</code>, return <em>the maximum value of</em> <code>length(word[i]) * length(word[j])</code> <em>where the two words do not share common letters</em>. If no such two words exist, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The two words can be &quot;ab&quot;, &quot;cd&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> No such pair of words.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> consists only of lowercase English letters.</li>\n</ul>\n",
        "likes": 3565,
        "dislikes": 143,
        "stats": "{\"totalAccepted\": \"232.5K\", \"totalSubmission\": \"384.7K\", \"totalAcceptedRaw\": 232537, \"totalSubmissionRaw\": 384726, \"acRate\": \"60.4%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximum-product-of-word-lengths/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "319",
        "questionFrontendId": "319",
        "title": "Bulb Switcher",
        "content": "<p>There are <code>n</code> bulbs that are initially off. You first turn on all the bulbs, then&nbsp;you turn off every second bulb.</p>\n\n<p>On the third round, you toggle every third bulb (turning on if it&#39;s off or turning off if it&#39;s on). For the <code>i<sup>th</sup></code> round, you toggle every <code>i</code> bulb. For the <code>n<sup>th</sup></code> round, you only toggle the last bulb.</p>\n\n<p>Return <em>the number of bulbs that are on after <code>n</code> rounds</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg\" style=\"width: 421px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 2774,
        "dislikes": 3174,
        "stats": "{\"totalAccepted\": \"251.4K\", \"totalSubmission\": \"466.9K\", \"totalAcceptedRaw\": 251363, \"totalSubmissionRaw\": 466898, \"acRate\": \"53.8%\"}",
        "similarQuestions": "[{\"title\": \"Bulb Switcher II\", \"titleSlug\": \"bulb-switcher-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of K Consecutive Bit Flips\", \"titleSlug\": \"minimum-number-of-k-consecutive-bit-flips\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Times Binary String Is Prefix-Aligned\", \"titleSlug\": \"number-of-times-binary-string-is-prefix-aligned\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Pivot Integer\", \"titleSlug\": \"find-the-pivot-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Brainteaser"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n--- \n\n### Approach 1: Math\n\n#### Intuition\n\nThe idea behind this problem is to find the number of bulbs that are on after `n` rounds. In each round, we toggle some of the bulbs.  \n\nAs all the bulbs are initially off, at the end **only bulbs that are toggled an odd number of times will remain on**.    \nNow, whenever we are at a round `i` we know we toggle all bulbs having a factor `i`. Thus, we need to find the bulbs which have an odd number of factors, as those bulbs will be toggled an odd number of times (once by each factor).   \n\nIt might be unintuitive, but with a few examples, we can easily see that a perfect square number has an odd number of factors, since any number's factors come in pairs of two different numbers, but the square root of the number will be paired with itself.\n\n\nLet's take an example to make it more clear. Suppose `n = 10`.   \nSo, the number of rounds is `10`. In each round, we will toggle some of the bulbs.\n\n![slide1](../Figures/319/Slide.PNG)\n\nTrack of rounds in which each bulb is toggled:    \n- **Bulb 1:**   Round 1 **(odd number of toggles)**   \n- **Bulb 2:**   Round 1, Round 2   \n- **Bulb 3:**   Round 1, Round 3   \n- **Bulb 4:**   Round 1, Round 2, Round 4 **(odd number of toggles)**   \n- **Bulb 5:**   Round 1, Round 5   \n- **Bulb 6:**   Round 1, Round 2, Round 3, Round 6   \n- **Bulb 7:**   Round 1, Round 7   \n- **Bulb 8:**   Round 1, Round 2, Round 4, Round 8   \n- **Bulb 9:**   Round 1, Round 3, Round 9 **(odd number of toggles)**   \n- **Bulb 10:** Round 1, Round 2, Round 5, Round10   \n\nSo, the number of bulbs that are on after 10 rounds is 3: Bulb 1, Bulb 4, and Bulb 9.\n\n<br />\n\nNow let's discuss, **why do perfect squares have odd and non-perfect squares have an even number of factors?**  \n\nA factor is a number that can be multiplied by another number to produce a given result. Say for `12`, `1, 2, 3, 4, 6, 12` all are its factors as any factor `x` can be paired with another factor `12 / x` and when multiplied together it will result in `12`.    \n  \nWhen we factorize a number `y`, say we have one factor `x`, then the other factor whose multiplication will result in the original number will be `y / x`.   \nNow comparing `x` and `y / x`, if `y` is a perfect square it means `y = a * a`, thus, here it is a possibility that `x` and `y / x` are same numbers, i.e. `a`.    \nBut if `y` is not a perfect square then for each `x` we will have a unique `y / x`, thus, it's factor pairs will always exist as two different numbers (e.g: for `12` -> `1 x 12`, `2 x 6`, `3 x 4`, (it has three factor pairs, so total `6` factors)), thus the total count of number of factors for non-perfect squares will be even,    \nand for perfect square, all other `x` and `y / x` factor pairs will be two different numbers except for one case, i.e. `a` and `a` (e.g: for `16` -> `1 x 16`, `2 x 8`, `4 x 4` (`4` is paired with itself, it has three factor pairs, but one pair has both numbers same, so total `5` factors)). Thus, it will have odd number of total factors.\n\n<br />\n\nThus we just need to find how many numbers from `1` to `n` are perfect squares.   \nWe can iterate on each number and check if it's a perfect square or not, (i.e. `floor(sqrt(i)) * floor(sqrt(i)) == i`)\n\nOr, we can directly find the square root of `n` and its floor value will be equal to the count of numbers whose squares exist in this range `1` to `n`. \n\nThe floor of the square root of `n` gives us the largest number whose square is less than or equal to `n`. For example, if `n = 26`, then the floor of square root of `n` is `5`, which means the largest number whose square is less than or equal to `26` is `5` thus for each number from `1` to `5`, its respective square will be present in the original range. So, there are `5` perfect squares in the range `1` to `25` `(1, 4, 9, 16, and 25)`. \n\nSo, taking the floor value of the square root of `n` will give us the number of perfect squares in the range `1` to `n`.     \nHence, `sqrt(n)` is our answer to this problem.\n\n> **Note:** You can also implement a function to find the square root of a number on your own, but here will use the in-built STL methods provided by each language.\n\n#### Algorithm\n\n1. Return the square root of `n`.\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/nBFXmq9V/shared\" frameBorder=\"0\" width=\"100%\" height=\"157\" name=\"nBFXmq9V\"></iframe>\n\n\n#### Complexity Analysis\n\nHere, $n$ is the number of bulbs and rounds.\n\n* Time complexity: $O(1)$          \n  - In general, the [fast inverse square root algorithm](https://en.wikipedia.org/wiki/Fast_inverse_square_root) is used to compute the square root of a number (which is typically represented using 32 bits) in most programming languages. The algorithm performs a series of bitwise and floating-point operations on the input value to compute an approximation of the inverse square root. The number of operations performed by the algorithm is fixed and does not depend on the input size. Thus, it makes each call to this method an $O(1)$ time operation.\n<br />\n\n  > Note: If we want to compute the square root of large numbers (e.g: 10^10000), it would be impractical to use the fast inverse square root algorithm. The fast inverse square root algorithm is designed to compute an approximation of the inverse square root of a 32-bit floating-point number, and it may not be accurate enough for very large numbers.\n  > \n  > Instead, the languages would need to use a different algorithm that is capable of handling very large numbers with high precision. The Newton-Raphson and Babylonina methods are such algorithms that can be used to compute the square root of large numbers with high precision in nearly log-linear time (also called linearithmic time) $O(d \\log d)$, where $d$ is the number of digits of the input number. \n\n* Space complexity: $O(1)$    \n  - The implementation of the `sqrt` method doesn't use any additional space."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/bulb-switcher/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "320",
        "questionFrontendId": "320",
        "title": "Generalized Abbreviation",
        "content": null,
        "likes": 707,
        "dislikes": 232,
        "stats": "{\"totalAccepted\": \"73.9K\", \"totalSubmission\": \"123.3K\", \"totalAcceptedRaw\": 73931, \"totalSubmissionRaw\": 123286, \"acRate\": \"60.0%\"}",
        "similarQuestions": "[{\"title\": \"Subsets\", \"titleSlug\": \"subsets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Unique Word Abbreviation\", \"titleSlug\": \"unique-word-abbreviation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Unique Word Abbreviation\", \"titleSlug\": \"minimum-unique-word-abbreviation\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": true,
          "content": "## Solution\n\n---\n\n### Approach 1: Backtracking\n\n#### Intuition\n\nWe are given a string `word` of $N$ lowercase English letters. Our task is to choose any number of non-overlapping and non-adjacent substrings from the string and replace them with their length, resulting in an abbreviated string of the original one. \n\nFor example, given the string `abcde`, we can choose substrings `bc` and `e`, replacing `bc` with `2` and `e` with `1`, resulting in the abbreviated string `a2d1`. Note that substrings like `bc` and `cd` are invalid because they are adjacent, and substrings like `abc` and `cd` are invalid because they overlap.\n\nAn important observation is that the length of the string `word` will be less than 15. To generate all possible abbreviated strings, we need to explore all options. Each character in `word` can either be part of an abbreviated substring or remain as a separate character. We will explore both options for each character and store the resulting strings in a list.\n\nFor each character, the first option is to keep it as part of the current string without abbreviation. The second option is to abbreviate it. We track three things: the current string being constructed (`currWord`), the current index in `word` (`index`), and the length of the current substring being abbreviated (`abbreviatedCount`).\n\nWhen we choose to abbreviate a character, we increment the `abbreviatedCount` by 1 and move to the next index. When we choose not to abbreviate, we add the `abbreviatedCount` to `currWord` (since the current substring ends), then add the character `word[index]` to `currWord`, and reset `abbreviatedCount` to 0.\n\nAfter iterating over all characters in `word`, we add the final `abbreviatedCount` to `currWord` and store the resulting string in a list of all possible abbreviations.\n\n#### Algorithm\n\n1. Initialize an empty list of strings `abbreviations`.\n\n2. Define the method `storeAbbreviations` that has three parameters to track `currWord`, `index`, and `abbreviatedCount`. Do the following:\n    - If the `index` is equal to the `word` size, store the abbreviated integer corresponding to the last substring to `currWord` and then store it in the list `abbreviations`.\n    - Define the string `abbreviatedString` as the `abbreviatedCount` in the form of a string or an empty string if the integer is `0`.\n    - Recursively call the method when we choose not to abbreviate the current character with `index = index + 1`, `abbreviatedCount = 0`, add the`abbreviatedString` and `word[index]` to `currWord`.\n    - When we choose to abbreviate the current character, make a recursive call with `index = index + 1`, `abbreviatedCount = abbreviatedCount + 1`.\n \n3. Call the method `storeAbbreviations` with `index = 0` and `abbreviatedCount = 0`.\n4. Return `abbreviations`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/mnybzYD4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mnybzYD4\"></iframe>\n\n#### Complexity Analysis\n\nHere, $N$ is the length of the string `word`.\n\n* Time complexity: $O(N \\times 2^N)$.\n\n  Each of the $N$ characters in the string `word` has two choices that we will make until we do it for all the characters. Also, for each string produced, we are appending the `abbreviatedString` during the process which adds another $O(N)$ time. Since we are going to generate $2^N$ strings, therefore the time complexity is equal to $O(2^N)$.\n\n* Space complexity: $O(N)$.\n\n    The space used to store the output is generally not considered part of the space complexity. Thus, the only space required is the stack space, the maximum number of active function calls in the stack will be equal to $N$ one for each character in the string `word`. Hence, the space complexity is equal to $O(N)$.\n\n---\n\n### Approach 2: Bit Manipulation\n\n#### Intuition\n\nThis approach is very similar to the previous one, following the same procedure but in an iterative manner. From the previous approach, we know that each character has two choices, and we will expand each choice for all characters to generate all $2^N$ strings. Another way to view this is by using bits: consider the numbers from `0` to $2^N - 1$ and their binary representation. If a bit in the binary representation is `0`, it means we are not going to abbreviate the corresponding character; if the bit is `1`, it means this character will be abbreviated.\n\nThe starting number `0` has all bits as `0`, meaning none of the characters should be abbreviated, while the last number $2^N - 1$ has all bits as `1`, meaning all characters should be abbreviated as a single substring. The integers in between represent the different combinations of choices for each character.\n\nTo represent all possible combinations for choices of all characters, we convert these binary numbers to strings that represent the abbreviated form of the original string. When a bit is `1`, we need to add it to the abbreviated string and hence we keep an integer `abbreviatedCount` to track the length of the current substring that is being abbreviated. We increment this counter when the bit is `1`. When the bit is `0`, we append the current character as it is to the current word we are preparing, `currWord`. However, before appending the character, we append the abbreviated string of the last substring length represented by `abbreviatedCount`, then reset `abbreviatedCount` to `0`.\n\nFor each of the integers from `0` to $2^N - 1$, we repeat this process and store the `currWord` in the list of strings `abbreviations`, which we can return at the end.\n\n![fig](../Figures/320/320A.png)\n\n#### Algorithm\n\n1. Initialize an empty list of strings `abbreviations`.\n2. Iterate over each number from `0` to `$2^N$ - 1` and for each such integer `mask` do the following:\n\n    - Initialize an empty string `currWord` and integer `abbreviatedCount` to `0`.\n    - Iterate over the integers from `0` to `N - 1` `Index` that represents the bits, for each `Index`\n        - If the bit at `Index` is `1`, increment the counter `abbreviatedCount`\n        - If the bit at `Index` is `0`, append the integer `abbreviatedCount` (if not `0`) and then append the character `word[Index]` to `currWord`. Reset `abbreviatedCount` to `0`.\n    - After iterating over all bits, append the last substring length (if not `0`) using the variable `abbreviatedCount` to `currWord`.\n    - Add the string `currWord` to `abbreviations`.\n\n3. Return `abbreviations`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/TRMro2mK/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"TRMro2mK\"></iframe>\n\n#### Complexity Analysis\n\nHere, $N$ is the length of the string `word`.\n\n* Time complexity: $O(N \\times 2^N)$.\n\n    We iterate over the integers from `0` to `$2^N$ - 1` and for each one of these we will iterate over the bits from `0` to `N`, hence the total time complexity is equal to $O(N \\times 2^N)$.\n\n* Space complexity: $O(1)$.\n\n    The space used to store the output is generally not considered part of the space complexity. Thus no extra space is required. Hence, the space complexity is constant.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/generalized-abbreviation/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "321",
        "questionFrontendId": "321",
        "title": "Create Maximum Number",
        "content": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of lengths <code>m</code> and <code>n</code> respectively. <code>nums1</code> and <code>nums2</code> represent the digits of two numbers. You are also given an integer <code>k</code>.</p>\n\n<p>Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two numbers. The relative order of the digits from the same array must be preserved.</p>\n\n<p>Return an array of the <code>k</code> digits representing the answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n<strong>Output:</strong> [9,8,6,5,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [6,7], nums2 = [6,0,4], k = 5\n<strong>Output:</strong> [6,7,6,0,4]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,9], nums2 = [8,9], k = 3\n<strong>Output:</strong> [9,8,9]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= m + n</code></li>\n\t<li><code>nums1</code> and <code>nums2</code> do not have leading zeros.</li>\n</ul>\n",
        "likes": 2013,
        "dislikes": 363,
        "stats": "{\"totalAccepted\": \"70.2K\", \"totalSubmission\": \"219.2K\", \"totalAcceptedRaw\": 70222, \"totalSubmissionRaw\": 219241, \"acRate\": \"32.0%\"}",
        "similarQuestions": "[{\"title\": \"Remove K Digits\", \"titleSlug\": \"remove-k-digits\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Swap\", \"titleSlug\": \"maximum-swap\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/create-maximum-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "322",
        "questionFrontendId": "322",
        "title": "Coin Change",
        "content": "<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>\n\n<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>\n\n<p>You may assume that you have an infinite number of each kind of coin.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> coins = [1,2,5], amount = 11\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 11 = 5 + 5 + 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> coins = [2], amount = 3\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> coins = [1], amount = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 19761,
        "dislikes": 496,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"4.9M\", \"totalAcceptedRaw\": 2258056, \"totalSubmissionRaw\": 4902348, \"acRate\": \"46.1%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Cost For Tickets\", \"titleSlug\": \"minimum-cost-for-tickets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Value of K Coins From Piles\", \"titleSlug\": \"maximum-value-of-k-coins-from-piles\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Operations to Convert Time\", \"titleSlug\": \"minimum-number-of-operations-to-convert-time\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost to Split an Array\", \"titleSlug\": \"minimum-cost-to-split-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count of Sub-Multisets With Bounded Sum\", \"titleSlug\": \"count-of-sub-multisets-with-bounded-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Length of the Longest Subsequence That Sums to Target\", \"titleSlug\": \"length-of-the-longest-subsequence-that-sums-to-target\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Coins to be Added\", \"titleSlug\": \"minimum-number-of-coins-to-be-added\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Most Expensive Item That Can Not Be Bought\", \"titleSlug\": \"most-expensive-item-that-can-not-be-bought\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Breadth-First Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/coin-change/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "323",
        "questionFrontendId": "323",
        "title": "Number of Connected Components in an Undirected Graph",
        "content": null,
        "likes": 2738,
        "dislikes": 108,
        "stats": "{\"totalAccepted\": \"472.3K\", \"totalSubmission\": \"737.9K\", \"totalAcceptedRaw\": 472311, \"totalSubmissionRaw\": 737942, \"acRate\": \"64.0%\"}",
        "similarQuestions": "[{\"title\": \"Number of Islands\", \"titleSlug\": \"number-of-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Graph Valid Tree\", \"titleSlug\": \"graph-valid-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Provinces\", \"titleSlug\": \"number-of-provinces\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Maze That Lead to Same Room\", \"titleSlug\": \"paths-in-maze-that-lead-to-same-room\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count the Number of Complete Components\", \"titleSlug\": \"count-the-number-of-complete-components\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Union Find"
          },
          {
            "name": "Graph"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "324",
        "questionFrontendId": "324",
        "title": "Wiggle Sort II",
        "content": "<p>Given an integer array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>\n\n<p>You may assume the input array always has a valid answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,1,1,6,4]\n<strong>Output:</strong> [1,6,1,5,1,4]\n<strong>Explanation:</strong> [1,4,1,5,1,6] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,2,3,1]\n<strong>Output:</strong> [2,3,1,3,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>It is guaranteed that there will be an answer for the given input <code>nums</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow Up:</strong> Can you do it in <code>O(n)</code> time and/or <strong>in-place</strong> with <code>O(1)</code> extra space?",
        "likes": 3146,
        "dislikes": 974,
        "stats": "{\"totalAccepted\": \"177.2K\", \"totalSubmission\": \"500.1K\", \"totalAcceptedRaw\": 177237, \"totalSubmissionRaw\": 500107, \"acRate\": \"35.4%\"}",
        "similarQuestions": "[{\"title\": \"Sort Colors\", \"titleSlug\": \"sort-colors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Kth Largest Element in an Array\", \"titleSlug\": \"kth-largest-element-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Wiggle Sort\", \"titleSlug\": \"wiggle-sort\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Array With Elements Not Equal to Average of Neighbors\", \"titleSlug\": \"array-with-elements-not-equal-to-average-of-neighbors\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Quickselect"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/wiggle-sort-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "325",
        "questionFrontendId": "325",
        "title": "Maximum Size Subarray Sum Equals k",
        "content": null,
        "likes": 2082,
        "dislikes": 64,
        "stats": "{\"totalAccepted\": \"205.1K\", \"totalSubmission\": \"407.8K\", \"totalAcceptedRaw\": 205050, \"totalSubmissionRaw\": 407775, \"acRate\": \"50.3%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Size Subarray Sum\", \"titleSlug\": \"minimum-size-subarray-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query - Immutable\", \"titleSlug\": \"range-sum-query-immutable\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Contiguous Array\", \"titleSlug\": \"contiguous-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Subarray Product Less Than K\", \"titleSlug\": \"subarray-product-less-than-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Beauty of an Array After Applying Operation\", \"titleSlug\": \"maximum-beauty-of-an-array-after-applying-operation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Subarray With OR at Least K II\", \"titleSlug\": \"shortest-subarray-with-or-at-least-k-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Compute the prefix sum array where psum[i] is the sum of all the elements from <i>0</i> to <i>i</i>.",
          "At each index <i>i</i>, the sum of the prefix is psum[i], so we are searching for the index x where psum[x] = psum[i] - k.\r\nThe subarray [x + 1, i] will be of sum k.",
          "Use a hashmap to get the index x efficiently or to determine that it does not exist."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Prefix Sum"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "326",
        "questionFrontendId": "326",
        "title": "Power of Three",
        "content": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 27\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 27 = 3<sup>3</sup>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = (-1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "likes": 3234,
        "dislikes": 289,
        "stats": "{\"totalAccepted\": \"995.8K\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 995845, \"totalSubmissionRaw\": 2085830, \"acRate\": \"47.7%\"}",
        "similarQuestions": "[{\"title\": \"Power of Two\", \"titleSlug\": \"power-of-two\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Power of Four\", \"titleSlug\": \"power-of-four\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Check if Number is a Sum of Powers of Three\", \"titleSlug\": \"check-if-number-is-a-sum-of-powers-of-three\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/power-of-three/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "327",
        "questionFrontendId": "327",
        "title": "Count of Range Sum",
        "content": "<p>Given an integer array <code>nums</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of range sums that lie in</em> <code>[lower, upper]</code> <em>inclusive</em>.</p>\n\n<p>Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and <code>j</code> inclusive, where <code>i &lt;= j</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,5,-1], lower = -2, upper = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0], lower = 0, upper = 0\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>\n\t<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n",
        "likes": 2396,
        "dislikes": 255,
        "stats": "{\"totalAccepted\": \"87.7K\", \"totalSubmission\": \"238.6K\", \"totalAcceptedRaw\": 87718, \"totalSubmissionRaw\": 238553, \"acRate\": \"36.8%\"}",
        "similarQuestions": "[{\"title\": \"Count of Smaller Numbers After Self\", \"titleSlug\": \"count-of-smaller-numbers-after-self\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Reverse Pairs\", \"titleSlug\": \"reverse-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count the Number of Fair Pairs\", \"titleSlug\": \"count-the-number-of-fair-pairs\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Number of Copy Arrays\", \"titleSlug\": \"find-the-number-of-copy-arrays\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Binary Indexed Tree"
          },
          {
            "name": "Segment Tree"
          },
          {
            "name": "Merge Sort"
          },
          {
            "name": "Ordered Set"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-of-range-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "328",
        "questionFrontendId": "328",
        "title": "Odd Even Linked List",
        "content": "<p>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p>\n\n<p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p>\n\n<p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p>\n\n<p>You must solve the problem&nbsp;in <code>O(1)</code>&nbsp;extra space complexity and <code>O(n)</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg\" style=\"width: 300px; height: 123px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,3,5,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [2,1,3,5,6,4,7]\n<strong>Output:</strong> [2,3,6,7,1,5,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the linked list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>6</sup> &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "likes": 10634,
        "dislikes": 557,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1186609, \"totalSubmissionRaw\": 1917266, \"acRate\": \"61.9%\"}",
        "similarQuestions": "[{\"title\": \"Split Linked List in Parts\", \"titleSlug\": \"split-linked-list-in-parts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Transform Array by Parity\", \"titleSlug\": \"transform-array-by-parity\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/odd-even-linked-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "329",
        "questionFrontendId": "329",
        "title": "Longest Increasing Path in a Matrix",
        "content": "<p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>\n\n<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 9177,
        "dislikes": 140,
        "stats": "{\"totalAccepted\": \"614.7K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 614681, \"totalSubmissionRaw\": 1116452, \"acRate\": \"55.1%\"}",
        "similarQuestions": "[{\"title\": \"Number of Increasing Paths in a Grid\", \"titleSlug\": \"number-of-increasing-paths-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Topological Sort"
          },
          {
            "name": "Memoization"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "330",
        "questionFrontendId": "330",
        "title": "Patching Array",
        "content": "<p>Given a sorted integer array <code>nums</code> and an integer <code>n</code>, add/patch elements to the array such that any number in the range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array.</p>\n\n<p>Return <em>the minimum number of patches required</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3], n = 6\n<strong>Output:</strong> 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,10], n = 20\n<strong>Output:</strong> 2\nExplanation: The two patches can be [2, 4].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2], n = 5\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 2354,
        "dislikes": 198,
        "stats": "{\"totalAccepted\": \"167.3K\", \"totalSubmission\": \"313.4K\", \"totalAcceptedRaw\": 167337, \"totalSubmissionRaw\": 313400, \"acRate\": \"53.4%\"}",
        "similarQuestions": "[{\"title\": \"Maximum Number of Consecutive Values You Can Make\", \"titleSlug\": \"maximum-number-of-consecutive-values-you-can-make\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/patching-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "331",
        "questionFrontendId": "331",
        "title": "Verify Preorder Serialization of a Binary Tree",
        "content": "<p>One way to serialize a binary tree is to use <strong>preorder traversal</strong>. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as <code>&#39;#&#39;</code>.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg\" style=\"width: 362px; height: 293px;\" />\n<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>&#39;#&#39;</code> represents a null node.</p>\n\n<p>Given a string of comma-separated values <code>preorder</code>, return <code>true</code> if it is a correct preorder traversal serialization of a binary tree.</p>\n\n<p>It is <strong>guaranteed</strong> that each comma-separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing null pointer.</p>\n\n<p>You may assume that the input format is always valid.</p>\n\n<ul>\n\t<li>For example, it could never contain two consecutive commas, such as <code>&quot;1,,3&quot;</code>.</li>\n</ul>\n\n<p><strong>Note:&nbsp;</strong>You are not allowed to reconstruct the tree.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> preorder = \"1,#\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> preorder = \"9,#,#,1\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>preorder</code> consist of integers in the range <code>[0, 100]</code> and <code>&#39;#&#39;</code> separated by commas <code>&#39;,&#39;</code>.</li>\n</ul>\n",
        "likes": 2383,
        "dislikes": 126,
        "stats": "{\"totalAccepted\": \"152.3K\", \"totalSubmission\": \"331.2K\", \"totalAcceptedRaw\": 152286, \"totalSubmissionRaw\": 331226, \"acRate\": \"46.0%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "332",
        "questionFrontendId": "332",
        "title": "Reconstruct Itinerary",
        "content": "<p>You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p>\n\n<p>All of the tickets belong to a man who departs from <code>&quot;JFK&quot;</code>, thus, the itinerary must begin with <code>&quot;JFK&quot;</code>. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>\n\n<ul>\n\t<li>For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>\n</ul>\n\n<p>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg\" style=\"width: 382px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]\n<strong>Output:</strong> [&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg\" style=\"width: 222px; height: 230px;\" />\n<pre>\n<strong>Input:</strong> tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]\n<strong>Output:</strong> [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]\n<strong>Explanation:</strong> Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] but it is larger in lexical order.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tickets.length &lt;= 300</code></li>\n\t<li><code>tickets[i].length == 2</code></li>\n\t<li><code>from<sub>i</sub>.length == 3</code></li>\n\t<li><code>to<sub>i</sub>.length == 3</code></li>\n\t<li><code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> consist of uppercase English letters.</li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n</ul>\n",
        "likes": 6091,
        "dislikes": 1904,
        "stats": "{\"totalAccepted\": \"483.1K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 483117, \"totalSubmissionRaw\": 1111640, \"acRate\": \"43.5%\"}",
        "similarQuestions": "[{\"title\": \"Longest Common Subpath\", \"titleSlug\": \"longest-common-subpath\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Valid Arrangement of Pairs\", \"titleSlug\": \"valid-arrangement-of-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Graph"
          },
          {
            "name": "Eulerian Circuit"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/reconstruct-itinerary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "333",
        "questionFrontendId": "333",
        "title": "Largest BST Subtree",
        "content": null,
        "likes": 1529,
        "dislikes": 136,
        "stats": "{\"totalAccepted\": \"121.1K\", \"totalSubmission\": \"267.7K\", \"totalAcceptedRaw\": 121057, \"totalSubmissionRaw\": 267736, \"acRate\": \"45.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You can recursively use algorithm similar to <a href=\"https://leetcode.com/problems/validate-binary-search-tree/\">98. Validate Binary Search Tree</a> at each node of the tree, which will result in O(nlogn) time complexity."
        ],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/largest-bst-subtree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "334",
        "questionFrontendId": "334",
        "title": "Increasing Triplet Subsequence",
        "content": "<p>Given an integer array <code>nums</code>, return <code>true</code><em> if there exists a triple of indices </em><code>(i, j, k)</code><em> such that </em><code>i &lt; j &lt; k</code><em> and </em><code>nums[i] &lt; nums[j] &lt; nums[k]</code>. If no such indices exists, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Any triplet where i &lt; j &lt; k is valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,3,2,1]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> No triplet exists.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,5,0,4,6]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The triplet (3, 4, 5) is valid because nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you implement a solution that runs in <code>O(n)</code> time complexity and <code>O(1)</code> space complexity?",
        "likes": 8490,
        "dislikes": 638,
        "stats": "{\"totalAccepted\": \"770.8K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 770751, \"totalSubmissionRaw\": 1969060, \"acRate\": \"39.1%\"}",
        "similarQuestions": "[{\"title\": \"Longest Increasing Subsequence\", \"titleSlug\": \"longest-increasing-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Special Quadruplets\", \"titleSlug\": \"count-special-quadruplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Good Triplets in an Array\", \"titleSlug\": \"count-good-triplets-in-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Increasing Quadruplets\", \"titleSlug\": \"count-increasing-quadruplets\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/increasing-triplet-subsequence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "335",
        "questionFrontendId": "335",
        "title": "Self Crossing",
        "content": "<p>You are given an array of integers <code>distance</code>.</p>\n\n<p>You start at the point <code>(0, 0)</code> on an <strong>X-Y plane,</strong> and you move <code>distance[0]</code> meters to the north, then <code>distance[1]</code> meters to the west, <code>distance[2]</code> meters to the south, <code>distance[3]</code> meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.</p>\n\n<p>Return <code>true</code> <em>if your path crosses itself or </em><code>false</code><em> if it does not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/21/11.jpg\" style=\"width: 400px; height: 413px;\" />\n<pre>\n<strong>Input:</strong> distance = [2,1,1,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The path crosses itself at the point (0, 1).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/21/22.jpg\" style=\"width: 400px; height: 413px;\" />\n<pre>\n<strong>Input:</strong> distance = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The path does not cross itself at any point.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/21/33.jpg\" style=\"width: 400px; height: 413px;\" />\n<pre>\n<strong>Input:</strong> distance = [1,1,1,2,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The path crosses itself at the point (0, 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;distance.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;=&nbsp;distance[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 401,
        "dislikes": 518,
        "stats": "{\"totalAccepted\": \"39.3K\", \"totalSubmission\": \"123.8K\", \"totalAcceptedRaw\": 39335, \"totalSubmissionRaw\": 123796, \"acRate\": \"31.8%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Geometry"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/self-crossing/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "336",
        "questionFrontendId": "336",
        "title": "Palindrome Pairs",
        "content": "<p>You are given a <strong>0-indexed</strong> array of <strong>unique</strong> strings <code>words</code>.</p>\n\n<p>A <strong>palindrome pair</strong> is a pair of integers <code>(i, j)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; words.length</code>,</li>\n\t<li><code>i != j</code>, and</li>\n\t<li><code>words[i] + words[j]</code> (the concatenation of the two strings) is a <span data-keyword=\"palindrome-string\">palindrome</span>.</li>\n</ul>\n\n<p>Return <em>an array of all the <strong>palindrome pairs</strong> of </em><code>words</code>.</p>\n\n<p>You must write an algorithm with&nbsp;<code>O(sum of words[i].length)</code>&nbsp;runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]\n<strong>Output:</strong> [[0,1],[1,0],[3,2],[2,4]]\n<strong>Explanation:</strong> The palindromes are [&quot;abcddcba&quot;,&quot;dcbaabcd&quot;,&quot;slls&quot;,&quot;llssssll&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;a&quot;,&quot;a&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= words[i].length &lt;= 300</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "likes": 4543,
        "dislikes": 468,
        "stats": "{\"totalAccepted\": \"222.1K\", \"totalSubmission\": \"615.4K\", \"totalAcceptedRaw\": 222146, \"totalSubmissionRaw\": 615357, \"acRate\": \"36.1%\"}",
        "similarQuestions": "[{\"title\": \"Longest Palindromic Substring\", \"titleSlug\": \"longest-palindromic-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Palindrome by Concatenating Two Letter Words\", \"titleSlug\": \"longest-palindrome-by-concatenating-two-letter-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Maximum Number of String Pairs\", \"titleSlug\": \"find-maximum-number-of-string-pairs\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Checking every two pairs will exceed the time limit. It will be O(n^2 * k). We need a faster way.",
          "If we hash every string in the array, how can we check if two pairs form a palindrome after the concatenation?",
          "We can check every string in words and consider it as words[j] (i.e., the suffix of the target palindrome). We can check if there is a hash of string that can be the prefix to make it a palindrome."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Trie"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/palindrome-pairs/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "337",
        "questionFrontendId": "337",
        "title": "House Robber III",
        "content": "<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p>\n\n<p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p>\n\n<p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\" style=\"width: 277px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [3,2,3,null,3,null,1]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\" style=\"width: 357px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [3,4,5,1,3,null,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 8770,
        "dislikes": 147,
        "stats": "{\"totalAccepted\": \"430.6K\", \"totalSubmission\": \"786K\", \"totalAcceptedRaw\": 430612, \"totalSubmissionRaw\": 786038, \"acRate\": \"54.8%\"}",
        "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/house-robber-iii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "338",
        "questionFrontendId": "338",
        "title": "Counting Bits",
        "content": "<p>Given an integer <code>n</code>, return <em>an array </em><code>ans</code><em> of length </em><code>n + 1</code><em> such that for each </em><code>i</code><em> </em>(<code>0 &lt;= i &lt;= n</code>)<em>, </em><code>ans[i]</code><em> is the <strong>number of </strong></em><code>1</code><em><strong>&#39;s</strong> in the binary representation of </em><code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [0,1,1]\n<strong>Explanation:</strong>\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> [0,1,1,2,1,2]\n<strong>Explanation:</strong>\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>It is very easy to come up with a solution with a runtime of <code>O(n log n)</code>. Can you do it in linear time <code>O(n)</code> and possibly in a single pass?</li>\n\t<li>Can you do it without using any built-in function (i.e., like <code>__builtin_popcount</code> in C++)?</li>\n</ul>\n",
        "likes": 11474,
        "dislikes": 572,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1337792, \"totalSubmissionRaw\": 1682519, \"acRate\": \"79.5%\"}",
        "similarQuestions": "[{\"title\": \"Number of 1 Bits\", \"titleSlug\": \"number-of-1-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Values at Indices With K Set Bits\", \"titleSlug\": \"sum-of-values-at-indices-with-k-set-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the K-or of an Array\", \"titleSlug\": \"find-the-k-or-of-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You should make use of what you have produced already.",
          "Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.",
          "Or does the odd/even status of the number help you in calculating the number of 1s?"
        ],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/counting-bits/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "339",
        "questionFrontendId": "339",
        "title": "Nested List Weight Sum",
        "content": null,
        "likes": 1809,
        "dislikes": 466,
        "stats": "{\"totalAccepted\": \"364.9K\", \"totalSubmission\": \"427.6K\", \"totalAcceptedRaw\": 364929, \"totalSubmissionRaw\": 427609, \"acRate\": \"85.3%\"}",
        "similarQuestions": "[{\"title\": \"Nested List Weight Sum II\", \"titleSlug\": \"nested-list-weight-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Array Nesting\", \"titleSlug\": \"array-nesting\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Employee Importance\", \"titleSlug\": \"employee-importance\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/nested-list-weight-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "340",
        "questionFrontendId": "340",
        "title": "Longest Substring with At Most K Distinct Characters",
        "content": null,
        "likes": 2869,
        "dislikes": 81,
        "stats": "{\"totalAccepted\": \"373.6K\", \"totalSubmission\": \"756.3K\", \"totalAcceptedRaw\": 373561, \"totalSubmissionRaw\": 756316, \"acRate\": \"49.4%\"}",
        "similarQuestions": "[{\"title\": \"Longest Substring Without Repeating Characters\", \"titleSlug\": \"longest-substring-without-repeating-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Substring with At Most Two Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-two-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Repeating Character Replacement\", \"titleSlug\": \"longest-repeating-character-replacement\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Subarrays with K Different Integers\", \"titleSlug\": \"subarrays-with-k-different-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Max Consecutive Ones III\", \"titleSlug\": \"max-consecutive-ones-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximize the Confusion of an Exam\", \"titleSlug\": \"maximize-the-confusion-of-an-exam\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "341",
        "questionFrontendId": "341",
        "title": "Flatten Nested List Iterator",
        "content": "<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>\n\n<p>Implement the <code>NestedIterator</code> class:</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>\n\t<li><code>int next()</code> Returns the next integer in the nested list.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>\n</ul>\n\n<p>Your code will be tested with the following pseudocode:</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n</pre>\n\n<p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]\n<strong>Output:</strong> [1,1,2,1,1]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [1,[4,[6]]]\n<strong>Output:</strong> [1,4,6]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>The values of the integers in the nested list is in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>\n</ul>\n",
        "likes": 4968,
        "dislikes": 1776,
        "stats": "{\"totalAccepted\": \"490.7K\", \"totalSubmission\": \"752.1K\", \"totalAcceptedRaw\": 490740, \"totalSubmissionRaw\": 752101, \"acRate\": \"65.2%\"}",
        "similarQuestions": "[{\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Mini Parser\", \"titleSlug\": \"mini-parser\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Array Nesting\", \"titleSlug\": \"array-nesting\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Design"
          },
          {
            "name": "Queue"
          },
          {
            "name": "Iterator"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/flatten-nested-list-iterator/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "342",
        "questionFrontendId": "342",
        "title": "Power of Four",
        "content": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of four. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of four, if there exists an integer <code>x</code> such that <code>n == 4<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 5\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "likes": 4029,
        "dislikes": 402,
        "stats": "{\"totalAccepted\": \"784K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 783954, \"totalSubmissionRaw\": 1593034, \"acRate\": \"49.2%\"}",
        "similarQuestions": "[{\"title\": \"Power of Two\", \"titleSlug\": \"power-of-two\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Power of Three\", \"titleSlug\": \"power-of-three\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/power-of-four/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "343",
        "questionFrontendId": "343",
        "title": "Integer Break",
        "content": "<p>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p>\n\n<p>Return <em>the maximum product you can get</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 2 = 1 + 1, 1 &times; 1 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 36\n<strong>Explanation:</strong> 10 = 3 + 3 + 4, 3 &times; 3 &times; 4 = 36.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 58</code></li>\n</ul>\n",
        "likes": 5230,
        "dislikes": 456,
        "stats": "{\"totalAccepted\": \"390.9K\", \"totalSubmission\": \"640.9K\", \"totalAcceptedRaw\": 390941, \"totalSubmissionRaw\": 640949, \"acRate\": \"61.0%\"}",
        "similarQuestions": "[{\"title\": \"Maximize Number of Nice Divisors\", \"titleSlug\": \"maximize-number-of-nice-divisors\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "There is a simple O(n) solution to this problem.",
          "You may check the breaking results of <i>n</i> ranging from 7 to 10 to discover the regularities."
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/integer-break/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "344",
        "questionFrontendId": "344",
        "title": "Reverse String",
        "content": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>\n\n<p>You must do this by modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> with <code>O(1)</code> extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>Output:</strong> [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>Output:</strong> [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii character</a>.</li>\n</ul>\n",
        "likes": 8946,
        "dislikes": 1191,
        "stats": "{\"totalAccepted\": \"3.1M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 3119076, \"totalSubmissionRaw\": 3919199, \"acRate\": \"79.6%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Vowels of a String\", \"titleSlug\": \"reverse-vowels-of-a-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Reverse String II\", \"titleSlug\": \"reverse-string-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "The entire logic for reversing a string is based on using the opposite directional two-pointer approach!"
        ],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "345",
        "questionFrontendId": "345",
        "title": "Reverse Vowels of a String",
        "content": "<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>\n\n<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;IceCreAm&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;AceCreIm&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The vowels in <code>s</code> are <code>[&#39;I&#39;, &#39;e&#39;, &#39;e&#39;, &#39;A&#39;]</code>. On reversing the vowels, s becomes <code>&quot;AceCreIm&quot;</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;leetcode&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;leotcede&quot;</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of <strong>printable ASCII</strong> characters.</li>\n</ul>\n",
        "likes": 4913,
        "dislikes": 2829,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 1227327, \"totalSubmissionRaw\": 2135090, \"acRate\": \"57.5%\"}",
        "similarQuestions": "[{\"title\": \"Reverse String\", \"titleSlug\": \"reverse-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Vowels from a String\", \"titleSlug\": \"remove-vowels-from-a-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Faulty Keyboard\", \"titleSlug\": \"faulty-keyboard\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sort Vowels in a String\", \"titleSlug\": \"sort-vowels-in-a-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "346",
        "questionFrontendId": "346",
        "title": "Moving Average from Data Stream",
        "content": null,
        "likes": 1713,
        "dislikes": 187,
        "stats": "{\"totalAccepted\": \"474.3K\", \"totalSubmission\": \"594.6K\", \"totalAcceptedRaw\": 474283, \"totalSubmissionRaw\": 594620, \"acRate\": \"79.8%\"}",
        "similarQuestions": "[{\"title\": \"K Radius Subarray Averages\", \"titleSlug\": \"k-radius-subarray-averages\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Design"
          },
          {
            "name": "Queue"
          },
          {
            "name": "Data Stream"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/moving-average-from-data-stream/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "347",
        "questionFrontendId": "347",
        "title": "Top K Frequent Elements",
        "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2\n<strong>Output:</strong> [1,2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Your algorithm&#39;s time complexity must be better than <code>O(n log n)</code>, where n is the array&#39;s size.</p>\n",
        "likes": 18167,
        "dislikes": 717,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 2734809, \"totalSubmissionRaw\": 4255648, \"acRate\": \"64.3%\"}",
        "similarQuestions": "[{\"title\": \"Word Frequency\", \"titleSlug\": \"word-frequency\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Kth Largest Element in an Array\", \"titleSlug\": \"kth-largest-element-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sort Characters By Frequency\", \"titleSlug\": \"sort-characters-by-frequency\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Split Array into Consecutive Subsequences\", \"titleSlug\": \"split-array-into-consecutive-subsequences\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Top K Frequent Words\", \"titleSlug\": \"top-k-frequent-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"K Closest Points to Origin\", \"titleSlug\": \"k-closest-points-to-origin\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sort Features by Popularity\", \"titleSlug\": \"sort-features-by-popularity\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sender With Largest Word Count\", \"titleSlug\": \"sender-with-largest-word-count\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Most Frequent Even Element\", \"titleSlug\": \"most-frequent-even-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Linked List Frequency\", \"titleSlug\": \"linked-list-frequency\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Bucket Sort"
          },
          {
            "name": "Counting"
          },
          {
            "name": "Quickselect"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Heap\n\nLet's start from the simple [heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) approach with $$\\mathcal{O}(N \\log k)$$ time complexity. To ensure that $$\\mathcal{O}(N \\log k)$$ is always less than $$\\mathcal{O}(N \\log N)$$, the particular case $$k = N$$ could be considered separately and solved in $$\\mathcal{O}(N)$$ time. \n\n**Algorithm**\n\n- The first step is to build a hash map `element -> its frequency`. In Java, we use the data structure `HashMap`. Python provides a dictionary subclass `Counter` to initialize the hash map we need directly from the input array. This step takes $$\\mathcal{O}(N)$$ time where `N` is a number of elements in the list.\n\n- The second step is to build a heap of _size k using N elements_. To add the first `k` elements takes a linear time $$\\mathcal{O}(k)$$ in the average case, and $O(\\log 1 + \\log 2 + ... + \\log k) = O(log k!) = \\mathcal{O}(k \\log k)$ in the worst case. It's equivalent to [heapify implementation in Python](https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l16). After the first `k` elements we start to push and pop at each step, `N - k` steps in total. The time complexity of heap push/pop is $$\\mathcal{O}(\\log k)$$ and we do it `N - k` times which means $$\\mathcal{O}((N - k)\\log k)$$ time complexity. Adding both parts up, we get $$\\mathcal{O}(N \\log k)$$ time complexity for the second step.\n\n- The third and last step is to convert the heap into an output array. That could be done in $$\\mathcal{O}(k \\log k)$$ time.\n \nIn Python, library `heapq` provides a method `nlargest`, which [combines the last two steps under the hood](https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l203) and has the same $$\\mathcal{O}(N \\log k)$$ time complexity.\n\n![diff](../Figures/347_rewrite/summary.png)\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/JLvuc8ZH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"JLvuc8ZH\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N \\log k)$$ if $$k < N$$ and $$\\mathcal{O}(N)$$ in the particular case of $$N = k$$. That ensures time complexity to be better than $$\\mathcal{O}(N \\log N)$$.\n\n* Space complexity : $$\\mathcal{O}(N + k)$$ to store the hash map with not more $$N$$ elements and a heap with $$k$$ elements.\n<br />\n<br />\n\n\n---\n\n### Approach 2: Quickselect (Hoare's selection algorithm)\n\nQuickselect is a [textbook algorithm](https://en.wikipedia.org/wiki/Quickselect) typically used to solve the problems \"find `k`*th* something\": `k`*th* smallest, `k`*th* largest, `k`*th* most frequent, `k`*th* less frequent, etc. Like quicksort, quickselect was developed by [Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare) and is also known as _Hoare's selection algorithm_.\n\nIt has $$\\mathcal{O}(N)$$ _average_ time complexity and is widely used in practice. It is worth noting that its worst-case time complexity is $$\\mathcal{O}(N^2)$$, although the probability of this worst-case is negligible.\n\nThe approach is the same as for quicksort.\n\n> One chooses a pivot and defines its position in a sorted array in a linear time using the so-called _partition algorithm_. \n\nAs an output, we have an array where the pivot is in its perfect position in the ascending sorted array, sorted by the frequency. All elements on the left of the pivot are less frequent than the pivot, and all elements on the right are more frequent or have the same frequency.\n\nHence the array is now split into two parts. If by chance our pivot element took `N - k`*th* final position, then $$k$$ elements on the right are these top $$k$$ frequent we're looking for. If not, we can choose one more pivot and place it in its perfect position.\n\n![diff](../Figures/347_rewrite/hoare.png)\n\nIf that were a quicksort algorithm, one would have to process both parts of the array. That would result in $$\\mathcal{O}(N \\log N)$$ time complexity. In this case, there is no need to deal with both parts since one knows in which part to search for `N - k`*th* less frequent element, and that reduces the average time complexity to $$\\mathcal{O}(N)$$.\n\n**Algorithm**\n\nThe algorithm is quite straightforward :\n\n* Build a hash map `element -> its frequency` and convert its keys into the array `unique` of unique elements. Note that elements are unique, but their frequencies are _not_. That means we need a partition algorithm that works fine with _duplicates_. \n\n* Work with `unique` array. \nUse a partition scheme (please check the next section) to place the pivot into its perfect position `pivot_index` in the sorted array, move less frequent elements to the left of the pivot, and more frequent or of the same frequency - to the right.\n\n* Compare `pivot_index` and `N - k`.\n \n    - If `pivot_index == N - k`, the pivot is `N - k`*th* most frequent element, and all elements on the right are more frequent or of the same frequency. Return these top $$k$$ frequent elements.\n    \n    - Otherwise, choose the side of the array to proceed recursively.\n    \n![diff](../Figures/347_rewrite/details.png)\n\n**Lomuto's Partition Scheme**\n\nThere is a zoo of partition algorithms. The most simple one is [Lomuto's Partition Scheme](https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme), and so is what we will use in this article.\n\nHere is how it works:\n\n- Move the pivot at the end of the array using swap. \n\n- Set the pointer at the beginning of the array `store_index = left`.\n    \n- Iterate over the array and move all less frequent elements to the left `swap(store_index, i)`. Move `store_index` one step to the right after each swap.\n\n- Move the pivot to its final place, and return this index.\n\n!?!../Documents/347_RES.json:1000,556!?!\n\n<iframe src=\"https://leetcode.com/playground/DsZt2xQy/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"DsZt2xQy\"></iframe>\n \n**Implementation**\n\nHere is a total algorithm implementation. \n\n<iframe src=\"https://leetcode.com/playground/auAMEKfN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"auAMEKfN\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ in the average case, \n    $$\\mathcal{O}(N^2)$$ in the worst case. [Please refer to this card for a good detailed explanation of Master Theorem](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2871/). Master Theorem helps to get an average complexity by writing the algorithm cost as $$T(N) = a T(N / b) + f(N)$$. Here we have an example of Master Theorem case III: $$T(N) = T \\left(\\frac{N}{2}\\right) + N$$, which results in $$\\mathcal{O}(N)$$ time complexity. That's the case with random pivots.\n    \n    In the worst case of constantly badly chosen pivots, the problem is not divided by half at each step, it becomes just one element less, which leads to $$\\mathcal{O}(N^2)$$ time complexity. It happens, for example, if at each step you choose the pivot not randomly, but take the rightmost element. For the random pivot choice, the probability of having such a worst-case is negligibly small. \n\n* Space complexity: up to $$\\mathcal{O}(N)$$ to store hash map and array of unique elements.\n<br />\n<br />\n\n\n---\n### Further Discussion: Could We Do Worst-Case Linear Time? \n\nIn theory, we could, the algorithm is called [Median of Medians](https://en.wikipedia.org/wiki/Median_of_medians).\n\nThis method is never used in practice because of two drawbacks:\n\n- It's _outperformer_. Yes, it works in a linear time $$\\alpha N$$, but the constant $$\\alpha$$ is so large that in practice it often works even slower than $$N^2$$.  \n\n- It doesn't work with duplicates.\n<br />\n<br />\n\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/top-k-frequent-elements/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "348",
        "questionFrontendId": "348",
        "title": "Design Tic-Tac-Toe",
        "content": null,
        "likes": 2120,
        "dislikes": 118,
        "stats": "{\"totalAccepted\": \"280.2K\", \"totalSubmission\": \"478.8K\", \"totalAcceptedRaw\": 280153, \"totalSubmissionRaw\": 478842, \"acRate\": \"58.5%\"}",
        "similarQuestions": "[{\"title\": \"Valid Tic-Tac-Toe State\", \"titleSlug\": \"valid-tic-tac-toe-state\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Could you trade extra space such that <code>move()</code> operation can be done in O(1)?",
          "You need two arrays: int rows[n], int cols[n], plus two variables: diagonal, anti_diagonal."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Design"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/design-tic-tac-toe/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "349",
        "questionFrontendId": "349",
        "title": "Intersection of Two Arrays",
        "content": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their <span data-keyword=\"array-intersection\">intersection</span></em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [9,4]\n<strong>Explanation:</strong> [4,9] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 6399,
        "dislikes": 2319,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1476803, \"totalSubmissionRaw\": 1938594, \"acRate\": \"76.2%\"}",
        "similarQuestions": "[{\"title\": \"Intersection of Two Arrays II\", \"titleSlug\": \"intersection-of-two-arrays-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Intersection of Three Sorted Arrays\", \"titleSlug\": \"intersection-of-three-sorted-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Difference of Two Arrays\", \"titleSlug\": \"find-the-difference-of-two-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Common Words With One Occurrence\", \"titleSlug\": \"count-common-words-with-one-occurrence\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Choose Numbers From Two Arrays in Range\", \"titleSlug\": \"choose-numbers-from-two-arrays-in-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Intersection of Multiple Arrays\", \"titleSlug\": \"intersection-of-multiple-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Common Value\", \"titleSlug\": \"minimum-common-value\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Size of a Set After Removals\", \"titleSlug\": \"maximum-size-of-a-set-after-removals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Sorting and Two Pointers\n\n#### Intuition\n\nIf `nums1` and `nums2` are sorted, we can use a two pointers approach to find elements that appear in both arrays. Initialize one pointer for each array that starts at the smallest element. \n\nIf the numbers at both pointers are the same, add the number to a set that stores integers that appear in both arrays. Then, increase both pointers by $1$, since this element is already processed.  \n\nOtherwise, if the numbers at both pointers are not equal, the smaller of the two values cannot appear in the other array because both arrays are sorted. Therefore, we can increase the pointer of the smaller value.\n\n#### Algorithm\n\n1. Sort `nums1` and `nums2` arrays.\n2. Create a pointer for each array, initially set to $0$.\n3. Initialize an empty set that stores intersecting integers.\n4. If the integers at both pointers equal the same value, add this value to the intersecting set and increment both pointers.\n5. Otherwise, increment the pointer that points to the smaller integer value.\n6. Repeat steps 4 and 5 until a pointer is out of bounds.\n7. Convert the intersection set into an array.\n8. Return the resulting array.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/esWGp92Z/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"esWGp92Z\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(n \\log n + m \\log m)$, where $n$ and $m$ are the arrays' lengths. This dominating term comes from the need to sort both input arrays at the beginning of the solution.\n \n* Space complexity: $O(\\min(m, n))$ in the worst case when all elements in the smaller array are unique and present in the larger array. This space is necessary to store elements in the set `intersection`.  \n\n    - The space used to store the result array is counted in the space complexity, making the worst case $O(\\min(m, n))$.  \n    - Some extra space is used when sorting the arrays in place, and the space complexity depends on the programming language:  \n        - In Python, the `sort()` method uses the Timsort algorithm, which requires O(n) additional space in the worst case.  \n        - In Java, `Arrays.sort()` for primitive types uses a Dual-Pivot QuickSort, which has a worst-case space complexity of O(\\log n) due to recursion.  \n\n---\n\n### Approach 2: Built-in Set Intersection\n\n#### Intuition\n\nThere are built-in intersection facilities, which provide $O(n + m)$ time complexity in the average case and $O(n \\times m)$ time complexity in the worst case. \n\n> In Python it's the [intersection operator](https://wiki.python.org/moin/TimeComplexity#set), and in Java it's the [retainAll() function](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html#retainAll-java.util.Collection-).\n\n#### Algorithm\n\n1. Initialize a set `set1` and add all elements of `nums1` to it.\n2. Initialize a set `set2` and add all elements of `nums2` to it.\n3. Call the built-in set intersection method (either `retainAll()` in Java, or `&` operator in Python).\n4. Transform the resulting set into an array and return this result.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/C2TF5Yk6/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"C2TF5Yk6\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(n + m)$, where $n$ and $m$ are the arrays' lengths in the average case and $O(n \\times m)$ [in the worst case when the load factor is high enough](https://wiki.python.org/moin/TimeComplexity#set).\n \n* Space complexity: $O(m + n)$ because in the worst case, when all elements in the arrays are unique, $n$ space is used to store `set1` and $m$ space is used to store `set2`. The space used to store the result is not counted in the space complexity.\n\n---\n\n### Approach 3: Two Sets\n\n#### Intuition\n\nThe naive approach would be to iterate through the values in the first array, `nums1`, and check whether each one is in `nums2`. If yes, add the value to the output. Such an approach would result in a less efficient solution.\n\n> To solve the problem in linear time, let's use the data structure `set`, which provides `in/contains` operations in $O(1)$ time in the average case.\n\nThe idea is to convert both arrays into sets and then iterate over the smallest set while checking the presence of each element in the larger set.\n\n!?!../Documents/349_LIS.json:1000,352!?!\n\n#### Algorithm\n\n1. Initialize a set `set1` and add all elements of `nums1` to it.\n2. Initialize a set `set2` and add all elements of `nums2` to it.\n3. If `set1` has more elements than `set2`, swap them.\n4. For each element in `set1`, add it to the result array if it also appears in `set2`.\n5. Result the result array.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/RAoCNPwG/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"RAoCNPwG\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(n + m)$, where $n$ and $m$ are the arrays' lengths. $O(n)$ time is used to convert `nums1` into a set, $O(m)$ time is used to convert `nums2`, and `contains/in` operations are $O(1)$ in the average case.\n \n* Space complexity: $O(m + n)$ because in the worst case, when all elements in the arrays are unique, $n$ space is used to store `set1` and $m$ space is used to store `set2`.\n\n---\n\n### Approach 4: One Dictionary\n\n#### Intuition\n\nThis approach uses only one additional data structure and one pass through each of `nums1` and `nums2`. The idea is to use a dictionary/map rather than a set to store information about values that appear in each array. \n\nDefine this dictionary as `seen`, where the key is an element that exists in one or both input arrays, and the value stores either $0$ or $1$. A number `x` appears as a key in this dictionary, indicating it is present in at least one array, and the value of the key indicates if `x` has been observed in both arrays and added to the `result` array.\n\n#### Algorithm\n\n1. Initialize a dictionary/map `seen` and the `result` array.\n2. For each `x` in `nums1`, set `seen[x]` to $1$.\n3. For each `x` in `nums2`, add `x` to `result` if `seen[x]` equals $1$. Then, set `seen[x]` to $0$, as this element has already been included in the result.\n4. Result the result array.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/6m6gWp2U/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"6m6gWp2U\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums1` and $m$ be the length of `nums2`.\n\n* Time complexity: $O(n + m)$ in the average case and $O(n \\times m)$ [in the worst case when the load factor is high enough](https://wiki.python.org/moin/TimeComplexity#set).\n \n* Space complexity: $O(n)$ because we use a map of size $n$ store the elements from `nums1`. The `result` array is just used to store the result, so it is not counted in the space complexity.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/intersection-of-two-arrays/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "350",
        "questionFrontendId": "350",
        "title": "Intersection of Two Arrays II",
        "content": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [4,9]\n<strong>Explanation:</strong> [9,4] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n\t<li>What if <code>nums1</code>&#39;s size is small compared to <code>nums2</code>&#39;s size? Which algorithm is better?</li>\n\t<li>What if elements of <code>nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n",
        "likes": 7879,
        "dislikes": 989,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 1527477, \"totalSubmissionRaw\": 2591324, \"acRate\": \"58.9%\"}",
        "similarQuestions": "[{\"title\": \"Intersection of Two Arrays\", \"titleSlug\": \"intersection-of-two-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Common Characters\", \"titleSlug\": \"find-common-characters\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Difference of Two Arrays\", \"titleSlug\": \"find-the-difference-of-two-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Choose Numbers From Two Arrays in Range\", \"titleSlug\": \"choose-numbers-from-two-arrays-in-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Intersection of Multiple Arrays\", \"titleSlug\": \"intersection-of-multiple-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Common Value\", \"titleSlug\": \"minimum-common-value\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "351",
        "questionFrontendId": "351",
        "title": "Android Unlock Patterns",
        "content": null,
        "likes": 198,
        "dislikes": 228,
        "stats": "{\"totalAccepted\": \"80K\", \"totalSubmission\": \"150.2K\", \"totalAcceptedRaw\": 79962, \"totalSubmissionRaw\": 150172, \"acRate\": \"53.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Bitmask"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nMost Android phones feature a security mechanism known as a lock pattern. It is a $3 \\times 3$ grid of dots, where unmarked dots can be connected consecutively to create a pattern. More formally, from any dot in the grid, we can make 2 types of moves:\n\n1. Single-step move: This involves connecting two dots directly.\n\n![simple moves in dot grid](../Figures/351/simple_moves.png)\n\n2. Skip move: This allows us to skip over exactly one dot to connect two non-neighboring dots, but only when the dot in between has already been marked.\n\n![skip moves in dot grid](../Figures/351/skip_moves.png)\n\n**Key Observations:**\n1. From any given dot on the grid, all other dots are accessible through either a single-step move or a skip move.\n2. No dot in the pattern may be visited twice, unless it is being passed over to connect two non-neighboring dots.\n\nGiven two integers, `m` and `n`, our task is to calculate the total number of possible patterns that can be formed using these moves, with the constraint that the pattern must include at least `m` dots and at most `n` dots.\n    \n---\n\n### Approach 1: Backtracking\n\n#### Intuition\n\nOne approach to solving this problem involves generating all possible patterns and counting those that meet our specified conditions. Let's explore this method with a slight optimization.\n\nFirst, we'll create two arrays to represent each type of possible move: `SINGLE_STEP_MOVES` and `SKIP_DOT_MOVES`.\n\nTo find each pattern, we'll employ a recursive function `countPatternsFromDot` which explores all possible moves from the current dot under examination. We'll keep track of the dots explored at each step and start counting once the number of dots exceeds `m`. The recursion will continue until the current pattern reaches `n` dots, at which point it terminates. This function will successfully return all possible patterns from any given starting point. \n\nHowever, we can often predict whether a path will yield a satisfactory pattern well before reaching its end. For instance, if at any point in the pattern's development, all potential next moves violate the rules, we can conclude that any patterns stemming from this state will be invalid. At any step, if we determine that the current path will not lead to a valid solution, we can abandon it and return to a previous step that still shows promise. This technique, known as backtracking, helps optimize our approach. If you're unfamiliar with it, consider reviewing this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) for a detailed explanation.\n\nSince a valid pattern can start from any dot, we'll call `countPatternsFromDot` for each of the nine dots and aggregate the results. This total count represents the required number of unlock patterns.\n\n#### Algorithm\n\n- Define constants:\n  - `SINGLE_STEP_MOVES`: All possible adjacent and diagonal moves.\n  - `SKIP_DOT_MOVES`: Moves that jump over a dot, requiring the middle dot to be visited.\n\nMain method `numberOfPatterns`:\n\n- Initialize a counter `totalPatterns` to accumulate our result.\n- Iterate through all 9 dots on the grid:\n  - For each dot, call `countPatternsFromDot` and add it to `totalPatterns`.\n- Return `totalPatterns`.\n\nHelper method `countPatternsFromDot`:\n\n- Define a method `countPatternsFromDot` with parameters: `m`, `n`, `currentLength`, `currentRow`, `currentCol` and a boolean matrix `visitedDots`.\n- If `currentLength` exceeds `n`, return `0`.\n- Initialize a variable `validPatterns` to count the number of patterns.\n- If `currentLength` is greater than `m`, increment `validPatterns`.\n- Mark the current dot as visited in `visitedDots`.\n- Explore all `SINGLE_STEP_MOVES`:\n  - For each `move`, check if it's valid using `isValidMove`.\n  - If valid, recursively count patterns from the new position.\n- Explore all `SKIP_DOT_MOVES`:\n  - For each `move`, check if it's valid using `isValidMove`.\n  - Find `middleRow` as `currentRow + move[0] / 2` and `middleCol` as `currentCol + move[1] / 2`.\n  - If the middle point is visited, recursively count patterns from the new position.\n- To backtrack, un-mark the current dot in `visitedDots`.\n- Return `validPatterns`.\n\nHelper method `isValidMove`:\n\n- Define a method `isValidMove` with parameters: `row`, `col` and `visitedDots`.\n- Return `true` if `(row, col)` is within the grid and hasn't been visited. \n\n> Note: For reference, the possible directions for traversal from any given cell are:\n> ![directions in a grid](../Figures/351/directions.png)\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ATTrKNuh/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ATTrKNuh\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the maximum numbers of keys allowed in the pattern.\n\n- Time complexity: $O(9 \\cdot 8^n)$\n\n    The method `numberOfPatterns` iterates through all $9$ dots on the grid as a starting point. \n\n    In each call to `countPatternsFromDot`, the function explores all possible moves from the current dot. Let $8$ be the approximate number of choices at each dot. In the worst-case scenario, each recursive call leads to further recursive calls, up to a maximum depth of $n$. Thus, the total number of patterns explored can be approximated by $9 \\times 8^n$ (each move branching out into multiple further moves).\n\n    Thus, the overall time complexity of the algorithm is $O(9 \\cdot 8^n)$.\n\n- Space complexity: $O(n)$\n    \n    The arrays `SINGLE_STEP_MOVES` and `SKIP_DOT_MOVES` use constant space.\n\n    The `visitedDots` matrix is a $3 \\times 3$ boolean array, which takes up constant space.\n\n    The maximum depth of the recursion stack is $n$.\n\n    Thus, the overall space complexity of the algorithm is $O(n)$.\n---\n\n### Approach 2: Backtracking (Optimized)\n\n#### Intuition\n\nA major inconvenience in the previous approach was hardcoding each possible move from a dot. Instead of physically creating a grid and traversing it, notice that we can reach all other dots from each dot, albeit some of those moves are skip moves. So, let's eliminate the arrays of moves, and instead maintain a matrix called `jump`. This matrix will track which moves require a jump and over which dot. For instance, moving from dot `2` to dot `8` necessitates jumping over dot `5`, so we'll set `jump[2][8]` to `5`.\n\nAnother crucial observation is that when we iterate over all numbers in `numberOfPatterns` to find the total number of moves starting with each number, we're performing redundant calculations. Check out the image below:\n\n![image to show symmetry](../Figures/351/symmetry.png)\n\nWe can see that the positions (2, 4, 6, 8) are symmetrical, yielding the same number of total patterns. The same concept applies to the corner points (1, 3, 7, 9). Consequently, we can replace the nine calls to `countPatternsFromDot` with three calls:\n\n1. A call for the corner points (1, 3, 7, 9).\n2. A call for the edge points (2, 4, 6, 8).\n3. A call for the center point (5).\n\n#### Algorithm\n\nMain method `numberOfPatterns`:\n \n- Initialize a 2D array `jump` to store numbers that need to be jumped over for valid moves.\n- Populate `jump` array with valid jump-over numbers. Each `jump[i][j]` contains the number needed to be jumped over to reach `j` from `i`.\n- Create a boolean array `visitedNumbers` to track visited numbers.\n- Initialize `totalPatterns` to store the count of valid patterns.\n- Call `countPatternsFromNumber` for corner numbers (1, 3, 7, 9) and multiply by `4` due to symmetry. Add it to `totalPatterns`.\n- Call `countPatternsFromNumber` for edge numbers (2, 4, 6, 8) and multiply by `4` due to symmetry. Add it to `totalPatterns`.\n- Call `countPatternsFromNumber` for the final time to account for the center(5). Add it to `totalPatterns`.\n- Return `totalPatterns`.\n\nHelper method `countPatternsFromDot`:\n\n- If `currentLength` exceeds `maxLength`, return `0`.\n- Initialize a variable `validPatterns` to count the total number of patterns for the current configuration.\n- If `currentLength` is greater than `minLength`, increment `validPatterns`.\n- Mark `visitedNumbers[currentNumber]` as `true`.\n- For each possible `nextNumber` from 1 to 9:\n  - Calculate `jumpOverNumber` from the `jump` matrix.\n  - If `nextNumber` has not been visited yet and either `jumpOverNumber` is `0` or `jumpOverNumber` is visited:\n    - Recursively call `countPatternsFromDot` from `nextNumber` and add it to `validPatterns`.\n- To backtrack, un-mark `currentNumber` from the `visitedNumbers` array.\n- Return `validPatterns`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/E55hUUCe/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"E55hUUCe\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the maximum number of keys allowed in the pattern.  \n\n* Time complexity: $O(3 \\cdot 8^n)$\n\n    The algorithm calls the recursive function `countPatternsFromNumber` a total of 3 times. Each recursive call explores approximately 8 surrounding dots in each call. In the worst case, each recursive call can spread up to a maximum depth of $n$ with a branching factor of $8$. Thus, the total time complexity of the algorithm comes out to be $O(3 \\cdot 8^n)$.\n\n* Space complexity: $O(n)$\n\n    The `jump` array is a $10 \\times 10$ grid which takes constant space. The maximum depth of recursion can be $n$ in the worst case. Thus, the overall space complexity is $O(n)$.\n\n---\n\n### Approach 3: Memoization\n\n#### Intuition\n\nAs we recursively construct each pattern, we often encounter sub-problems that we've previously solved. For example, in the sequences [7, 8, 5] and [8, 7, 5], the number of patterns emerging from 5 will be identical in both cases, as it depends solely on the current number and the dots visited thus far. To avoid repeatedly calculating these overlapping sub-problems, we can significantly improve our time complexity by optimizing our algorithm.\n\nThis is where [dynamic programming](https://leetcode.com/explore/learn/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035/) comes in. The essence of dynamic programming is to save (memoize) the results of previously computed sub-problems, so that if we encounter the same sub-problem again, we can directly return the saved result instead of recalculating it. But how do we uniquely identify a sub-problem? The answer lies in its state. Each recursive state is defined by two factors: the current number from which the pattern emerges, and the dots visited up to that point. This state uniquely identifies each sub-problem, allowing us to store the result in a `dp` table using this state as the identifier.\n\nHowever, storing all visited numbers in a boolean array is cumbersome to use as an identifier. We need something simpler, like an integer value. Considering the constraints of the problem, the maximum number of dots possible is 9. We can use a 9-digit binary number, where each digit can be a 0 or a 1, to represent whether a number has been visited (1) or not (0). This 9-digit binary number effectively replaces the `visitedNumbers` array, allowing us to memoize the recursion results in a `dp` table of size $10 \\times (1<<10)$.\n\nTo manipulate this new `visitedNumbers` integer, we need three essential functions:\n\n1. `setBit`: Toggles the `i`th bit of the number to `1`.\n2. `clearBit`: Toggles the `i`th bit of the number to `0`.\n3. `isSet`: Checks whether the `i`th bit is `0` or `1`.\n\nFor more information on bit manipulation concepts, you can refer to this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/bit-manipulation/669/bit-manipulation-concepts/4496/).\n\n#### Algorithm\n\nMain method `numberOfPatterns`:\n \n- Initialize a 2D array `jump` to store numbers that need to be jumped over for valid moves.\n- Populate `jump` array such that `jump[i][j]` stores the number needed to be jumped over to get to `j` from `i`.\n- Initialize variables:\n  - `visitedNumbers` to `0` for tracking visited numbers.\n  - `totalPatterns` to store the count of valid patterns.\n- Create a 2D array 'dp' of size $10 \\times (1 << 10)$ for memoization.\n- Call `countPatternsFromNumber` for the corner numbers (1, 3, 7, 9) and multiply by 4 due to symmetry. Add it to `totalPatterns`.\n- Call `countPatternsFromNumber` for the edge numbers (2, 4, 6, 8) and multiply by 4 due to symmetry. Add it to `totalPatterns`.\n- Call `countPatternsFromNumber` a final time for the center (5). Add it to `totalPatterns`.\n- Return `totalPatterns` as our answer.\n\nHelper method `countPatternsFromNumber`:\n\n- Define a method `countPatternsFromNumber` with parameters: `currentNumber`, `currentLength`, `minLength`, `maxLength`, the `jump` array, `visitedNumbers`, and the `dp` matrix.\n- If `currentLength` exceeds `maxLength`, return `0`;\n- If the result for the current state `(currentNumber, visitedNumbers)` is in `dp`, return it.\n- Create a variable `validPatterns` to store the total patterns for the current combination.\n- If `currentLength` is greater than `minLength`, increment `validPatterns`.\n- Use `setBit` to mark `currentNumber` as visited in `visitedNumbers`.\n- For each `nextNumber` from `1` to `9`:\n  - Set `jumpOverNumber` as `jump[currentNumber][nextNumber]`.\n  - Check if it's unvisited and either `jumpOverNumber` is `0` or the `jumpOverNumber` is visited:\n    - If so, recursively count patterns for `nextNumber` and add them to `validPatterns`.\n- Backtrack by un-marking `currentNumber` from `visitedNumbers`.\n- Store `visitedNumbers` as the result for the current state in `dp` for the current state.\n- Return `visitedNumbers`.\n\nHelper method `setBit`:\n- Define a method `setBit` with parameters: `num` and `position`.\n- Left shift `1` by `(position-1)` places. Bitwise OR the result with `num`.\n- Return `num`. \n\nHelper method `clearBit`:\n- Define a method `clearBit` with parameters: `num` and `position`.\n- Left shift `1` by `(position-1)` places. Bitwise XOR the result with `num`.\n- Return `num`. \n\nHelper method `isSet`:\n- Define a method `isSet` with parameters: `num` and `position`.\n- Find the `bitAtPosition` by right shifting `num` by `(position-1)` places and bitwise AND'ing with `1`.\n- Return `true` if `bitAtPosition` is `1`. Else return `false`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/VjHqLpnk/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VjHqLpnk\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the maximum numbers of keys allowed in the pattern.\n\n* Time complexity: $O(1)$\n\n    Due to memoization, the time complexity of the algorithm is bounded by the total time required to fill the `dp` array. The total size of `dp` is $10 \\times (1 << 10)$ or $10240$. So, the overall time complexity of the algorithm is $O(10240)$, which can be simplified to $O(1)$.\n\n* Space complexity: $O(n)$\n\n    The `jump` array and the `dp` array both use constant space irrelevant of the input. The recursion stack has a space complexity of $O(n)$. Thus, the space complexity of the algorithm is $O(n)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/android-unlock-patterns/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "352",
        "questionFrontendId": "352",
        "title": "Data Stream as Disjoint Intervals",
        "content": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>\n",
        "likes": 1769,
        "dislikes": 367,
        "stats": "{\"totalAccepted\": \"117.7K\", \"totalSubmission\": \"195.1K\", \"totalAcceptedRaw\": 117728, \"totalSubmissionRaw\": 195065, \"acRate\": \"60.4%\"}",
        "similarQuestions": "[{\"title\": \"Summary Ranges\", \"titleSlug\": \"summary-ranges\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Right Interval\", \"titleSlug\": \"find-right-interval\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Integers in Intervals\", \"titleSlug\": \"count-integers-in-intervals\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Binary Search"
          },
          {
            "name": "Design"
          },
          {
            "name": "Ordered Set"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n--- \n\n\n### Approach 1: Save all values in an ordered set\n\n#### Intuition\n\nThe question asks to combine consecutive values into intervals, namely, if we have values of 1, 2, 3, and 4, we can make an interval that starts from 1 and ends at 4. If the data is sorted, we can easily iterate over it to find the intervals. A data structure is needed that allows us to insert elements while maintaining sorted order, otherwise we would need to sort the data every time we call `getIntervals`, which is expensive.\n\nJava's TreeSet can do the work. The reason to use a TreeSet is that we can iterate on the values in it in the increasing order and elements can be added in $O(\\log{}n)$. In Python we can use SortedList and in C++ we can use the standard library's set. To find the intervals, we can look at each value and check whether it is adjacent to the previous one. If it is, we can build an interval, otherwise we need to start a new one.\n\n#### Algorithm\n\nInitialize a TreeSet equivalent data structure `values`.\n\n\n##### addNum(int value)\nSimply add `value` into `values`. If your language's TreeSet equivalent allows duplicate values like Python's SortedList, you will also need to check that `value` does not already exist in `values` as duplicates will break the algorithm.\n\n##### getIntervals\n\n\n* If `values` is empty, return an empty array.\n* Create an empty list of intervals.\n* Set `left = right = -1`. `left` represents the left bound of the current interval and `right` represents the right bound.\n* Iterate over `values`. At each iteration:\n   *  If `left < 0` set `left = right = value` \n   *  else if `value = right + 1`, set `right = value` as we can continue the current interval.\n   *  else, we cannot continue the current interval. Insert `[left, right]` into `intervals` and set `left = right = value` to start a new one.\n* Insert `[left, right]` into `intervals` and return `intervals`\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/GQnYWXuW/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GQnYWXuW\"></iframe>\n\n\n#### Complexity Analysis\n\nHere, $N$ is the total number of calls of `addNum`.\n\n* Time complexity: $O(log(N))$ for addNum, $O(N)$ for getIntervals.\n\n  For `addNum`, we insert a value into the TreeSet which takes $O(log(N))$ time.\n  For `getIntervals`, we iterate all the values in the TreeSet which is the same as traversing the whole tree, so the time complexity is $O(N)$.\n\n* Space complexity: $O(N)$.\n\n  This is just the space to save all the values in the TreeSet.\n\n\n### Approach 2: Maintain all the intervals in ordered map\n\n#### Intuition\nInstead of storing the values and then building the intervals every time we call `getIntervals`, we can just store the intervals themselves and update them every time we add a number.\n\nIn Java, we can maintain a TreeMap in which each entry represents an interval. The key and value are the left and right bounds of an interval. We still want to maintain the intervals in sorted order so that when we add a number, we can easily find the interval a number is close to and perform merges if necessary. `getIntervals` then returns all the entries in the TreeMap. In Python, SortedDict can be used. In C++, STL map can be used.\n\n\nWhen we insert a `value`, there are 3 non-trivial cases (in all cases, blue represents existing intervals, red is the number being added, and cyan is the result after our operations):\n\n1. There is an interval with a right bound of `value - 1`.\nIn this case, we need to merge the this interval and the `value`, namely change the the interval's right bound into `value`.\n\n<center>\n<img src=\"../Figures/352/352_Data_Stream_as_Disjoint_Intervals_2.png\" width=\"500\"/>\n</center>\n<br>\n\n\n2. There is an interval with a left bound of `value + 1`.\nIn this case, we need to merge this interval and the `value`, namely change the interval's left bound into `value`.\n\n<center>\n<img src=\"../Figures/352/352_Data_Stream_as_Disjoint_Intervals_1.png\" width=\"500\"/>\n</center>\n<br>\n\n3. Both condition 1 and 2 are satisfied.\nThis is the combination of the previous 2 cases. We should make a new interval which \"connects\" the two intervals and replace them with the new one.\n\n<center>\n<img src=\"../Figures/352/352_Data_Stream_as_Disjoint_Intervals_3.png\" width=\"500\"/>\n</center>\n<br>\n\nTo be complete, there are 2 trivial cases as well:\n\n1. The `value` is already in the existing intervals.\nWe do nothing.\n\n2. All other cases.\nWe need to insert a new interval [`value`, `value`].\n\n\n#### Algorithm\n\nInitialize a TreeMap equivalent data structure `intervals`.\n\n\n##### addNum(int value)\n* Set `left = right = value`. These variables will represent the bounds of a new interval to be created.\n* Let `smallEntry` be the entry with the greatest key (left bound) no larger than `value` in `intervals`.\n* If `smallEntry` exists\n   * Let `previous` be the value (right bound) in `smallEntry`, if `previous >= value` then this is the first trivial case, so return. \n   * If `previous == value - 1`, set `left` to the key (left bound) in `smallEntry`. This is the first non trivial case, so we will prepare a merge.\n* Let `maxEntry` be the entry with the smallest key (left bound) larger than `value` in `intervals`.\n* If `maxEntry` exists and the key in it is `value + 1`, then this is the second non trivial case.\n  * Set `right` to the value in `maxEntry`.\n  * Remove the key `value + 1` from `intervals`.\n* Insert `[left, right]` into `intervals`. All cases are covered here. \n\n1. In the first case, we are updating the existing interval's entry since we set `left` to be that interval's key.\n2. In the second case, we removed the old interval and are now adding a new one with the `right` bound set to be the removed interval's old `right` bound and `left` updated to `value`.\n3. In the third case, we have done both of the above. We are replacing the interval on the left and deleting the interval on the right.\n4. For the 2nd trivial case, we didn't modify any intervals and `[left, right] = [value, value]`.\n\n\n\n##### getIntervals\nIterate over all the entries in `intervals` and return them in order.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/c7bDrXgu/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"c7bDrXgu\"></iframe>\n\n\n#### Complexity Analysis\n\nHere, $N$ is the total number of calls of `addNum`.\n\n* Time complexity: $O(log(N))$ for `addNum`, $O(N)$ for `getIntervals`.\n\n  For `addNum`, in the worst case, we remove 2 entries from the TreeMap and add 1 entry, the time complexity for each operation is $O(log(N))$.\n  For `getIntervals`, we iterate all the entries in the TreeMap which is the same as traversing the whole tree, so the time complexity is $O(N)$.\n\n* Space complexity: $O(N)$.\n\n  This is just the space to save all the intervals in the TreeMap.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "353",
        "questionFrontendId": "353",
        "title": "Design Snake Game",
        "content": null,
        "likes": 963,
        "dislikes": 341,
        "stats": "{\"totalAccepted\": \"93.3K\", \"totalSubmission\": \"238.7K\", \"totalAcceptedRaw\": 93285, \"totalSubmissionRaw\": 238709, \"acRate\": \"39.1%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Design"
          },
          {
            "name": "Queue"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/design-snake-game/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "354",
        "questionFrontendId": "354",
        "title": "Russian Doll Envelopes",
        "content": "<p>You are given a 2D array of integers <code>envelopes</code> where <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> represents the width and the height of an envelope.</p>\n\n<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&#39;s width and height.</p>\n\n<p>Return <em>the maximum number of envelopes you can Russian doll (i.e., put one inside the other)</em>.</p>\n\n<p><strong>Note:</strong> You cannot rotate an envelope.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>envelopes[i].length == 2</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 6198,
        "dislikes": 156,
        "stats": "{\"totalAccepted\": \"248.3K\", \"totalSubmission\": \"667.4K\", \"totalAcceptedRaw\": 248349, \"totalSubmissionRaw\": 667394, \"acRate\": \"37.2%\"}",
        "similarQuestions": "[{\"title\": \"Longest Increasing Subsequence\", \"titleSlug\": \"longest-increasing-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"The Number of Weak Characters in the Game\", \"titleSlug\": \"the-number-of-weak-characters-in-the-game\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Non-decreasing Subarray From Two Arrays\", \"titleSlug\": \"longest-non-decreasing-subarray-from-two-arrays\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/russian-doll-envelopes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "355",
        "questionFrontendId": "355",
        "title": "Design Twitter",
        "content": "<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the <code>10</code> most recent tweets in the user&#39;s news feed.</p>\n\n<p>Implement the <code>Twitter</code> class:</p>\n\n<ul>\n\t<li><code>Twitter()</code> Initializes your twitter object.</li>\n\t<li><code>void postTweet(int userId, int tweetId)</code> Composes a new tweet with ID <code>tweetId</code> by the user <code>userId</code>. Each call to this function will be made with a unique <code>tweetId</code>.</li>\n\t<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> Retrieves the <code>10</code> most recent tweet IDs in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be <strong>ordered from most recent to least recent</strong>.</li>\n\t<li><code>void follow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started following the user with ID <code>followeeId</code>.</li>\n\t<li><code>void unfollow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started unfollowing the user with ID <code>followeeId</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Twitter&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;follow&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;unfollow&quot;, &quot;getNewsFeed&quot;]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n<strong>Output</strong>\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n<strong>Explanation</strong>\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= userId, followerId, followeeId &lt;= 500</code></li>\n\t<li><code>0 &lt;= tweetId &lt;= 10<sup>4</sup></code></li>\n\t<li>All the tweets have <strong>unique</strong> IDs.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>postTweet</code>, <code>getNewsFeed</code>, <code>follow</code>, and <code>unfollow</code>.</li>\n\t<li>A user cannot follow himself.</li>\n</ul>\n",
        "likes": 4216,
        "dislikes": 596,
        "stats": "{\"totalAccepted\": \"242.7K\", \"totalSubmission\": \"580.8K\", \"totalAcceptedRaw\": 242696, \"totalSubmissionRaw\": 580848, \"acRate\": \"41.8%\"}",
        "similarQuestions": "[{\"title\": \"Design a File Sharing System\", \"titleSlug\": \"design-a-file-sharing-system\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Linked List"
          },
          {
            "name": "Design"
          },
          {
            "name": "Heap (Priority Queue)"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/design-twitter/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "356",
        "questionFrontendId": "356",
        "title": "Line Reflection",
        "content": null,
        "likes": 310,
        "dislikes": 633,
        "stats": "{\"totalAccepted\": \"43.6K\", \"totalSubmission\": \"121.3K\", \"totalAcceptedRaw\": 43563, \"totalSubmissionRaw\": 121333, \"acRate\": \"35.9%\"}",
        "similarQuestions": "[{\"title\": \"Max Points on a Line\", \"titleSlug\": \"max-points-on-a-line\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Boomerangs\", \"titleSlug\": \"number-of-boomerangs\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Find the smallest and largest x-value for all points.",
          "If there is a line then it should be at y = (minX + maxX) / 2.",
          "For each point, make sure that it has a reflected point in the opposite side."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": true,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/line-reflection/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "357",
        "questionFrontendId": "357",
        "title": "Count Numbers with Unique Digits",
        "content": "<p>Given an integer <code>n</code>, return the count of all numbers with unique digits, <code>x</code>, where <code>0 &lt;= x &lt; 10<sup>n</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 91\n<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 &le; x &lt; 100, excluding 11,22,33,44,55,66,77,88,99\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "likes": 1612,
        "dislikes": 1507,
        "stats": "{\"totalAccepted\": \"159.8K\", \"totalSubmission\": \"295.4K\", \"totalAcceptedRaw\": 159827, \"totalSubmissionRaw\": 295440, \"acRate\": \"54.1%\"}",
        "similarQuestions": "[{\"title\": \"Count Special Integers\", \"titleSlug\": \"count-special-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Numbers With Unique Digits II\", \"titleSlug\": \"count-numbers-with-unique-digits-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "A direct way is to use the backtracking approach.",
          "Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10<sup>n</sup>.",
          "This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.",
          "Let f(k) = count of numbers with unique digits with length equals k.",
          "f(1) = 10, ..., f(k) = 9 * 9 * 8 * ... (9 - k + 2) [The first factor is 9 because a number cannot start with 0]."
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": null,
        "hasSolution": false,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-numbers-with-unique-digits/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "358",
        "questionFrontendId": "358",
        "title": "Rearrange String k Distance Apart",
        "content": null,
        "likes": 981,
        "dislikes": 39,
        "stats": "{\"totalAccepted\": \"69.4K\", \"totalSubmission\": \"176.4K\", \"totalAcceptedRaw\": 69355, \"totalSubmissionRaw\": 176414, \"acRate\": \"39.3%\"}",
        "similarQuestions": "[{\"title\": \"Task Scheduler\", \"titleSlug\": \"task-scheduler\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reorganize String\", \"titleSlug\": \"reorganize-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Construct String With Repeat Limit\", \"titleSlug\": \"construct-string-with-repeat-limit\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Sorting"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Counting"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": true,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rearrange-string-k-distance-apart/"
      }
    }
  }
]